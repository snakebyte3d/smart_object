// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'smart_object_registry.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

SmartObjectRegistry _$SmartObjectRegistryFromJson(Map<String, dynamic> json) {
  return _SmartObjectRegistry.fromJson(json);
}

/// @nodoc
class _$SmartObjectRegistryTearOff {
  const _$SmartObjectRegistryTearOff();

  _SmartObjectRegistry call(
      {required RspCode rspCode,
      required CmdId cmdId,
      required Map<String, int> oid,
      required Map<String, int> uniqueRid,
      required SpecificRid specificRid,
      required ObjectSpec objectSpec,
      required SpecificResrcChar specificResrcChar}) {
    return _SmartObjectRegistry(
      rspCode: rspCode,
      cmdId: cmdId,
      oid: oid,
      uniqueRid: uniqueRid,
      specificRid: specificRid,
      objectSpec: objectSpec,
      specificResrcChar: specificResrcChar,
    );
  }

  SmartObjectRegistry fromJson(Map<String, Object> json) {
    return SmartObjectRegistry.fromJson(json);
  }
}

/// @nodoc
const $SmartObjectRegistry = _$SmartObjectRegistryTearOff();

/// @nodoc
mixin _$SmartObjectRegistry {
  RspCode get rspCode => throw _privateConstructorUsedError;
  CmdId get cmdId => throw _privateConstructorUsedError;
  Map<String, int> get oid => throw _privateConstructorUsedError;
  Map<String, int> get uniqueRid => throw _privateConstructorUsedError;
  SpecificRid get specificRid => throw _privateConstructorUsedError;
  ObjectSpec get objectSpec => throw _privateConstructorUsedError;
  SpecificResrcChar get specificResrcChar => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SmartObjectRegistryCopyWith<SmartObjectRegistry> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SmartObjectRegistryCopyWith<$Res> {
  factory $SmartObjectRegistryCopyWith(
          SmartObjectRegistry value, $Res Function(SmartObjectRegistry) then) =
      _$SmartObjectRegistryCopyWithImpl<$Res>;
  $Res call(
      {RspCode rspCode,
      CmdId cmdId,
      Map<String, int> oid,
      Map<String, int> uniqueRid,
      SpecificRid specificRid,
      ObjectSpec objectSpec,
      SpecificResrcChar specificResrcChar});

  $RspCodeCopyWith<$Res> get rspCode;
  $CmdIdCopyWith<$Res> get cmdId;
  $SpecificRidCopyWith<$Res> get specificRid;
  $ObjectSpecCopyWith<$Res> get objectSpec;
  $SpecificResrcCharCopyWith<$Res> get specificResrcChar;
}

/// @nodoc
class _$SmartObjectRegistryCopyWithImpl<$Res>
    implements $SmartObjectRegistryCopyWith<$Res> {
  _$SmartObjectRegistryCopyWithImpl(this._value, this._then);

  final SmartObjectRegistry _value;
  // ignore: unused_field
  final $Res Function(SmartObjectRegistry) _then;

  @override
  $Res call({
    Object? rspCode = freezed,
    Object? cmdId = freezed,
    Object? oid = freezed,
    Object? uniqueRid = freezed,
    Object? specificRid = freezed,
    Object? objectSpec = freezed,
    Object? specificResrcChar = freezed,
  }) {
    return _then(_value.copyWith(
      rspCode: rspCode == freezed
          ? _value.rspCode
          : rspCode // ignore: cast_nullable_to_non_nullable
              as RspCode,
      cmdId: cmdId == freezed
          ? _value.cmdId
          : cmdId // ignore: cast_nullable_to_non_nullable
              as CmdId,
      oid: oid == freezed
          ? _value.oid
          : oid // ignore: cast_nullable_to_non_nullable
              as Map<String, int>,
      uniqueRid: uniqueRid == freezed
          ? _value.uniqueRid
          : uniqueRid // ignore: cast_nullable_to_non_nullable
              as Map<String, int>,
      specificRid: specificRid == freezed
          ? _value.specificRid
          : specificRid // ignore: cast_nullable_to_non_nullable
              as SpecificRid,
      objectSpec: objectSpec == freezed
          ? _value.objectSpec
          : objectSpec // ignore: cast_nullable_to_non_nullable
              as ObjectSpec,
      specificResrcChar: specificResrcChar == freezed
          ? _value.specificResrcChar
          : specificResrcChar // ignore: cast_nullable_to_non_nullable
              as SpecificResrcChar,
    ));
  }

  @override
  $RspCodeCopyWith<$Res> get rspCode {
    return $RspCodeCopyWith<$Res>(_value.rspCode, (value) {
      return _then(_value.copyWith(rspCode: value));
    });
  }

  @override
  $CmdIdCopyWith<$Res> get cmdId {
    return $CmdIdCopyWith<$Res>(_value.cmdId, (value) {
      return _then(_value.copyWith(cmdId: value));
    });
  }

  @override
  $SpecificRidCopyWith<$Res> get specificRid {
    return $SpecificRidCopyWith<$Res>(_value.specificRid, (value) {
      return _then(_value.copyWith(specificRid: value));
    });
  }

  @override
  $ObjectSpecCopyWith<$Res> get objectSpec {
    return $ObjectSpecCopyWith<$Res>(_value.objectSpec, (value) {
      return _then(_value.copyWith(objectSpec: value));
    });
  }

  @override
  $SpecificResrcCharCopyWith<$Res> get specificResrcChar {
    return $SpecificResrcCharCopyWith<$Res>(_value.specificResrcChar, (value) {
      return _then(_value.copyWith(specificResrcChar: value));
    });
  }
}

/// @nodoc
abstract class _$SmartObjectRegistryCopyWith<$Res>
    implements $SmartObjectRegistryCopyWith<$Res> {
  factory _$SmartObjectRegistryCopyWith(_SmartObjectRegistry value,
          $Res Function(_SmartObjectRegistry) then) =
      __$SmartObjectRegistryCopyWithImpl<$Res>;
  @override
  $Res call(
      {RspCode rspCode,
      CmdId cmdId,
      Map<String, int> oid,
      Map<String, int> uniqueRid,
      SpecificRid specificRid,
      ObjectSpec objectSpec,
      SpecificResrcChar specificResrcChar});

  @override
  $RspCodeCopyWith<$Res> get rspCode;
  @override
  $CmdIdCopyWith<$Res> get cmdId;
  @override
  $SpecificRidCopyWith<$Res> get specificRid;
  @override
  $ObjectSpecCopyWith<$Res> get objectSpec;
  @override
  $SpecificResrcCharCopyWith<$Res> get specificResrcChar;
}

/// @nodoc
class __$SmartObjectRegistryCopyWithImpl<$Res>
    extends _$SmartObjectRegistryCopyWithImpl<$Res>
    implements _$SmartObjectRegistryCopyWith<$Res> {
  __$SmartObjectRegistryCopyWithImpl(
      _SmartObjectRegistry _value, $Res Function(_SmartObjectRegistry) _then)
      : super(_value, (v) => _then(v as _SmartObjectRegistry));

  @override
  _SmartObjectRegistry get _value => super._value as _SmartObjectRegistry;

  @override
  $Res call({
    Object? rspCode = freezed,
    Object? cmdId = freezed,
    Object? oid = freezed,
    Object? uniqueRid = freezed,
    Object? specificRid = freezed,
    Object? objectSpec = freezed,
    Object? specificResrcChar = freezed,
  }) {
    return _then(_SmartObjectRegistry(
      rspCode: rspCode == freezed
          ? _value.rspCode
          : rspCode // ignore: cast_nullable_to_non_nullable
              as RspCode,
      cmdId: cmdId == freezed
          ? _value.cmdId
          : cmdId // ignore: cast_nullable_to_non_nullable
              as CmdId,
      oid: oid == freezed
          ? _value.oid
          : oid // ignore: cast_nullable_to_non_nullable
              as Map<String, int>,
      uniqueRid: uniqueRid == freezed
          ? _value.uniqueRid
          : uniqueRid // ignore: cast_nullable_to_non_nullable
              as Map<String, int>,
      specificRid: specificRid == freezed
          ? _value.specificRid
          : specificRid // ignore: cast_nullable_to_non_nullable
              as SpecificRid,
      objectSpec: objectSpec == freezed
          ? _value.objectSpec
          : objectSpec // ignore: cast_nullable_to_non_nullable
              as ObjectSpec,
      specificResrcChar: specificResrcChar == freezed
          ? _value.specificResrcChar
          : specificResrcChar // ignore: cast_nullable_to_non_nullable
              as SpecificResrcChar,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SmartObjectRegistry implements _SmartObjectRegistry {
  const _$_SmartObjectRegistry(
      {required this.rspCode,
      required this.cmdId,
      required this.oid,
      required this.uniqueRid,
      required this.specificRid,
      required this.objectSpec,
      required this.specificResrcChar});

  factory _$_SmartObjectRegistry.fromJson(Map<String, dynamic> json) =>
      _$$_SmartObjectRegistryFromJson(json);

  @override
  final RspCode rspCode;
  @override
  final CmdId cmdId;
  @override
  final Map<String, int> oid;
  @override
  final Map<String, int> uniqueRid;
  @override
  final SpecificRid specificRid;
  @override
  final ObjectSpec objectSpec;
  @override
  final SpecificResrcChar specificResrcChar;

  @override
  String toString() {
    return 'SmartObjectRegistry(rspCode: $rspCode, cmdId: $cmdId, oid: $oid, uniqueRid: $uniqueRid, specificRid: $specificRid, objectSpec: $objectSpec, specificResrcChar: $specificResrcChar)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SmartObjectRegistry &&
            (identical(other.rspCode, rspCode) ||
                const DeepCollectionEquality()
                    .equals(other.rspCode, rspCode)) &&
            (identical(other.cmdId, cmdId) ||
                const DeepCollectionEquality().equals(other.cmdId, cmdId)) &&
            (identical(other.oid, oid) ||
                const DeepCollectionEquality().equals(other.oid, oid)) &&
            (identical(other.uniqueRid, uniqueRid) ||
                const DeepCollectionEquality()
                    .equals(other.uniqueRid, uniqueRid)) &&
            (identical(other.specificRid, specificRid) ||
                const DeepCollectionEquality()
                    .equals(other.specificRid, specificRid)) &&
            (identical(other.objectSpec, objectSpec) ||
                const DeepCollectionEquality()
                    .equals(other.objectSpec, objectSpec)) &&
            (identical(other.specificResrcChar, specificResrcChar) ||
                const DeepCollectionEquality()
                    .equals(other.specificResrcChar, specificResrcChar)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(rspCode) ^
      const DeepCollectionEquality().hash(cmdId) ^
      const DeepCollectionEquality().hash(oid) ^
      const DeepCollectionEquality().hash(uniqueRid) ^
      const DeepCollectionEquality().hash(specificRid) ^
      const DeepCollectionEquality().hash(objectSpec) ^
      const DeepCollectionEquality().hash(specificResrcChar);

  @JsonKey(ignore: true)
  @override
  _$SmartObjectRegistryCopyWith<_SmartObjectRegistry> get copyWith =>
      __$SmartObjectRegistryCopyWithImpl<_SmartObjectRegistry>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SmartObjectRegistryToJson(this);
  }
}

abstract class _SmartObjectRegistry implements SmartObjectRegistry {
  const factory _SmartObjectRegistry(
      {required RspCode rspCode,
      required CmdId cmdId,
      required Map<String, int> oid,
      required Map<String, int> uniqueRid,
      required SpecificRid specificRid,
      required ObjectSpec objectSpec,
      required SpecificResrcChar specificResrcChar}) = _$_SmartObjectRegistry;

  factory _SmartObjectRegistry.fromJson(Map<String, dynamic> json) =
      _$_SmartObjectRegistry.fromJson;

  @override
  RspCode get rspCode => throw _privateConstructorUsedError;
  @override
  CmdId get cmdId => throw _privateConstructorUsedError;
  @override
  Map<String, int> get oid => throw _privateConstructorUsedError;
  @override
  Map<String, int> get uniqueRid => throw _privateConstructorUsedError;
  @override
  SpecificRid get specificRid => throw _privateConstructorUsedError;
  @override
  ObjectSpec get objectSpec => throw _privateConstructorUsedError;
  @override
  SpecificResrcChar get specificResrcChar => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SmartObjectRegistryCopyWith<_SmartObjectRegistry> get copyWith =>
      throw _privateConstructorUsedError;
}

RspCode _$RspCodeFromJson(Map<String, dynamic> json) {
  return _RspCode.fromJson(json);
}

/// @nodoc
class _$RspCodeTearOff {
  const _$RspCodeTearOff();

  _RspCode call(
      {required int OK,
      required int Created,
      required int Deleted,
      required int Changed,
      required int Content,
      required int BadRequest,
      required int Unauthorized,
      required int Forbidden,
      required int NotFound,
      required int MethodNotAllowed,
      required int Timeout,
      required int Conflict,
      required int InternalServerError}) {
    return _RspCode(
      OK: OK,
      Created: Created,
      Deleted: Deleted,
      Changed: Changed,
      Content: Content,
      BadRequest: BadRequest,
      Unauthorized: Unauthorized,
      Forbidden: Forbidden,
      NotFound: NotFound,
      MethodNotAllowed: MethodNotAllowed,
      Timeout: Timeout,
      Conflict: Conflict,
      InternalServerError: InternalServerError,
    );
  }

  RspCode fromJson(Map<String, Object> json) {
    return RspCode.fromJson(json);
  }
}

/// @nodoc
const $RspCode = _$RspCodeTearOff();

/// @nodoc
mixin _$RspCode {
  int get OK => throw _privateConstructorUsedError;
  int get Created => throw _privateConstructorUsedError;
  int get Deleted => throw _privateConstructorUsedError;
  int get Changed => throw _privateConstructorUsedError;
  int get Content => throw _privateConstructorUsedError;
  int get BadRequest => throw _privateConstructorUsedError;
  int get Unauthorized => throw _privateConstructorUsedError;
  int get Forbidden => throw _privateConstructorUsedError;
  int get NotFound => throw _privateConstructorUsedError;
  int get MethodNotAllowed => throw _privateConstructorUsedError;
  int get Timeout => throw _privateConstructorUsedError;
  int get Conflict => throw _privateConstructorUsedError;
  int get InternalServerError => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RspCodeCopyWith<RspCode> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RspCodeCopyWith<$Res> {
  factory $RspCodeCopyWith(RspCode value, $Res Function(RspCode) then) =
      _$RspCodeCopyWithImpl<$Res>;
  $Res call(
      {int OK,
      int Created,
      int Deleted,
      int Changed,
      int Content,
      int BadRequest,
      int Unauthorized,
      int Forbidden,
      int NotFound,
      int MethodNotAllowed,
      int Timeout,
      int Conflict,
      int InternalServerError});
}

/// @nodoc
class _$RspCodeCopyWithImpl<$Res> implements $RspCodeCopyWith<$Res> {
  _$RspCodeCopyWithImpl(this._value, this._then);

  final RspCode _value;
  // ignore: unused_field
  final $Res Function(RspCode) _then;

  @override
  $Res call({
    Object? OK = freezed,
    Object? Created = freezed,
    Object? Deleted = freezed,
    Object? Changed = freezed,
    Object? Content = freezed,
    Object? BadRequest = freezed,
    Object? Unauthorized = freezed,
    Object? Forbidden = freezed,
    Object? NotFound = freezed,
    Object? MethodNotAllowed = freezed,
    Object? Timeout = freezed,
    Object? Conflict = freezed,
    Object? InternalServerError = freezed,
  }) {
    return _then(_value.copyWith(
      OK: OK == freezed
          ? _value.OK
          : OK // ignore: cast_nullable_to_non_nullable
              as int,
      Created: Created == freezed
          ? _value.Created
          : Created // ignore: cast_nullable_to_non_nullable
              as int,
      Deleted: Deleted == freezed
          ? _value.Deleted
          : Deleted // ignore: cast_nullable_to_non_nullable
              as int,
      Changed: Changed == freezed
          ? _value.Changed
          : Changed // ignore: cast_nullable_to_non_nullable
              as int,
      Content: Content == freezed
          ? _value.Content
          : Content // ignore: cast_nullable_to_non_nullable
              as int,
      BadRequest: BadRequest == freezed
          ? _value.BadRequest
          : BadRequest // ignore: cast_nullable_to_non_nullable
              as int,
      Unauthorized: Unauthorized == freezed
          ? _value.Unauthorized
          : Unauthorized // ignore: cast_nullable_to_non_nullable
              as int,
      Forbidden: Forbidden == freezed
          ? _value.Forbidden
          : Forbidden // ignore: cast_nullable_to_non_nullable
              as int,
      NotFound: NotFound == freezed
          ? _value.NotFound
          : NotFound // ignore: cast_nullable_to_non_nullable
              as int,
      MethodNotAllowed: MethodNotAllowed == freezed
          ? _value.MethodNotAllowed
          : MethodNotAllowed // ignore: cast_nullable_to_non_nullable
              as int,
      Timeout: Timeout == freezed
          ? _value.Timeout
          : Timeout // ignore: cast_nullable_to_non_nullable
              as int,
      Conflict: Conflict == freezed
          ? _value.Conflict
          : Conflict // ignore: cast_nullable_to_non_nullable
              as int,
      InternalServerError: InternalServerError == freezed
          ? _value.InternalServerError
          : InternalServerError // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$RspCodeCopyWith<$Res> implements $RspCodeCopyWith<$Res> {
  factory _$RspCodeCopyWith(_RspCode value, $Res Function(_RspCode) then) =
      __$RspCodeCopyWithImpl<$Res>;
  @override
  $Res call(
      {int OK,
      int Created,
      int Deleted,
      int Changed,
      int Content,
      int BadRequest,
      int Unauthorized,
      int Forbidden,
      int NotFound,
      int MethodNotAllowed,
      int Timeout,
      int Conflict,
      int InternalServerError});
}

/// @nodoc
class __$RspCodeCopyWithImpl<$Res> extends _$RspCodeCopyWithImpl<$Res>
    implements _$RspCodeCopyWith<$Res> {
  __$RspCodeCopyWithImpl(_RspCode _value, $Res Function(_RspCode) _then)
      : super(_value, (v) => _then(v as _RspCode));

  @override
  _RspCode get _value => super._value as _RspCode;

  @override
  $Res call({
    Object? OK = freezed,
    Object? Created = freezed,
    Object? Deleted = freezed,
    Object? Changed = freezed,
    Object? Content = freezed,
    Object? BadRequest = freezed,
    Object? Unauthorized = freezed,
    Object? Forbidden = freezed,
    Object? NotFound = freezed,
    Object? MethodNotAllowed = freezed,
    Object? Timeout = freezed,
    Object? Conflict = freezed,
    Object? InternalServerError = freezed,
  }) {
    return _then(_RspCode(
      OK: OK == freezed
          ? _value.OK
          : OK // ignore: cast_nullable_to_non_nullable
              as int,
      Created: Created == freezed
          ? _value.Created
          : Created // ignore: cast_nullable_to_non_nullable
              as int,
      Deleted: Deleted == freezed
          ? _value.Deleted
          : Deleted // ignore: cast_nullable_to_non_nullable
              as int,
      Changed: Changed == freezed
          ? _value.Changed
          : Changed // ignore: cast_nullable_to_non_nullable
              as int,
      Content: Content == freezed
          ? _value.Content
          : Content // ignore: cast_nullable_to_non_nullable
              as int,
      BadRequest: BadRequest == freezed
          ? _value.BadRequest
          : BadRequest // ignore: cast_nullable_to_non_nullable
              as int,
      Unauthorized: Unauthorized == freezed
          ? _value.Unauthorized
          : Unauthorized // ignore: cast_nullable_to_non_nullable
              as int,
      Forbidden: Forbidden == freezed
          ? _value.Forbidden
          : Forbidden // ignore: cast_nullable_to_non_nullable
              as int,
      NotFound: NotFound == freezed
          ? _value.NotFound
          : NotFound // ignore: cast_nullable_to_non_nullable
              as int,
      MethodNotAllowed: MethodNotAllowed == freezed
          ? _value.MethodNotAllowed
          : MethodNotAllowed // ignore: cast_nullable_to_non_nullable
              as int,
      Timeout: Timeout == freezed
          ? _value.Timeout
          : Timeout // ignore: cast_nullable_to_non_nullable
              as int,
      Conflict: Conflict == freezed
          ? _value.Conflict
          : Conflict // ignore: cast_nullable_to_non_nullable
              as int,
      InternalServerError: InternalServerError == freezed
          ? _value.InternalServerError
          : InternalServerError // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_RspCode implements _RspCode {
  const _$_RspCode(
      {required this.OK,
      required this.Created,
      required this.Deleted,
      required this.Changed,
      required this.Content,
      required this.BadRequest,
      required this.Unauthorized,
      required this.Forbidden,
      required this.NotFound,
      required this.MethodNotAllowed,
      required this.Timeout,
      required this.Conflict,
      required this.InternalServerError});

  factory _$_RspCode.fromJson(Map<String, dynamic> json) =>
      _$$_RspCodeFromJson(json);

  @override
  final int OK;
  @override
  final int Created;
  @override
  final int Deleted;
  @override
  final int Changed;
  @override
  final int Content;
  @override
  final int BadRequest;
  @override
  final int Unauthorized;
  @override
  final int Forbidden;
  @override
  final int NotFound;
  @override
  final int MethodNotAllowed;
  @override
  final int Timeout;
  @override
  final int Conflict;
  @override
  final int InternalServerError;

  @override
  String toString() {
    return 'RspCode(OK: $OK, Created: $Created, Deleted: $Deleted, Changed: $Changed, Content: $Content, BadRequest: $BadRequest, Unauthorized: $Unauthorized, Forbidden: $Forbidden, NotFound: $NotFound, MethodNotAllowed: $MethodNotAllowed, Timeout: $Timeout, Conflict: $Conflict, InternalServerError: $InternalServerError)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _RspCode &&
            (identical(other.OK, OK) ||
                const DeepCollectionEquality().equals(other.OK, OK)) &&
            (identical(other.Created, Created) ||
                const DeepCollectionEquality()
                    .equals(other.Created, Created)) &&
            (identical(other.Deleted, Deleted) ||
                const DeepCollectionEquality()
                    .equals(other.Deleted, Deleted)) &&
            (identical(other.Changed, Changed) ||
                const DeepCollectionEquality()
                    .equals(other.Changed, Changed)) &&
            (identical(other.Content, Content) ||
                const DeepCollectionEquality()
                    .equals(other.Content, Content)) &&
            (identical(other.BadRequest, BadRequest) ||
                const DeepCollectionEquality()
                    .equals(other.BadRequest, BadRequest)) &&
            (identical(other.Unauthorized, Unauthorized) ||
                const DeepCollectionEquality()
                    .equals(other.Unauthorized, Unauthorized)) &&
            (identical(other.Forbidden, Forbidden) ||
                const DeepCollectionEquality()
                    .equals(other.Forbidden, Forbidden)) &&
            (identical(other.NotFound, NotFound) ||
                const DeepCollectionEquality()
                    .equals(other.NotFound, NotFound)) &&
            (identical(other.MethodNotAllowed, MethodNotAllowed) ||
                const DeepCollectionEquality()
                    .equals(other.MethodNotAllowed, MethodNotAllowed)) &&
            (identical(other.Timeout, Timeout) ||
                const DeepCollectionEquality()
                    .equals(other.Timeout, Timeout)) &&
            (identical(other.Conflict, Conflict) ||
                const DeepCollectionEquality()
                    .equals(other.Conflict, Conflict)) &&
            (identical(other.InternalServerError, InternalServerError) ||
                const DeepCollectionEquality()
                    .equals(other.InternalServerError, InternalServerError)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(OK) ^
      const DeepCollectionEquality().hash(Created) ^
      const DeepCollectionEquality().hash(Deleted) ^
      const DeepCollectionEquality().hash(Changed) ^
      const DeepCollectionEquality().hash(Content) ^
      const DeepCollectionEquality().hash(BadRequest) ^
      const DeepCollectionEquality().hash(Unauthorized) ^
      const DeepCollectionEquality().hash(Forbidden) ^
      const DeepCollectionEquality().hash(NotFound) ^
      const DeepCollectionEquality().hash(MethodNotAllowed) ^
      const DeepCollectionEquality().hash(Timeout) ^
      const DeepCollectionEquality().hash(Conflict) ^
      const DeepCollectionEquality().hash(InternalServerError);

  @JsonKey(ignore: true)
  @override
  _$RspCodeCopyWith<_RspCode> get copyWith =>
      __$RspCodeCopyWithImpl<_RspCode>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_RspCodeToJson(this);
  }
}

abstract class _RspCode implements RspCode {
  const factory _RspCode(
      {required int OK,
      required int Created,
      required int Deleted,
      required int Changed,
      required int Content,
      required int BadRequest,
      required int Unauthorized,
      required int Forbidden,
      required int NotFound,
      required int MethodNotAllowed,
      required int Timeout,
      required int Conflict,
      required int InternalServerError}) = _$_RspCode;

  factory _RspCode.fromJson(Map<String, dynamic> json) = _$_RspCode.fromJson;

  @override
  int get OK => throw _privateConstructorUsedError;
  @override
  int get Created => throw _privateConstructorUsedError;
  @override
  int get Deleted => throw _privateConstructorUsedError;
  @override
  int get Changed => throw _privateConstructorUsedError;
  @override
  int get Content => throw _privateConstructorUsedError;
  @override
  int get BadRequest => throw _privateConstructorUsedError;
  @override
  int get Unauthorized => throw _privateConstructorUsedError;
  @override
  int get Forbidden => throw _privateConstructorUsedError;
  @override
  int get NotFound => throw _privateConstructorUsedError;
  @override
  int get MethodNotAllowed => throw _privateConstructorUsedError;
  @override
  int get Timeout => throw _privateConstructorUsedError;
  @override
  int get Conflict => throw _privateConstructorUsedError;
  @override
  int get InternalServerError => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$RspCodeCopyWith<_RspCode> get copyWith =>
      throw _privateConstructorUsedError;
}

CmdId _$CmdIdFromJson(Map<String, dynamic> json) {
  return _CmdId.fromJson(json);
}

/// @nodoc
class _$CmdIdTearOff {
  const _$CmdIdTearOff();

  _CmdId call(
      {required int read,
      required int write,
      required int discover,
      required int writeAttrs,
      required int execute,
      required int observe,
      required int notify,
      required int ping,
      required int unknown}) {
    return _CmdId(
      read: read,
      write: write,
      discover: discover,
      writeAttrs: writeAttrs,
      execute: execute,
      observe: observe,
      notify: notify,
      ping: ping,
      unknown: unknown,
    );
  }

  CmdId fromJson(Map<String, Object> json) {
    return CmdId.fromJson(json);
  }
}

/// @nodoc
const $CmdId = _$CmdIdTearOff();

/// @nodoc
mixin _$CmdId {
  int get read => throw _privateConstructorUsedError;
  int get write => throw _privateConstructorUsedError;
  int get discover => throw _privateConstructorUsedError;
  int get writeAttrs => throw _privateConstructorUsedError;
  int get execute => throw _privateConstructorUsedError;
  int get observe => throw _privateConstructorUsedError;
  int get notify => throw _privateConstructorUsedError;
  int get ping => throw _privateConstructorUsedError;
  int get unknown => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CmdIdCopyWith<CmdId> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CmdIdCopyWith<$Res> {
  factory $CmdIdCopyWith(CmdId value, $Res Function(CmdId) then) =
      _$CmdIdCopyWithImpl<$Res>;
  $Res call(
      {int read,
      int write,
      int discover,
      int writeAttrs,
      int execute,
      int observe,
      int notify,
      int ping,
      int unknown});
}

/// @nodoc
class _$CmdIdCopyWithImpl<$Res> implements $CmdIdCopyWith<$Res> {
  _$CmdIdCopyWithImpl(this._value, this._then);

  final CmdId _value;
  // ignore: unused_field
  final $Res Function(CmdId) _then;

  @override
  $Res call({
    Object? read = freezed,
    Object? write = freezed,
    Object? discover = freezed,
    Object? writeAttrs = freezed,
    Object? execute = freezed,
    Object? observe = freezed,
    Object? notify = freezed,
    Object? ping = freezed,
    Object? unknown = freezed,
  }) {
    return _then(_value.copyWith(
      read: read == freezed
          ? _value.read
          : read // ignore: cast_nullable_to_non_nullable
              as int,
      write: write == freezed
          ? _value.write
          : write // ignore: cast_nullable_to_non_nullable
              as int,
      discover: discover == freezed
          ? _value.discover
          : discover // ignore: cast_nullable_to_non_nullable
              as int,
      writeAttrs: writeAttrs == freezed
          ? _value.writeAttrs
          : writeAttrs // ignore: cast_nullable_to_non_nullable
              as int,
      execute: execute == freezed
          ? _value.execute
          : execute // ignore: cast_nullable_to_non_nullable
              as int,
      observe: observe == freezed
          ? _value.observe
          : observe // ignore: cast_nullable_to_non_nullable
              as int,
      notify: notify == freezed
          ? _value.notify
          : notify // ignore: cast_nullable_to_non_nullable
              as int,
      ping: ping == freezed
          ? _value.ping
          : ping // ignore: cast_nullable_to_non_nullable
              as int,
      unknown: unknown == freezed
          ? _value.unknown
          : unknown // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$CmdIdCopyWith<$Res> implements $CmdIdCopyWith<$Res> {
  factory _$CmdIdCopyWith(_CmdId value, $Res Function(_CmdId) then) =
      __$CmdIdCopyWithImpl<$Res>;
  @override
  $Res call(
      {int read,
      int write,
      int discover,
      int writeAttrs,
      int execute,
      int observe,
      int notify,
      int ping,
      int unknown});
}

/// @nodoc
class __$CmdIdCopyWithImpl<$Res> extends _$CmdIdCopyWithImpl<$Res>
    implements _$CmdIdCopyWith<$Res> {
  __$CmdIdCopyWithImpl(_CmdId _value, $Res Function(_CmdId) _then)
      : super(_value, (v) => _then(v as _CmdId));

  @override
  _CmdId get _value => super._value as _CmdId;

  @override
  $Res call({
    Object? read = freezed,
    Object? write = freezed,
    Object? discover = freezed,
    Object? writeAttrs = freezed,
    Object? execute = freezed,
    Object? observe = freezed,
    Object? notify = freezed,
    Object? ping = freezed,
    Object? unknown = freezed,
  }) {
    return _then(_CmdId(
      read: read == freezed
          ? _value.read
          : read // ignore: cast_nullable_to_non_nullable
              as int,
      write: write == freezed
          ? _value.write
          : write // ignore: cast_nullable_to_non_nullable
              as int,
      discover: discover == freezed
          ? _value.discover
          : discover // ignore: cast_nullable_to_non_nullable
              as int,
      writeAttrs: writeAttrs == freezed
          ? _value.writeAttrs
          : writeAttrs // ignore: cast_nullable_to_non_nullable
              as int,
      execute: execute == freezed
          ? _value.execute
          : execute // ignore: cast_nullable_to_non_nullable
              as int,
      observe: observe == freezed
          ? _value.observe
          : observe // ignore: cast_nullable_to_non_nullable
              as int,
      notify: notify == freezed
          ? _value.notify
          : notify // ignore: cast_nullable_to_non_nullable
              as int,
      ping: ping == freezed
          ? _value.ping
          : ping // ignore: cast_nullable_to_non_nullable
              as int,
      unknown: unknown == freezed
          ? _value.unknown
          : unknown // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_CmdId implements _CmdId {
  const _$_CmdId(
      {required this.read,
      required this.write,
      required this.discover,
      required this.writeAttrs,
      required this.execute,
      required this.observe,
      required this.notify,
      required this.ping,
      required this.unknown});

  factory _$_CmdId.fromJson(Map<String, dynamic> json) =>
      _$$_CmdIdFromJson(json);

  @override
  final int read;
  @override
  final int write;
  @override
  final int discover;
  @override
  final int writeAttrs;
  @override
  final int execute;
  @override
  final int observe;
  @override
  final int notify;
  @override
  final int ping;
  @override
  final int unknown;

  @override
  String toString() {
    return 'CmdId(read: $read, write: $write, discover: $discover, writeAttrs: $writeAttrs, execute: $execute, observe: $observe, notify: $notify, ping: $ping, unknown: $unknown)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _CmdId &&
            (identical(other.read, read) ||
                const DeepCollectionEquality().equals(other.read, read)) &&
            (identical(other.write, write) ||
                const DeepCollectionEquality().equals(other.write, write)) &&
            (identical(other.discover, discover) ||
                const DeepCollectionEquality()
                    .equals(other.discover, discover)) &&
            (identical(other.writeAttrs, writeAttrs) ||
                const DeepCollectionEquality()
                    .equals(other.writeAttrs, writeAttrs)) &&
            (identical(other.execute, execute) ||
                const DeepCollectionEquality()
                    .equals(other.execute, execute)) &&
            (identical(other.observe, observe) ||
                const DeepCollectionEquality()
                    .equals(other.observe, observe)) &&
            (identical(other.notify, notify) ||
                const DeepCollectionEquality().equals(other.notify, notify)) &&
            (identical(other.ping, ping) ||
                const DeepCollectionEquality().equals(other.ping, ping)) &&
            (identical(other.unknown, unknown) ||
                const DeepCollectionEquality().equals(other.unknown, unknown)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(read) ^
      const DeepCollectionEquality().hash(write) ^
      const DeepCollectionEquality().hash(discover) ^
      const DeepCollectionEquality().hash(writeAttrs) ^
      const DeepCollectionEquality().hash(execute) ^
      const DeepCollectionEquality().hash(observe) ^
      const DeepCollectionEquality().hash(notify) ^
      const DeepCollectionEquality().hash(ping) ^
      const DeepCollectionEquality().hash(unknown);

  @JsonKey(ignore: true)
  @override
  _$CmdIdCopyWith<_CmdId> get copyWith =>
      __$CmdIdCopyWithImpl<_CmdId>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CmdIdToJson(this);
  }
}

abstract class _CmdId implements CmdId {
  const factory _CmdId(
      {required int read,
      required int write,
      required int discover,
      required int writeAttrs,
      required int execute,
      required int observe,
      required int notify,
      required int ping,
      required int unknown}) = _$_CmdId;

  factory _CmdId.fromJson(Map<String, dynamic> json) = _$_CmdId.fromJson;

  @override
  int get read => throw _privateConstructorUsedError;
  @override
  int get write => throw _privateConstructorUsedError;
  @override
  int get discover => throw _privateConstructorUsedError;
  @override
  int get writeAttrs => throw _privateConstructorUsedError;
  @override
  int get execute => throw _privateConstructorUsedError;
  @override
  int get observe => throw _privateConstructorUsedError;
  @override
  int get notify => throw _privateConstructorUsedError;
  @override
  int get ping => throw _privateConstructorUsedError;
  @override
  int get unknown => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$CmdIdCopyWith<_CmdId> get copyWith => throw _privateConstructorUsedError;
}

ObjectSpec _$ObjectSpecFromJson(Map<String, dynamic> json) {
  return _ObjectSpec.fromJson(json);
}

/// @nodoc
class _$ObjectSpecTearOff {
  const _$ObjectSpecTearOff();

  _ObjectSpec call(
      {required InstanceCtrl lwm2mSecurity,
      required InstanceCtrl lwm2mServer,
      required InstanceCtrl accessCtrl,
      required InstanceCtrl device,
      required InstanceCtrl connMonitor,
      required InstanceCtrl firmware,
      required InstanceCtrl location,
      required InstanceCtrl connStatistics}) {
    return _ObjectSpec(
      lwm2mSecurity: lwm2mSecurity,
      lwm2mServer: lwm2mServer,
      accessCtrl: accessCtrl,
      device: device,
      connMonitor: connMonitor,
      firmware: firmware,
      location: location,
      connStatistics: connStatistics,
    );
  }

  ObjectSpec fromJson(Map<String, Object> json) {
    return ObjectSpec.fromJson(json);
  }
}

/// @nodoc
const $ObjectSpec = _$ObjectSpecTearOff();

/// @nodoc
mixin _$ObjectSpec {
  InstanceCtrl get lwm2mSecurity => throw _privateConstructorUsedError;
  InstanceCtrl get lwm2mServer => throw _privateConstructorUsedError;
  InstanceCtrl get accessCtrl => throw _privateConstructorUsedError;
  InstanceCtrl get device => throw _privateConstructorUsedError;
  InstanceCtrl get connMonitor => throw _privateConstructorUsedError;
  InstanceCtrl get firmware => throw _privateConstructorUsedError;
  InstanceCtrl get location => throw _privateConstructorUsedError;
  InstanceCtrl get connStatistics => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ObjectSpecCopyWith<ObjectSpec> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ObjectSpecCopyWith<$Res> {
  factory $ObjectSpecCopyWith(
          ObjectSpec value, $Res Function(ObjectSpec) then) =
      _$ObjectSpecCopyWithImpl<$Res>;
  $Res call(
      {InstanceCtrl lwm2mSecurity,
      InstanceCtrl lwm2mServer,
      InstanceCtrl accessCtrl,
      InstanceCtrl device,
      InstanceCtrl connMonitor,
      InstanceCtrl firmware,
      InstanceCtrl location,
      InstanceCtrl connStatistics});

  $InstanceCtrlCopyWith<$Res> get lwm2mSecurity;
  $InstanceCtrlCopyWith<$Res> get lwm2mServer;
  $InstanceCtrlCopyWith<$Res> get accessCtrl;
  $InstanceCtrlCopyWith<$Res> get device;
  $InstanceCtrlCopyWith<$Res> get connMonitor;
  $InstanceCtrlCopyWith<$Res> get firmware;
  $InstanceCtrlCopyWith<$Res> get location;
  $InstanceCtrlCopyWith<$Res> get connStatistics;
}

/// @nodoc
class _$ObjectSpecCopyWithImpl<$Res> implements $ObjectSpecCopyWith<$Res> {
  _$ObjectSpecCopyWithImpl(this._value, this._then);

  final ObjectSpec _value;
  // ignore: unused_field
  final $Res Function(ObjectSpec) _then;

  @override
  $Res call({
    Object? lwm2mSecurity = freezed,
    Object? lwm2mServer = freezed,
    Object? accessCtrl = freezed,
    Object? device = freezed,
    Object? connMonitor = freezed,
    Object? firmware = freezed,
    Object? location = freezed,
    Object? connStatistics = freezed,
  }) {
    return _then(_value.copyWith(
      lwm2mSecurity: lwm2mSecurity == freezed
          ? _value.lwm2mSecurity
          : lwm2mSecurity // ignore: cast_nullable_to_non_nullable
              as InstanceCtrl,
      lwm2mServer: lwm2mServer == freezed
          ? _value.lwm2mServer
          : lwm2mServer // ignore: cast_nullable_to_non_nullable
              as InstanceCtrl,
      accessCtrl: accessCtrl == freezed
          ? _value.accessCtrl
          : accessCtrl // ignore: cast_nullable_to_non_nullable
              as InstanceCtrl,
      device: device == freezed
          ? _value.device
          : device // ignore: cast_nullable_to_non_nullable
              as InstanceCtrl,
      connMonitor: connMonitor == freezed
          ? _value.connMonitor
          : connMonitor // ignore: cast_nullable_to_non_nullable
              as InstanceCtrl,
      firmware: firmware == freezed
          ? _value.firmware
          : firmware // ignore: cast_nullable_to_non_nullable
              as InstanceCtrl,
      location: location == freezed
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as InstanceCtrl,
      connStatistics: connStatistics == freezed
          ? _value.connStatistics
          : connStatistics // ignore: cast_nullable_to_non_nullable
              as InstanceCtrl,
    ));
  }

  @override
  $InstanceCtrlCopyWith<$Res> get lwm2mSecurity {
    return $InstanceCtrlCopyWith<$Res>(_value.lwm2mSecurity, (value) {
      return _then(_value.copyWith(lwm2mSecurity: value));
    });
  }

  @override
  $InstanceCtrlCopyWith<$Res> get lwm2mServer {
    return $InstanceCtrlCopyWith<$Res>(_value.lwm2mServer, (value) {
      return _then(_value.copyWith(lwm2mServer: value));
    });
  }

  @override
  $InstanceCtrlCopyWith<$Res> get accessCtrl {
    return $InstanceCtrlCopyWith<$Res>(_value.accessCtrl, (value) {
      return _then(_value.copyWith(accessCtrl: value));
    });
  }

  @override
  $InstanceCtrlCopyWith<$Res> get device {
    return $InstanceCtrlCopyWith<$Res>(_value.device, (value) {
      return _then(_value.copyWith(device: value));
    });
  }

  @override
  $InstanceCtrlCopyWith<$Res> get connMonitor {
    return $InstanceCtrlCopyWith<$Res>(_value.connMonitor, (value) {
      return _then(_value.copyWith(connMonitor: value));
    });
  }

  @override
  $InstanceCtrlCopyWith<$Res> get firmware {
    return $InstanceCtrlCopyWith<$Res>(_value.firmware, (value) {
      return _then(_value.copyWith(firmware: value));
    });
  }

  @override
  $InstanceCtrlCopyWith<$Res> get location {
    return $InstanceCtrlCopyWith<$Res>(_value.location, (value) {
      return _then(_value.copyWith(location: value));
    });
  }

  @override
  $InstanceCtrlCopyWith<$Res> get connStatistics {
    return $InstanceCtrlCopyWith<$Res>(_value.connStatistics, (value) {
      return _then(_value.copyWith(connStatistics: value));
    });
  }
}

/// @nodoc
abstract class _$ObjectSpecCopyWith<$Res> implements $ObjectSpecCopyWith<$Res> {
  factory _$ObjectSpecCopyWith(
          _ObjectSpec value, $Res Function(_ObjectSpec) then) =
      __$ObjectSpecCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceCtrl lwm2mSecurity,
      InstanceCtrl lwm2mServer,
      InstanceCtrl accessCtrl,
      InstanceCtrl device,
      InstanceCtrl connMonitor,
      InstanceCtrl firmware,
      InstanceCtrl location,
      InstanceCtrl connStatistics});

  @override
  $InstanceCtrlCopyWith<$Res> get lwm2mSecurity;
  @override
  $InstanceCtrlCopyWith<$Res> get lwm2mServer;
  @override
  $InstanceCtrlCopyWith<$Res> get accessCtrl;
  @override
  $InstanceCtrlCopyWith<$Res> get device;
  @override
  $InstanceCtrlCopyWith<$Res> get connMonitor;
  @override
  $InstanceCtrlCopyWith<$Res> get firmware;
  @override
  $InstanceCtrlCopyWith<$Res> get location;
  @override
  $InstanceCtrlCopyWith<$Res> get connStatistics;
}

/// @nodoc
class __$ObjectSpecCopyWithImpl<$Res> extends _$ObjectSpecCopyWithImpl<$Res>
    implements _$ObjectSpecCopyWith<$Res> {
  __$ObjectSpecCopyWithImpl(
      _ObjectSpec _value, $Res Function(_ObjectSpec) _then)
      : super(_value, (v) => _then(v as _ObjectSpec));

  @override
  _ObjectSpec get _value => super._value as _ObjectSpec;

  @override
  $Res call({
    Object? lwm2mSecurity = freezed,
    Object? lwm2mServer = freezed,
    Object? accessCtrl = freezed,
    Object? device = freezed,
    Object? connMonitor = freezed,
    Object? firmware = freezed,
    Object? location = freezed,
    Object? connStatistics = freezed,
  }) {
    return _then(_ObjectSpec(
      lwm2mSecurity: lwm2mSecurity == freezed
          ? _value.lwm2mSecurity
          : lwm2mSecurity // ignore: cast_nullable_to_non_nullable
              as InstanceCtrl,
      lwm2mServer: lwm2mServer == freezed
          ? _value.lwm2mServer
          : lwm2mServer // ignore: cast_nullable_to_non_nullable
              as InstanceCtrl,
      accessCtrl: accessCtrl == freezed
          ? _value.accessCtrl
          : accessCtrl // ignore: cast_nullable_to_non_nullable
              as InstanceCtrl,
      device: device == freezed
          ? _value.device
          : device // ignore: cast_nullable_to_non_nullable
              as InstanceCtrl,
      connMonitor: connMonitor == freezed
          ? _value.connMonitor
          : connMonitor // ignore: cast_nullable_to_non_nullable
              as InstanceCtrl,
      firmware: firmware == freezed
          ? _value.firmware
          : firmware // ignore: cast_nullable_to_non_nullable
              as InstanceCtrl,
      location: location == freezed
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as InstanceCtrl,
      connStatistics: connStatistics == freezed
          ? _value.connStatistics
          : connStatistics // ignore: cast_nullable_to_non_nullable
              as InstanceCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ObjectSpec implements _ObjectSpec {
  const _$_ObjectSpec(
      {required this.lwm2mSecurity,
      required this.lwm2mServer,
      required this.accessCtrl,
      required this.device,
      required this.connMonitor,
      required this.firmware,
      required this.location,
      required this.connStatistics});

  factory _$_ObjectSpec.fromJson(Map<String, dynamic> json) =>
      _$$_ObjectSpecFromJson(json);

  @override
  final InstanceCtrl lwm2mSecurity;
  @override
  final InstanceCtrl lwm2mServer;
  @override
  final InstanceCtrl accessCtrl;
  @override
  final InstanceCtrl device;
  @override
  final InstanceCtrl connMonitor;
  @override
  final InstanceCtrl firmware;
  @override
  final InstanceCtrl location;
  @override
  final InstanceCtrl connStatistics;

  @override
  String toString() {
    return 'ObjectSpec(lwm2mSecurity: $lwm2mSecurity, lwm2mServer: $lwm2mServer, accessCtrl: $accessCtrl, device: $device, connMonitor: $connMonitor, firmware: $firmware, location: $location, connStatistics: $connStatistics)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ObjectSpec &&
            (identical(other.lwm2mSecurity, lwm2mSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.lwm2mSecurity, lwm2mSecurity)) &&
            (identical(other.lwm2mServer, lwm2mServer) ||
                const DeepCollectionEquality()
                    .equals(other.lwm2mServer, lwm2mServer)) &&
            (identical(other.accessCtrl, accessCtrl) ||
                const DeepCollectionEquality()
                    .equals(other.accessCtrl, accessCtrl)) &&
            (identical(other.device, device) ||
                const DeepCollectionEquality().equals(other.device, device)) &&
            (identical(other.connMonitor, connMonitor) ||
                const DeepCollectionEquality()
                    .equals(other.connMonitor, connMonitor)) &&
            (identical(other.firmware, firmware) ||
                const DeepCollectionEquality()
                    .equals(other.firmware, firmware)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.connStatistics, connStatistics) ||
                const DeepCollectionEquality()
                    .equals(other.connStatistics, connStatistics)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(lwm2mSecurity) ^
      const DeepCollectionEquality().hash(lwm2mServer) ^
      const DeepCollectionEquality().hash(accessCtrl) ^
      const DeepCollectionEquality().hash(device) ^
      const DeepCollectionEquality().hash(connMonitor) ^
      const DeepCollectionEquality().hash(firmware) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(connStatistics);

  @JsonKey(ignore: true)
  @override
  _$ObjectSpecCopyWith<_ObjectSpec> get copyWith =>
      __$ObjectSpecCopyWithImpl<_ObjectSpec>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ObjectSpecToJson(this);
  }
}

abstract class _ObjectSpec implements ObjectSpec {
  const factory _ObjectSpec(
      {required InstanceCtrl lwm2mSecurity,
      required InstanceCtrl lwm2mServer,
      required InstanceCtrl accessCtrl,
      required InstanceCtrl device,
      required InstanceCtrl connMonitor,
      required InstanceCtrl firmware,
      required InstanceCtrl location,
      required InstanceCtrl connStatistics}) = _$_ObjectSpec;

  factory _ObjectSpec.fromJson(Map<String, dynamic> json) =
      _$_ObjectSpec.fromJson;

  @override
  InstanceCtrl get lwm2mSecurity => throw _privateConstructorUsedError;
  @override
  InstanceCtrl get lwm2mServer => throw _privateConstructorUsedError;
  @override
  InstanceCtrl get accessCtrl => throw _privateConstructorUsedError;
  @override
  InstanceCtrl get device => throw _privateConstructorUsedError;
  @override
  InstanceCtrl get connMonitor => throw _privateConstructorUsedError;
  @override
  InstanceCtrl get firmware => throw _privateConstructorUsedError;
  @override
  InstanceCtrl get location => throw _privateConstructorUsedError;
  @override
  InstanceCtrl get connStatistics => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$ObjectSpecCopyWith<_ObjectSpec> get copyWith =>
      throw _privateConstructorUsedError;
}

InstanceCtrl _$InstanceCtrlFromJson(Map<String, dynamic> json) {
  return _InstanceCtrl.fromJson(json);
}

/// @nodoc
class _$InstanceCtrlTearOff {
  const _$InstanceCtrlTearOff();

  _InstanceCtrl call({required bool multi, required bool mand}) {
    return _InstanceCtrl(
      multi: multi,
      mand: mand,
    );
  }

  InstanceCtrl fromJson(Map<String, Object> json) {
    return InstanceCtrl.fromJson(json);
  }
}

/// @nodoc
const $InstanceCtrl = _$InstanceCtrlTearOff();

/// @nodoc
mixin _$InstanceCtrl {
  bool get multi => throw _privateConstructorUsedError;
  bool get mand => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InstanceCtrlCopyWith<InstanceCtrl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InstanceCtrlCopyWith<$Res> {
  factory $InstanceCtrlCopyWith(
          InstanceCtrl value, $Res Function(InstanceCtrl) then) =
      _$InstanceCtrlCopyWithImpl<$Res>;
  $Res call({bool multi, bool mand});
}

/// @nodoc
class _$InstanceCtrlCopyWithImpl<$Res> implements $InstanceCtrlCopyWith<$Res> {
  _$InstanceCtrlCopyWithImpl(this._value, this._then);

  final InstanceCtrl _value;
  // ignore: unused_field
  final $Res Function(InstanceCtrl) _then;

  @override
  $Res call({
    Object? multi = freezed,
    Object? mand = freezed,
  }) {
    return _then(_value.copyWith(
      multi: multi == freezed
          ? _value.multi
          : multi // ignore: cast_nullable_to_non_nullable
              as bool,
      mand: mand == freezed
          ? _value.mand
          : mand // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class _$InstanceCtrlCopyWith<$Res>
    implements $InstanceCtrlCopyWith<$Res> {
  factory _$InstanceCtrlCopyWith(
          _InstanceCtrl value, $Res Function(_InstanceCtrl) then) =
      __$InstanceCtrlCopyWithImpl<$Res>;
  @override
  $Res call({bool multi, bool mand});
}

/// @nodoc
class __$InstanceCtrlCopyWithImpl<$Res> extends _$InstanceCtrlCopyWithImpl<$Res>
    implements _$InstanceCtrlCopyWith<$Res> {
  __$InstanceCtrlCopyWithImpl(
      _InstanceCtrl _value, $Res Function(_InstanceCtrl) _then)
      : super(_value, (v) => _then(v as _InstanceCtrl));

  @override
  _InstanceCtrl get _value => super._value as _InstanceCtrl;

  @override
  $Res call({
    Object? multi = freezed,
    Object? mand = freezed,
  }) {
    return _then(_InstanceCtrl(
      multi: multi == freezed
          ? _value.multi
          : multi // ignore: cast_nullable_to_non_nullable
              as bool,
      mand: mand == freezed
          ? _value.mand
          : mand // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_InstanceCtrl implements _InstanceCtrl {
  const _$_InstanceCtrl({required this.multi, required this.mand});

  factory _$_InstanceCtrl.fromJson(Map<String, dynamic> json) =>
      _$$_InstanceCtrlFromJson(json);

  @override
  final bool multi;
  @override
  final bool mand;

  @override
  String toString() {
    return 'InstanceCtrl(multi: $multi, mand: $mand)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _InstanceCtrl &&
            (identical(other.multi, multi) ||
                const DeepCollectionEquality().equals(other.multi, multi)) &&
            (identical(other.mand, mand) ||
                const DeepCollectionEquality().equals(other.mand, mand)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(multi) ^
      const DeepCollectionEquality().hash(mand);

  @JsonKey(ignore: true)
  @override
  _$InstanceCtrlCopyWith<_InstanceCtrl> get copyWith =>
      __$InstanceCtrlCopyWithImpl<_InstanceCtrl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_InstanceCtrlToJson(this);
  }
}

abstract class _InstanceCtrl implements InstanceCtrl {
  const factory _InstanceCtrl({required bool multi, required bool mand}) =
      _$_InstanceCtrl;

  factory _InstanceCtrl.fromJson(Map<String, dynamic> json) =
      _$_InstanceCtrl.fromJson;

  @override
  bool get multi => throw _privateConstructorUsedError;
  @override
  bool get mand => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$InstanceCtrlCopyWith<_InstanceCtrl> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificResrcChar _$SpecificResrcCharFromJson(Map<String, dynamic> json) {
  return _SpecificResrcChar.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharTearOff {
  const _$SpecificResrcCharTearOff();

  _SpecificResrcChar call(
      {required SpecificResrcCharLwm2mSecurity lwm2mSecurity,
      required SpecificResrcCharLwm2mServer lwm2mServer,
      required SpecificResrcCharAccessCtrl accessCtrl,
      required Map<String, InstanceAndOpsCtrl> device,
      required Map<String, InstanceAndOpsCtrl> connMonitor,
      required SpecificResrcCharFirmware firmware,
      required SpecificResrcCharLocation location,
      required SpecificResrcCharConnStatistics connStatistics,
      required SpecificResrcCharDIn dIn,
      required SpecificResrcCharDOut dOut,
      required SpecificResrcCharAIn aIn,
      required SpecificResrcCharAOut aOut,
      required SpecificResrcCharGeneric generic,
      required SpecificResrcCharGeneric illuminance,
      required SpecificResrcCharPresence presence,
      required SpecificResrcCharGeneric temperature,
      required SpecificResrcCharGeneric humidity,
      required Map<String, InstanceAndOpsCtrl> pwrMea,
      required SpecificResrcCharActuation actuation,
      required SpecificResrcCharSetPoint setPoint,
      required SpecificResrcCharLoadCtrl loadCtrl,
      required SpecificResrcCharLightCtrl lightCtrl,
      required SpecificResrcCharPwrCtrl pwrCtrl,
      required SpecificResrcCharAccelerometer accelerometer,
      required SpecificResrcCharMagnetometer magnetometer,
      required SpecificResrcCharGeneric barometer,
      required SpecificResrcCharGeneric voltage,
      required SpecificResrcCharGeneric current,
      required SpecificResrcCharGeneric frequency,
      required SpecificResrcCharGeneric depth,
      required SpecificResrcCharGeneric percentage,
      required SpecificResrcCharGeneric altitude,
      required SpecificResrcCharGeneric load,
      required SpecificResrcCharGeneric pressure,
      required SpecificResrcCharGeneric loudness,
      required SpecificResrcCharGeneric concentration,
      required SpecificResrcCharGeneric acidity,
      required SpecificResrcCharGeneric conductivity,
      required SpecificResrcCharGeneric power,
      required SpecificResrcCharGeneric powerFactor,
      required SpecificResrcCharGeneric distance,
      required SpecificResrcCharEnergy energy,
      required SpecificResrcCharDirection direction,
      required SpecificResrcCharTime time,
      required Map<String, InstanceAndOpsCtrl> gyrometer,
      required SpecificResrcCharColour colour,
      required SpecificResrcCharGpsLocation gpsLocation,
      required SpecificResrcCharPositioner positioner,
      required SpecificResrcCharBuzzer buzzer,
      required SpecificResrcCharAudioClip audioClip,
      required Map<String, InstanceAndOpsCtrl> timer,
      required Map<String, InstanceAndOpsCtrl> addressableTextDisplay,
      required SpecificResrcCharOnOffSwitch onOffSwitch,
      required SpecificResrcCharLevelControl levelControl,
      required SpecificResrcCharUpDownControl upDownControl,
      required SpecificResrcCharMultipleAxisJoystick multipleAxisJoystick,
      required SpecificResrcCharGeneric rate,
      required SpecificResrcCharPushButton pushButton,
      required SpecificResrcCharMultistateSelector multistateSelector}) {
    return _SpecificResrcChar(
      lwm2mSecurity: lwm2mSecurity,
      lwm2mServer: lwm2mServer,
      accessCtrl: accessCtrl,
      device: device,
      connMonitor: connMonitor,
      firmware: firmware,
      location: location,
      connStatistics: connStatistics,
      dIn: dIn,
      dOut: dOut,
      aIn: aIn,
      aOut: aOut,
      generic: generic,
      illuminance: illuminance,
      presence: presence,
      temperature: temperature,
      humidity: humidity,
      pwrMea: pwrMea,
      actuation: actuation,
      setPoint: setPoint,
      loadCtrl: loadCtrl,
      lightCtrl: lightCtrl,
      pwrCtrl: pwrCtrl,
      accelerometer: accelerometer,
      magnetometer: magnetometer,
      barometer: barometer,
      voltage: voltage,
      current: current,
      frequency: frequency,
      depth: depth,
      percentage: percentage,
      altitude: altitude,
      load: load,
      pressure: pressure,
      loudness: loudness,
      concentration: concentration,
      acidity: acidity,
      conductivity: conductivity,
      power: power,
      powerFactor: powerFactor,
      distance: distance,
      energy: energy,
      direction: direction,
      time: time,
      gyrometer: gyrometer,
      colour: colour,
      gpsLocation: gpsLocation,
      positioner: positioner,
      buzzer: buzzer,
      audioClip: audioClip,
      timer: timer,
      addressableTextDisplay: addressableTextDisplay,
      onOffSwitch: onOffSwitch,
      levelControl: levelControl,
      upDownControl: upDownControl,
      multipleAxisJoystick: multipleAxisJoystick,
      rate: rate,
      pushButton: pushButton,
      multistateSelector: multistateSelector,
    );
  }

  SpecificResrcChar fromJson(Map<String, Object> json) {
    return SpecificResrcChar.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcChar = _$SpecificResrcCharTearOff();

/// @nodoc
mixin _$SpecificResrcChar {
  SpecificResrcCharLwm2mSecurity get lwm2mSecurity =>
      throw _privateConstructorUsedError;
  SpecificResrcCharLwm2mServer get lwm2mServer =>
      throw _privateConstructorUsedError;
  SpecificResrcCharAccessCtrl get accessCtrl =>
      throw _privateConstructorUsedError;
  Map<String, InstanceAndOpsCtrl> get device =>
      throw _privateConstructorUsedError; //TODO
  Map<String, InstanceAndOpsCtrl> get connMonitor =>
      throw _privateConstructorUsedError; //TODO
  SpecificResrcCharFirmware get firmware => throw _privateConstructorUsedError;
  SpecificResrcCharLocation get location => throw _privateConstructorUsedError;
  SpecificResrcCharConnStatistics get connStatistics =>
      throw _privateConstructorUsedError;
  SpecificResrcCharDIn get dIn => throw _privateConstructorUsedError;
  SpecificResrcCharDOut get dOut => throw _privateConstructorUsedError;
  SpecificResrcCharAIn get aIn => throw _privateConstructorUsedError;
  SpecificResrcCharAOut get aOut => throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get generic => throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get illuminance =>
      throw _privateConstructorUsedError;
  SpecificResrcCharPresence get presence => throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get temperature =>
      throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get humidity => throw _privateConstructorUsedError;
  Map<String, InstanceAndOpsCtrl> get pwrMea =>
      throw _privateConstructorUsedError; //TODO
  SpecificResrcCharActuation get actuation =>
      throw _privateConstructorUsedError;
  SpecificResrcCharSetPoint get setPoint => throw _privateConstructorUsedError;
  SpecificResrcCharLoadCtrl get loadCtrl => throw _privateConstructorUsedError;
  SpecificResrcCharLightCtrl get lightCtrl =>
      throw _privateConstructorUsedError;
  SpecificResrcCharPwrCtrl get pwrCtrl => throw _privateConstructorUsedError;
  SpecificResrcCharAccelerometer get accelerometer =>
      throw _privateConstructorUsedError;
  SpecificResrcCharMagnetometer get magnetometer =>
      throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get barometer => throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get voltage => throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get current => throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get frequency => throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get depth => throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get percentage => throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get altitude => throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get load => throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get pressure => throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get loudness => throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get concentration =>
      throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get acidity => throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get conductivity =>
      throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get power => throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get powerFactor =>
      throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get distance => throw _privateConstructorUsedError;
  SpecificResrcCharEnergy get energy => throw _privateConstructorUsedError;
  SpecificResrcCharDirection get direction =>
      throw _privateConstructorUsedError;
  SpecificResrcCharTime get time => throw _privateConstructorUsedError;
  Map<String, InstanceAndOpsCtrl> get gyrometer =>
      throw _privateConstructorUsedError; //TODO
  SpecificResrcCharColour get colour => throw _privateConstructorUsedError;
  SpecificResrcCharGpsLocation get gpsLocation =>
      throw _privateConstructorUsedError;
  SpecificResrcCharPositioner get positioner =>
      throw _privateConstructorUsedError;
  SpecificResrcCharBuzzer get buzzer => throw _privateConstructorUsedError;
  SpecificResrcCharAudioClip get audioClip =>
      throw _privateConstructorUsedError;
  Map<String, InstanceAndOpsCtrl> get timer =>
      throw _privateConstructorUsedError; //TODO
  Map<String, InstanceAndOpsCtrl> get addressableTextDisplay =>
      throw _privateConstructorUsedError; //TODO
  SpecificResrcCharOnOffSwitch get onOffSwitch =>
      throw _privateConstructorUsedError;
  SpecificResrcCharLevelControl get levelControl =>
      throw _privateConstructorUsedError;
  SpecificResrcCharUpDownControl get upDownControl =>
      throw _privateConstructorUsedError;
  SpecificResrcCharMultipleAxisJoystick get multipleAxisJoystick =>
      throw _privateConstructorUsedError;
  SpecificResrcCharGeneric get rate => throw _privateConstructorUsedError;
  SpecificResrcCharPushButton get pushButton =>
      throw _privateConstructorUsedError;
  SpecificResrcCharMultistateSelector get multistateSelector =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharCopyWith<SpecificResrcChar> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharCopyWith<$Res> {
  factory $SpecificResrcCharCopyWith(
          SpecificResrcChar value, $Res Function(SpecificResrcChar) then) =
      _$SpecificResrcCharCopyWithImpl<$Res>;
  $Res call(
      {SpecificResrcCharLwm2mSecurity lwm2mSecurity,
      SpecificResrcCharLwm2mServer lwm2mServer,
      SpecificResrcCharAccessCtrl accessCtrl,
      Map<String, InstanceAndOpsCtrl> device,
      Map<String, InstanceAndOpsCtrl> connMonitor,
      SpecificResrcCharFirmware firmware,
      SpecificResrcCharLocation location,
      SpecificResrcCharConnStatistics connStatistics,
      SpecificResrcCharDIn dIn,
      SpecificResrcCharDOut dOut,
      SpecificResrcCharAIn aIn,
      SpecificResrcCharAOut aOut,
      SpecificResrcCharGeneric generic,
      SpecificResrcCharGeneric illuminance,
      SpecificResrcCharPresence presence,
      SpecificResrcCharGeneric temperature,
      SpecificResrcCharGeneric humidity,
      Map<String, InstanceAndOpsCtrl> pwrMea,
      SpecificResrcCharActuation actuation,
      SpecificResrcCharSetPoint setPoint,
      SpecificResrcCharLoadCtrl loadCtrl,
      SpecificResrcCharLightCtrl lightCtrl,
      SpecificResrcCharPwrCtrl pwrCtrl,
      SpecificResrcCharAccelerometer accelerometer,
      SpecificResrcCharMagnetometer magnetometer,
      SpecificResrcCharGeneric barometer,
      SpecificResrcCharGeneric voltage,
      SpecificResrcCharGeneric current,
      SpecificResrcCharGeneric frequency,
      SpecificResrcCharGeneric depth,
      SpecificResrcCharGeneric percentage,
      SpecificResrcCharGeneric altitude,
      SpecificResrcCharGeneric load,
      SpecificResrcCharGeneric pressure,
      SpecificResrcCharGeneric loudness,
      SpecificResrcCharGeneric concentration,
      SpecificResrcCharGeneric acidity,
      SpecificResrcCharGeneric conductivity,
      SpecificResrcCharGeneric power,
      SpecificResrcCharGeneric powerFactor,
      SpecificResrcCharGeneric distance,
      SpecificResrcCharEnergy energy,
      SpecificResrcCharDirection direction,
      SpecificResrcCharTime time,
      Map<String, InstanceAndOpsCtrl> gyrometer,
      SpecificResrcCharColour colour,
      SpecificResrcCharGpsLocation gpsLocation,
      SpecificResrcCharPositioner positioner,
      SpecificResrcCharBuzzer buzzer,
      SpecificResrcCharAudioClip audioClip,
      Map<String, InstanceAndOpsCtrl> timer,
      Map<String, InstanceAndOpsCtrl> addressableTextDisplay,
      SpecificResrcCharOnOffSwitch onOffSwitch,
      SpecificResrcCharLevelControl levelControl,
      SpecificResrcCharUpDownControl upDownControl,
      SpecificResrcCharMultipleAxisJoystick multipleAxisJoystick,
      SpecificResrcCharGeneric rate,
      SpecificResrcCharPushButton pushButton,
      SpecificResrcCharMultistateSelector multistateSelector});

  $SpecificResrcCharLwm2mSecurityCopyWith<$Res> get lwm2mSecurity;
  $SpecificResrcCharLwm2mServerCopyWith<$Res> get lwm2mServer;
  $SpecificResrcCharAccessCtrlCopyWith<$Res> get accessCtrl;
  $SpecificResrcCharFirmwareCopyWith<$Res> get firmware;
  $SpecificResrcCharLocationCopyWith<$Res> get location;
  $SpecificResrcCharConnStatisticsCopyWith<$Res> get connStatistics;
  $SpecificResrcCharDInCopyWith<$Res> get dIn;
  $SpecificResrcCharDOutCopyWith<$Res> get dOut;
  $SpecificResrcCharAInCopyWith<$Res> get aIn;
  $SpecificResrcCharAOutCopyWith<$Res> get aOut;
  $SpecificResrcCharGenericCopyWith<$Res> get generic;
  $SpecificResrcCharGenericCopyWith<$Res> get illuminance;
  $SpecificResrcCharPresenceCopyWith<$Res> get presence;
  $SpecificResrcCharGenericCopyWith<$Res> get temperature;
  $SpecificResrcCharGenericCopyWith<$Res> get humidity;
  $SpecificResrcCharActuationCopyWith<$Res> get actuation;
  $SpecificResrcCharSetPointCopyWith<$Res> get setPoint;
  $SpecificResrcCharLoadCtrlCopyWith<$Res> get loadCtrl;
  $SpecificResrcCharLightCtrlCopyWith<$Res> get lightCtrl;
  $SpecificResrcCharPwrCtrlCopyWith<$Res> get pwrCtrl;
  $SpecificResrcCharAccelerometerCopyWith<$Res> get accelerometer;
  $SpecificResrcCharMagnetometerCopyWith<$Res> get magnetometer;
  $SpecificResrcCharGenericCopyWith<$Res> get barometer;
  $SpecificResrcCharGenericCopyWith<$Res> get voltage;
  $SpecificResrcCharGenericCopyWith<$Res> get current;
  $SpecificResrcCharGenericCopyWith<$Res> get frequency;
  $SpecificResrcCharGenericCopyWith<$Res> get depth;
  $SpecificResrcCharGenericCopyWith<$Res> get percentage;
  $SpecificResrcCharGenericCopyWith<$Res> get altitude;
  $SpecificResrcCharGenericCopyWith<$Res> get load;
  $SpecificResrcCharGenericCopyWith<$Res> get pressure;
  $SpecificResrcCharGenericCopyWith<$Res> get loudness;
  $SpecificResrcCharGenericCopyWith<$Res> get concentration;
  $SpecificResrcCharGenericCopyWith<$Res> get acidity;
  $SpecificResrcCharGenericCopyWith<$Res> get conductivity;
  $SpecificResrcCharGenericCopyWith<$Res> get power;
  $SpecificResrcCharGenericCopyWith<$Res> get powerFactor;
  $SpecificResrcCharGenericCopyWith<$Res> get distance;
  $SpecificResrcCharEnergyCopyWith<$Res> get energy;
  $SpecificResrcCharDirectionCopyWith<$Res> get direction;
  $SpecificResrcCharTimeCopyWith<$Res> get time;
  $SpecificResrcCharColourCopyWith<$Res> get colour;
  $SpecificResrcCharGpsLocationCopyWith<$Res> get gpsLocation;
  $SpecificResrcCharPositionerCopyWith<$Res> get positioner;
  $SpecificResrcCharBuzzerCopyWith<$Res> get buzzer;
  $SpecificResrcCharAudioClipCopyWith<$Res> get audioClip;
  $SpecificResrcCharOnOffSwitchCopyWith<$Res> get onOffSwitch;
  $SpecificResrcCharLevelControlCopyWith<$Res> get levelControl;
  $SpecificResrcCharUpDownControlCopyWith<$Res> get upDownControl;
  $SpecificResrcCharMultipleAxisJoystickCopyWith<$Res> get multipleAxisJoystick;
  $SpecificResrcCharGenericCopyWith<$Res> get rate;
  $SpecificResrcCharPushButtonCopyWith<$Res> get pushButton;
  $SpecificResrcCharMultistateSelectorCopyWith<$Res> get multistateSelector;
}

/// @nodoc
class _$SpecificResrcCharCopyWithImpl<$Res>
    implements $SpecificResrcCharCopyWith<$Res> {
  _$SpecificResrcCharCopyWithImpl(this._value, this._then);

  final SpecificResrcChar _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcChar) _then;

  @override
  $Res call({
    Object? lwm2mSecurity = freezed,
    Object? lwm2mServer = freezed,
    Object? accessCtrl = freezed,
    Object? device = freezed,
    Object? connMonitor = freezed,
    Object? firmware = freezed,
    Object? location = freezed,
    Object? connStatistics = freezed,
    Object? dIn = freezed,
    Object? dOut = freezed,
    Object? aIn = freezed,
    Object? aOut = freezed,
    Object? generic = freezed,
    Object? illuminance = freezed,
    Object? presence = freezed,
    Object? temperature = freezed,
    Object? humidity = freezed,
    Object? pwrMea = freezed,
    Object? actuation = freezed,
    Object? setPoint = freezed,
    Object? loadCtrl = freezed,
    Object? lightCtrl = freezed,
    Object? pwrCtrl = freezed,
    Object? accelerometer = freezed,
    Object? magnetometer = freezed,
    Object? barometer = freezed,
    Object? voltage = freezed,
    Object? current = freezed,
    Object? frequency = freezed,
    Object? depth = freezed,
    Object? percentage = freezed,
    Object? altitude = freezed,
    Object? load = freezed,
    Object? pressure = freezed,
    Object? loudness = freezed,
    Object? concentration = freezed,
    Object? acidity = freezed,
    Object? conductivity = freezed,
    Object? power = freezed,
    Object? powerFactor = freezed,
    Object? distance = freezed,
    Object? energy = freezed,
    Object? direction = freezed,
    Object? time = freezed,
    Object? gyrometer = freezed,
    Object? colour = freezed,
    Object? gpsLocation = freezed,
    Object? positioner = freezed,
    Object? buzzer = freezed,
    Object? audioClip = freezed,
    Object? timer = freezed,
    Object? addressableTextDisplay = freezed,
    Object? onOffSwitch = freezed,
    Object? levelControl = freezed,
    Object? upDownControl = freezed,
    Object? multipleAxisJoystick = freezed,
    Object? rate = freezed,
    Object? pushButton = freezed,
    Object? multistateSelector = freezed,
  }) {
    return _then(_value.copyWith(
      lwm2mSecurity: lwm2mSecurity == freezed
          ? _value.lwm2mSecurity
          : lwm2mSecurity // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharLwm2mSecurity,
      lwm2mServer: lwm2mServer == freezed
          ? _value.lwm2mServer
          : lwm2mServer // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharLwm2mServer,
      accessCtrl: accessCtrl == freezed
          ? _value.accessCtrl
          : accessCtrl // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharAccessCtrl,
      device: device == freezed
          ? _value.device
          : device // ignore: cast_nullable_to_non_nullable
              as Map<String, InstanceAndOpsCtrl>,
      connMonitor: connMonitor == freezed
          ? _value.connMonitor
          : connMonitor // ignore: cast_nullable_to_non_nullable
              as Map<String, InstanceAndOpsCtrl>,
      firmware: firmware == freezed
          ? _value.firmware
          : firmware // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharFirmware,
      location: location == freezed
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharLocation,
      connStatistics: connStatistics == freezed
          ? _value.connStatistics
          : connStatistics // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharConnStatistics,
      dIn: dIn == freezed
          ? _value.dIn
          : dIn // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharDIn,
      dOut: dOut == freezed
          ? _value.dOut
          : dOut // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharDOut,
      aIn: aIn == freezed
          ? _value.aIn
          : aIn // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharAIn,
      aOut: aOut == freezed
          ? _value.aOut
          : aOut // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharAOut,
      generic: generic == freezed
          ? _value.generic
          : generic // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      illuminance: illuminance == freezed
          ? _value.illuminance
          : illuminance // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      presence: presence == freezed
          ? _value.presence
          : presence // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharPresence,
      temperature: temperature == freezed
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      humidity: humidity == freezed
          ? _value.humidity
          : humidity // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      pwrMea: pwrMea == freezed
          ? _value.pwrMea
          : pwrMea // ignore: cast_nullable_to_non_nullable
              as Map<String, InstanceAndOpsCtrl>,
      actuation: actuation == freezed
          ? _value.actuation
          : actuation // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharActuation,
      setPoint: setPoint == freezed
          ? _value.setPoint
          : setPoint // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharSetPoint,
      loadCtrl: loadCtrl == freezed
          ? _value.loadCtrl
          : loadCtrl // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharLoadCtrl,
      lightCtrl: lightCtrl == freezed
          ? _value.lightCtrl
          : lightCtrl // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharLightCtrl,
      pwrCtrl: pwrCtrl == freezed
          ? _value.pwrCtrl
          : pwrCtrl // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharPwrCtrl,
      accelerometer: accelerometer == freezed
          ? _value.accelerometer
          : accelerometer // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharAccelerometer,
      magnetometer: magnetometer == freezed
          ? _value.magnetometer
          : magnetometer // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharMagnetometer,
      barometer: barometer == freezed
          ? _value.barometer
          : barometer // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      voltage: voltage == freezed
          ? _value.voltage
          : voltage // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      current: current == freezed
          ? _value.current
          : current // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      frequency: frequency == freezed
          ? _value.frequency
          : frequency // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      depth: depth == freezed
          ? _value.depth
          : depth // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      percentage: percentage == freezed
          ? _value.percentage
          : percentage // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      altitude: altitude == freezed
          ? _value.altitude
          : altitude // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      load: load == freezed
          ? _value.load
          : load // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      pressure: pressure == freezed
          ? _value.pressure
          : pressure // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      loudness: loudness == freezed
          ? _value.loudness
          : loudness // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      concentration: concentration == freezed
          ? _value.concentration
          : concentration // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      acidity: acidity == freezed
          ? _value.acidity
          : acidity // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      conductivity: conductivity == freezed
          ? _value.conductivity
          : conductivity // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      power: power == freezed
          ? _value.power
          : power // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      powerFactor: powerFactor == freezed
          ? _value.powerFactor
          : powerFactor // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      distance: distance == freezed
          ? _value.distance
          : distance // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      energy: energy == freezed
          ? _value.energy
          : energy // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharEnergy,
      direction: direction == freezed
          ? _value.direction
          : direction // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharDirection,
      time: time == freezed
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharTime,
      gyrometer: gyrometer == freezed
          ? _value.gyrometer
          : gyrometer // ignore: cast_nullable_to_non_nullable
              as Map<String, InstanceAndOpsCtrl>,
      colour: colour == freezed
          ? _value.colour
          : colour // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharColour,
      gpsLocation: gpsLocation == freezed
          ? _value.gpsLocation
          : gpsLocation // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGpsLocation,
      positioner: positioner == freezed
          ? _value.positioner
          : positioner // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharPositioner,
      buzzer: buzzer == freezed
          ? _value.buzzer
          : buzzer // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharBuzzer,
      audioClip: audioClip == freezed
          ? _value.audioClip
          : audioClip // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharAudioClip,
      timer: timer == freezed
          ? _value.timer
          : timer // ignore: cast_nullable_to_non_nullable
              as Map<String, InstanceAndOpsCtrl>,
      addressableTextDisplay: addressableTextDisplay == freezed
          ? _value.addressableTextDisplay
          : addressableTextDisplay // ignore: cast_nullable_to_non_nullable
              as Map<String, InstanceAndOpsCtrl>,
      onOffSwitch: onOffSwitch == freezed
          ? _value.onOffSwitch
          : onOffSwitch // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharOnOffSwitch,
      levelControl: levelControl == freezed
          ? _value.levelControl
          : levelControl // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharLevelControl,
      upDownControl: upDownControl == freezed
          ? _value.upDownControl
          : upDownControl // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharUpDownControl,
      multipleAxisJoystick: multipleAxisJoystick == freezed
          ? _value.multipleAxisJoystick
          : multipleAxisJoystick // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharMultipleAxisJoystick,
      rate: rate == freezed
          ? _value.rate
          : rate // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      pushButton: pushButton == freezed
          ? _value.pushButton
          : pushButton // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharPushButton,
      multistateSelector: multistateSelector == freezed
          ? _value.multistateSelector
          : multistateSelector // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharMultistateSelector,
    ));
  }

  @override
  $SpecificResrcCharLwm2mSecurityCopyWith<$Res> get lwm2mSecurity {
    return $SpecificResrcCharLwm2mSecurityCopyWith<$Res>(_value.lwm2mSecurity,
        (value) {
      return _then(_value.copyWith(lwm2mSecurity: value));
    });
  }

  @override
  $SpecificResrcCharLwm2mServerCopyWith<$Res> get lwm2mServer {
    return $SpecificResrcCharLwm2mServerCopyWith<$Res>(_value.lwm2mServer,
        (value) {
      return _then(_value.copyWith(lwm2mServer: value));
    });
  }

  @override
  $SpecificResrcCharAccessCtrlCopyWith<$Res> get accessCtrl {
    return $SpecificResrcCharAccessCtrlCopyWith<$Res>(_value.accessCtrl,
        (value) {
      return _then(_value.copyWith(accessCtrl: value));
    });
  }

  @override
  $SpecificResrcCharFirmwareCopyWith<$Res> get firmware {
    return $SpecificResrcCharFirmwareCopyWith<$Res>(_value.firmware, (value) {
      return _then(_value.copyWith(firmware: value));
    });
  }

  @override
  $SpecificResrcCharLocationCopyWith<$Res> get location {
    return $SpecificResrcCharLocationCopyWith<$Res>(_value.location, (value) {
      return _then(_value.copyWith(location: value));
    });
  }

  @override
  $SpecificResrcCharConnStatisticsCopyWith<$Res> get connStatistics {
    return $SpecificResrcCharConnStatisticsCopyWith<$Res>(_value.connStatistics,
        (value) {
      return _then(_value.copyWith(connStatistics: value));
    });
  }

  @override
  $SpecificResrcCharDInCopyWith<$Res> get dIn {
    return $SpecificResrcCharDInCopyWith<$Res>(_value.dIn, (value) {
      return _then(_value.copyWith(dIn: value));
    });
  }

  @override
  $SpecificResrcCharDOutCopyWith<$Res> get dOut {
    return $SpecificResrcCharDOutCopyWith<$Res>(_value.dOut, (value) {
      return _then(_value.copyWith(dOut: value));
    });
  }

  @override
  $SpecificResrcCharAInCopyWith<$Res> get aIn {
    return $SpecificResrcCharAInCopyWith<$Res>(_value.aIn, (value) {
      return _then(_value.copyWith(aIn: value));
    });
  }

  @override
  $SpecificResrcCharAOutCopyWith<$Res> get aOut {
    return $SpecificResrcCharAOutCopyWith<$Res>(_value.aOut, (value) {
      return _then(_value.copyWith(aOut: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get generic {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.generic, (value) {
      return _then(_value.copyWith(generic: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get illuminance {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.illuminance, (value) {
      return _then(_value.copyWith(illuminance: value));
    });
  }

  @override
  $SpecificResrcCharPresenceCopyWith<$Res> get presence {
    return $SpecificResrcCharPresenceCopyWith<$Res>(_value.presence, (value) {
      return _then(_value.copyWith(presence: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get temperature {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.temperature, (value) {
      return _then(_value.copyWith(temperature: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get humidity {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.humidity, (value) {
      return _then(_value.copyWith(humidity: value));
    });
  }

  @override
  $SpecificResrcCharActuationCopyWith<$Res> get actuation {
    return $SpecificResrcCharActuationCopyWith<$Res>(_value.actuation, (value) {
      return _then(_value.copyWith(actuation: value));
    });
  }

  @override
  $SpecificResrcCharSetPointCopyWith<$Res> get setPoint {
    return $SpecificResrcCharSetPointCopyWith<$Res>(_value.setPoint, (value) {
      return _then(_value.copyWith(setPoint: value));
    });
  }

  @override
  $SpecificResrcCharLoadCtrlCopyWith<$Res> get loadCtrl {
    return $SpecificResrcCharLoadCtrlCopyWith<$Res>(_value.loadCtrl, (value) {
      return _then(_value.copyWith(loadCtrl: value));
    });
  }

  @override
  $SpecificResrcCharLightCtrlCopyWith<$Res> get lightCtrl {
    return $SpecificResrcCharLightCtrlCopyWith<$Res>(_value.lightCtrl, (value) {
      return _then(_value.copyWith(lightCtrl: value));
    });
  }

  @override
  $SpecificResrcCharPwrCtrlCopyWith<$Res> get pwrCtrl {
    return $SpecificResrcCharPwrCtrlCopyWith<$Res>(_value.pwrCtrl, (value) {
      return _then(_value.copyWith(pwrCtrl: value));
    });
  }

  @override
  $SpecificResrcCharAccelerometerCopyWith<$Res> get accelerometer {
    return $SpecificResrcCharAccelerometerCopyWith<$Res>(_value.accelerometer,
        (value) {
      return _then(_value.copyWith(accelerometer: value));
    });
  }

  @override
  $SpecificResrcCharMagnetometerCopyWith<$Res> get magnetometer {
    return $SpecificResrcCharMagnetometerCopyWith<$Res>(_value.magnetometer,
        (value) {
      return _then(_value.copyWith(magnetometer: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get barometer {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.barometer, (value) {
      return _then(_value.copyWith(barometer: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get voltage {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.voltage, (value) {
      return _then(_value.copyWith(voltage: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get current {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.current, (value) {
      return _then(_value.copyWith(current: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get frequency {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.frequency, (value) {
      return _then(_value.copyWith(frequency: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get depth {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.depth, (value) {
      return _then(_value.copyWith(depth: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get percentage {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.percentage, (value) {
      return _then(_value.copyWith(percentage: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get altitude {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.altitude, (value) {
      return _then(_value.copyWith(altitude: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get load {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.load, (value) {
      return _then(_value.copyWith(load: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get pressure {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.pressure, (value) {
      return _then(_value.copyWith(pressure: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get loudness {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.loudness, (value) {
      return _then(_value.copyWith(loudness: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get concentration {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.concentration,
        (value) {
      return _then(_value.copyWith(concentration: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get acidity {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.acidity, (value) {
      return _then(_value.copyWith(acidity: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get conductivity {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.conductivity,
        (value) {
      return _then(_value.copyWith(conductivity: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get power {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.power, (value) {
      return _then(_value.copyWith(power: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get powerFactor {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.powerFactor, (value) {
      return _then(_value.copyWith(powerFactor: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get distance {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.distance, (value) {
      return _then(_value.copyWith(distance: value));
    });
  }

  @override
  $SpecificResrcCharEnergyCopyWith<$Res> get energy {
    return $SpecificResrcCharEnergyCopyWith<$Res>(_value.energy, (value) {
      return _then(_value.copyWith(energy: value));
    });
  }

  @override
  $SpecificResrcCharDirectionCopyWith<$Res> get direction {
    return $SpecificResrcCharDirectionCopyWith<$Res>(_value.direction, (value) {
      return _then(_value.copyWith(direction: value));
    });
  }

  @override
  $SpecificResrcCharTimeCopyWith<$Res> get time {
    return $SpecificResrcCharTimeCopyWith<$Res>(_value.time, (value) {
      return _then(_value.copyWith(time: value));
    });
  }

  @override
  $SpecificResrcCharColourCopyWith<$Res> get colour {
    return $SpecificResrcCharColourCopyWith<$Res>(_value.colour, (value) {
      return _then(_value.copyWith(colour: value));
    });
  }

  @override
  $SpecificResrcCharGpsLocationCopyWith<$Res> get gpsLocation {
    return $SpecificResrcCharGpsLocationCopyWith<$Res>(_value.gpsLocation,
        (value) {
      return _then(_value.copyWith(gpsLocation: value));
    });
  }

  @override
  $SpecificResrcCharPositionerCopyWith<$Res> get positioner {
    return $SpecificResrcCharPositionerCopyWith<$Res>(_value.positioner,
        (value) {
      return _then(_value.copyWith(positioner: value));
    });
  }

  @override
  $SpecificResrcCharBuzzerCopyWith<$Res> get buzzer {
    return $SpecificResrcCharBuzzerCopyWith<$Res>(_value.buzzer, (value) {
      return _then(_value.copyWith(buzzer: value));
    });
  }

  @override
  $SpecificResrcCharAudioClipCopyWith<$Res> get audioClip {
    return $SpecificResrcCharAudioClipCopyWith<$Res>(_value.audioClip, (value) {
      return _then(_value.copyWith(audioClip: value));
    });
  }

  @override
  $SpecificResrcCharOnOffSwitchCopyWith<$Res> get onOffSwitch {
    return $SpecificResrcCharOnOffSwitchCopyWith<$Res>(_value.onOffSwitch,
        (value) {
      return _then(_value.copyWith(onOffSwitch: value));
    });
  }

  @override
  $SpecificResrcCharLevelControlCopyWith<$Res> get levelControl {
    return $SpecificResrcCharLevelControlCopyWith<$Res>(_value.levelControl,
        (value) {
      return _then(_value.copyWith(levelControl: value));
    });
  }

  @override
  $SpecificResrcCharUpDownControlCopyWith<$Res> get upDownControl {
    return $SpecificResrcCharUpDownControlCopyWith<$Res>(_value.upDownControl,
        (value) {
      return _then(_value.copyWith(upDownControl: value));
    });
  }

  @override
  $SpecificResrcCharMultipleAxisJoystickCopyWith<$Res>
      get multipleAxisJoystick {
    return $SpecificResrcCharMultipleAxisJoystickCopyWith<$Res>(
        _value.multipleAxisJoystick, (value) {
      return _then(_value.copyWith(multipleAxisJoystick: value));
    });
  }

  @override
  $SpecificResrcCharGenericCopyWith<$Res> get rate {
    return $SpecificResrcCharGenericCopyWith<$Res>(_value.rate, (value) {
      return _then(_value.copyWith(rate: value));
    });
  }

  @override
  $SpecificResrcCharPushButtonCopyWith<$Res> get pushButton {
    return $SpecificResrcCharPushButtonCopyWith<$Res>(_value.pushButton,
        (value) {
      return _then(_value.copyWith(pushButton: value));
    });
  }

  @override
  $SpecificResrcCharMultistateSelectorCopyWith<$Res> get multistateSelector {
    return $SpecificResrcCharMultistateSelectorCopyWith<$Res>(
        _value.multistateSelector, (value) {
      return _then(_value.copyWith(multistateSelector: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharCopyWith<$Res>
    implements $SpecificResrcCharCopyWith<$Res> {
  factory _$SpecificResrcCharCopyWith(
          _SpecificResrcChar value, $Res Function(_SpecificResrcChar) then) =
      __$SpecificResrcCharCopyWithImpl<$Res>;
  @override
  $Res call(
      {SpecificResrcCharLwm2mSecurity lwm2mSecurity,
      SpecificResrcCharLwm2mServer lwm2mServer,
      SpecificResrcCharAccessCtrl accessCtrl,
      Map<String, InstanceAndOpsCtrl> device,
      Map<String, InstanceAndOpsCtrl> connMonitor,
      SpecificResrcCharFirmware firmware,
      SpecificResrcCharLocation location,
      SpecificResrcCharConnStatistics connStatistics,
      SpecificResrcCharDIn dIn,
      SpecificResrcCharDOut dOut,
      SpecificResrcCharAIn aIn,
      SpecificResrcCharAOut aOut,
      SpecificResrcCharGeneric generic,
      SpecificResrcCharGeneric illuminance,
      SpecificResrcCharPresence presence,
      SpecificResrcCharGeneric temperature,
      SpecificResrcCharGeneric humidity,
      Map<String, InstanceAndOpsCtrl> pwrMea,
      SpecificResrcCharActuation actuation,
      SpecificResrcCharSetPoint setPoint,
      SpecificResrcCharLoadCtrl loadCtrl,
      SpecificResrcCharLightCtrl lightCtrl,
      SpecificResrcCharPwrCtrl pwrCtrl,
      SpecificResrcCharAccelerometer accelerometer,
      SpecificResrcCharMagnetometer magnetometer,
      SpecificResrcCharGeneric barometer,
      SpecificResrcCharGeneric voltage,
      SpecificResrcCharGeneric current,
      SpecificResrcCharGeneric frequency,
      SpecificResrcCharGeneric depth,
      SpecificResrcCharGeneric percentage,
      SpecificResrcCharGeneric altitude,
      SpecificResrcCharGeneric load,
      SpecificResrcCharGeneric pressure,
      SpecificResrcCharGeneric loudness,
      SpecificResrcCharGeneric concentration,
      SpecificResrcCharGeneric acidity,
      SpecificResrcCharGeneric conductivity,
      SpecificResrcCharGeneric power,
      SpecificResrcCharGeneric powerFactor,
      SpecificResrcCharGeneric distance,
      SpecificResrcCharEnergy energy,
      SpecificResrcCharDirection direction,
      SpecificResrcCharTime time,
      Map<String, InstanceAndOpsCtrl> gyrometer,
      SpecificResrcCharColour colour,
      SpecificResrcCharGpsLocation gpsLocation,
      SpecificResrcCharPositioner positioner,
      SpecificResrcCharBuzzer buzzer,
      SpecificResrcCharAudioClip audioClip,
      Map<String, InstanceAndOpsCtrl> timer,
      Map<String, InstanceAndOpsCtrl> addressableTextDisplay,
      SpecificResrcCharOnOffSwitch onOffSwitch,
      SpecificResrcCharLevelControl levelControl,
      SpecificResrcCharUpDownControl upDownControl,
      SpecificResrcCharMultipleAxisJoystick multipleAxisJoystick,
      SpecificResrcCharGeneric rate,
      SpecificResrcCharPushButton pushButton,
      SpecificResrcCharMultistateSelector multistateSelector});

  @override
  $SpecificResrcCharLwm2mSecurityCopyWith<$Res> get lwm2mSecurity;
  @override
  $SpecificResrcCharLwm2mServerCopyWith<$Res> get lwm2mServer;
  @override
  $SpecificResrcCharAccessCtrlCopyWith<$Res> get accessCtrl;
  @override
  $SpecificResrcCharFirmwareCopyWith<$Res> get firmware;
  @override
  $SpecificResrcCharLocationCopyWith<$Res> get location;
  @override
  $SpecificResrcCharConnStatisticsCopyWith<$Res> get connStatistics;
  @override
  $SpecificResrcCharDInCopyWith<$Res> get dIn;
  @override
  $SpecificResrcCharDOutCopyWith<$Res> get dOut;
  @override
  $SpecificResrcCharAInCopyWith<$Res> get aIn;
  @override
  $SpecificResrcCharAOutCopyWith<$Res> get aOut;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get generic;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get illuminance;
  @override
  $SpecificResrcCharPresenceCopyWith<$Res> get presence;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get temperature;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get humidity;
  @override
  $SpecificResrcCharActuationCopyWith<$Res> get actuation;
  @override
  $SpecificResrcCharSetPointCopyWith<$Res> get setPoint;
  @override
  $SpecificResrcCharLoadCtrlCopyWith<$Res> get loadCtrl;
  @override
  $SpecificResrcCharLightCtrlCopyWith<$Res> get lightCtrl;
  @override
  $SpecificResrcCharPwrCtrlCopyWith<$Res> get pwrCtrl;
  @override
  $SpecificResrcCharAccelerometerCopyWith<$Res> get accelerometer;
  @override
  $SpecificResrcCharMagnetometerCopyWith<$Res> get magnetometer;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get barometer;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get voltage;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get current;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get frequency;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get depth;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get percentage;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get altitude;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get load;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get pressure;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get loudness;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get concentration;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get acidity;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get conductivity;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get power;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get powerFactor;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get distance;
  @override
  $SpecificResrcCharEnergyCopyWith<$Res> get energy;
  @override
  $SpecificResrcCharDirectionCopyWith<$Res> get direction;
  @override
  $SpecificResrcCharTimeCopyWith<$Res> get time;
  @override
  $SpecificResrcCharColourCopyWith<$Res> get colour;
  @override
  $SpecificResrcCharGpsLocationCopyWith<$Res> get gpsLocation;
  @override
  $SpecificResrcCharPositionerCopyWith<$Res> get positioner;
  @override
  $SpecificResrcCharBuzzerCopyWith<$Res> get buzzer;
  @override
  $SpecificResrcCharAudioClipCopyWith<$Res> get audioClip;
  @override
  $SpecificResrcCharOnOffSwitchCopyWith<$Res> get onOffSwitch;
  @override
  $SpecificResrcCharLevelControlCopyWith<$Res> get levelControl;
  @override
  $SpecificResrcCharUpDownControlCopyWith<$Res> get upDownControl;
  @override
  $SpecificResrcCharMultipleAxisJoystickCopyWith<$Res> get multipleAxisJoystick;
  @override
  $SpecificResrcCharGenericCopyWith<$Res> get rate;
  @override
  $SpecificResrcCharPushButtonCopyWith<$Res> get pushButton;
  @override
  $SpecificResrcCharMultistateSelectorCopyWith<$Res> get multistateSelector;
}

/// @nodoc
class __$SpecificResrcCharCopyWithImpl<$Res>
    extends _$SpecificResrcCharCopyWithImpl<$Res>
    implements _$SpecificResrcCharCopyWith<$Res> {
  __$SpecificResrcCharCopyWithImpl(
      _SpecificResrcChar _value, $Res Function(_SpecificResrcChar) _then)
      : super(_value, (v) => _then(v as _SpecificResrcChar));

  @override
  _SpecificResrcChar get _value => super._value as _SpecificResrcChar;

  @override
  $Res call({
    Object? lwm2mSecurity = freezed,
    Object? lwm2mServer = freezed,
    Object? accessCtrl = freezed,
    Object? device = freezed,
    Object? connMonitor = freezed,
    Object? firmware = freezed,
    Object? location = freezed,
    Object? connStatistics = freezed,
    Object? dIn = freezed,
    Object? dOut = freezed,
    Object? aIn = freezed,
    Object? aOut = freezed,
    Object? generic = freezed,
    Object? illuminance = freezed,
    Object? presence = freezed,
    Object? temperature = freezed,
    Object? humidity = freezed,
    Object? pwrMea = freezed,
    Object? actuation = freezed,
    Object? setPoint = freezed,
    Object? loadCtrl = freezed,
    Object? lightCtrl = freezed,
    Object? pwrCtrl = freezed,
    Object? accelerometer = freezed,
    Object? magnetometer = freezed,
    Object? barometer = freezed,
    Object? voltage = freezed,
    Object? current = freezed,
    Object? frequency = freezed,
    Object? depth = freezed,
    Object? percentage = freezed,
    Object? altitude = freezed,
    Object? load = freezed,
    Object? pressure = freezed,
    Object? loudness = freezed,
    Object? concentration = freezed,
    Object? acidity = freezed,
    Object? conductivity = freezed,
    Object? power = freezed,
    Object? powerFactor = freezed,
    Object? distance = freezed,
    Object? energy = freezed,
    Object? direction = freezed,
    Object? time = freezed,
    Object? gyrometer = freezed,
    Object? colour = freezed,
    Object? gpsLocation = freezed,
    Object? positioner = freezed,
    Object? buzzer = freezed,
    Object? audioClip = freezed,
    Object? timer = freezed,
    Object? addressableTextDisplay = freezed,
    Object? onOffSwitch = freezed,
    Object? levelControl = freezed,
    Object? upDownControl = freezed,
    Object? multipleAxisJoystick = freezed,
    Object? rate = freezed,
    Object? pushButton = freezed,
    Object? multistateSelector = freezed,
  }) {
    return _then(_SpecificResrcChar(
      lwm2mSecurity: lwm2mSecurity == freezed
          ? _value.lwm2mSecurity
          : lwm2mSecurity // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharLwm2mSecurity,
      lwm2mServer: lwm2mServer == freezed
          ? _value.lwm2mServer
          : lwm2mServer // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharLwm2mServer,
      accessCtrl: accessCtrl == freezed
          ? _value.accessCtrl
          : accessCtrl // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharAccessCtrl,
      device: device == freezed
          ? _value.device
          : device // ignore: cast_nullable_to_non_nullable
              as Map<String, InstanceAndOpsCtrl>,
      connMonitor: connMonitor == freezed
          ? _value.connMonitor
          : connMonitor // ignore: cast_nullable_to_non_nullable
              as Map<String, InstanceAndOpsCtrl>,
      firmware: firmware == freezed
          ? _value.firmware
          : firmware // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharFirmware,
      location: location == freezed
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharLocation,
      connStatistics: connStatistics == freezed
          ? _value.connStatistics
          : connStatistics // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharConnStatistics,
      dIn: dIn == freezed
          ? _value.dIn
          : dIn // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharDIn,
      dOut: dOut == freezed
          ? _value.dOut
          : dOut // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharDOut,
      aIn: aIn == freezed
          ? _value.aIn
          : aIn // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharAIn,
      aOut: aOut == freezed
          ? _value.aOut
          : aOut // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharAOut,
      generic: generic == freezed
          ? _value.generic
          : generic // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      illuminance: illuminance == freezed
          ? _value.illuminance
          : illuminance // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      presence: presence == freezed
          ? _value.presence
          : presence // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharPresence,
      temperature: temperature == freezed
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      humidity: humidity == freezed
          ? _value.humidity
          : humidity // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      pwrMea: pwrMea == freezed
          ? _value.pwrMea
          : pwrMea // ignore: cast_nullable_to_non_nullable
              as Map<String, InstanceAndOpsCtrl>,
      actuation: actuation == freezed
          ? _value.actuation
          : actuation // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharActuation,
      setPoint: setPoint == freezed
          ? _value.setPoint
          : setPoint // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharSetPoint,
      loadCtrl: loadCtrl == freezed
          ? _value.loadCtrl
          : loadCtrl // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharLoadCtrl,
      lightCtrl: lightCtrl == freezed
          ? _value.lightCtrl
          : lightCtrl // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharLightCtrl,
      pwrCtrl: pwrCtrl == freezed
          ? _value.pwrCtrl
          : pwrCtrl // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharPwrCtrl,
      accelerometer: accelerometer == freezed
          ? _value.accelerometer
          : accelerometer // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharAccelerometer,
      magnetometer: magnetometer == freezed
          ? _value.magnetometer
          : magnetometer // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharMagnetometer,
      barometer: barometer == freezed
          ? _value.barometer
          : barometer // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      voltage: voltage == freezed
          ? _value.voltage
          : voltage // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      current: current == freezed
          ? _value.current
          : current // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      frequency: frequency == freezed
          ? _value.frequency
          : frequency // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      depth: depth == freezed
          ? _value.depth
          : depth // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      percentage: percentage == freezed
          ? _value.percentage
          : percentage // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      altitude: altitude == freezed
          ? _value.altitude
          : altitude // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      load: load == freezed
          ? _value.load
          : load // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      pressure: pressure == freezed
          ? _value.pressure
          : pressure // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      loudness: loudness == freezed
          ? _value.loudness
          : loudness // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      concentration: concentration == freezed
          ? _value.concentration
          : concentration // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      acidity: acidity == freezed
          ? _value.acidity
          : acidity // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      conductivity: conductivity == freezed
          ? _value.conductivity
          : conductivity // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      power: power == freezed
          ? _value.power
          : power // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      powerFactor: powerFactor == freezed
          ? _value.powerFactor
          : powerFactor // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      distance: distance == freezed
          ? _value.distance
          : distance // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      energy: energy == freezed
          ? _value.energy
          : energy // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharEnergy,
      direction: direction == freezed
          ? _value.direction
          : direction // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharDirection,
      time: time == freezed
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharTime,
      gyrometer: gyrometer == freezed
          ? _value.gyrometer
          : gyrometer // ignore: cast_nullable_to_non_nullable
              as Map<String, InstanceAndOpsCtrl>,
      colour: colour == freezed
          ? _value.colour
          : colour // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharColour,
      gpsLocation: gpsLocation == freezed
          ? _value.gpsLocation
          : gpsLocation // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGpsLocation,
      positioner: positioner == freezed
          ? _value.positioner
          : positioner // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharPositioner,
      buzzer: buzzer == freezed
          ? _value.buzzer
          : buzzer // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharBuzzer,
      audioClip: audioClip == freezed
          ? _value.audioClip
          : audioClip // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharAudioClip,
      timer: timer == freezed
          ? _value.timer
          : timer // ignore: cast_nullable_to_non_nullable
              as Map<String, InstanceAndOpsCtrl>,
      addressableTextDisplay: addressableTextDisplay == freezed
          ? _value.addressableTextDisplay
          : addressableTextDisplay // ignore: cast_nullable_to_non_nullable
              as Map<String, InstanceAndOpsCtrl>,
      onOffSwitch: onOffSwitch == freezed
          ? _value.onOffSwitch
          : onOffSwitch // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharOnOffSwitch,
      levelControl: levelControl == freezed
          ? _value.levelControl
          : levelControl // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharLevelControl,
      upDownControl: upDownControl == freezed
          ? _value.upDownControl
          : upDownControl // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharUpDownControl,
      multipleAxisJoystick: multipleAxisJoystick == freezed
          ? _value.multipleAxisJoystick
          : multipleAxisJoystick // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharMultipleAxisJoystick,
      rate: rate == freezed
          ? _value.rate
          : rate // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharGeneric,
      pushButton: pushButton == freezed
          ? _value.pushButton
          : pushButton // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharPushButton,
      multistateSelector: multistateSelector == freezed
          ? _value.multistateSelector
          : multistateSelector // ignore: cast_nullable_to_non_nullable
              as SpecificResrcCharMultistateSelector,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcChar implements _SpecificResrcChar {
  const _$_SpecificResrcChar(
      {required this.lwm2mSecurity,
      required this.lwm2mServer,
      required this.accessCtrl,
      required this.device,
      required this.connMonitor,
      required this.firmware,
      required this.location,
      required this.connStatistics,
      required this.dIn,
      required this.dOut,
      required this.aIn,
      required this.aOut,
      required this.generic,
      required this.illuminance,
      required this.presence,
      required this.temperature,
      required this.humidity,
      required this.pwrMea,
      required this.actuation,
      required this.setPoint,
      required this.loadCtrl,
      required this.lightCtrl,
      required this.pwrCtrl,
      required this.accelerometer,
      required this.magnetometer,
      required this.barometer,
      required this.voltage,
      required this.current,
      required this.frequency,
      required this.depth,
      required this.percentage,
      required this.altitude,
      required this.load,
      required this.pressure,
      required this.loudness,
      required this.concentration,
      required this.acidity,
      required this.conductivity,
      required this.power,
      required this.powerFactor,
      required this.distance,
      required this.energy,
      required this.direction,
      required this.time,
      required this.gyrometer,
      required this.colour,
      required this.gpsLocation,
      required this.positioner,
      required this.buzzer,
      required this.audioClip,
      required this.timer,
      required this.addressableTextDisplay,
      required this.onOffSwitch,
      required this.levelControl,
      required this.upDownControl,
      required this.multipleAxisJoystick,
      required this.rate,
      required this.pushButton,
      required this.multistateSelector});

  factory _$_SpecificResrcChar.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharFromJson(json);

  @override
  final SpecificResrcCharLwm2mSecurity lwm2mSecurity;
  @override
  final SpecificResrcCharLwm2mServer lwm2mServer;
  @override
  final SpecificResrcCharAccessCtrl accessCtrl;
  @override
  final Map<String, InstanceAndOpsCtrl> device;
  @override //TODO
  final Map<String, InstanceAndOpsCtrl> connMonitor;
  @override //TODO
  final SpecificResrcCharFirmware firmware;
  @override
  final SpecificResrcCharLocation location;
  @override
  final SpecificResrcCharConnStatistics connStatistics;
  @override
  final SpecificResrcCharDIn dIn;
  @override
  final SpecificResrcCharDOut dOut;
  @override
  final SpecificResrcCharAIn aIn;
  @override
  final SpecificResrcCharAOut aOut;
  @override
  final SpecificResrcCharGeneric generic;
  @override
  final SpecificResrcCharGeneric illuminance;
  @override
  final SpecificResrcCharPresence presence;
  @override
  final SpecificResrcCharGeneric temperature;
  @override
  final SpecificResrcCharGeneric humidity;
  @override
  final Map<String, InstanceAndOpsCtrl> pwrMea;
  @override //TODO
  final SpecificResrcCharActuation actuation;
  @override
  final SpecificResrcCharSetPoint setPoint;
  @override
  final SpecificResrcCharLoadCtrl loadCtrl;
  @override
  final SpecificResrcCharLightCtrl lightCtrl;
  @override
  final SpecificResrcCharPwrCtrl pwrCtrl;
  @override
  final SpecificResrcCharAccelerometer accelerometer;
  @override
  final SpecificResrcCharMagnetometer magnetometer;
  @override
  final SpecificResrcCharGeneric barometer;
  @override
  final SpecificResrcCharGeneric voltage;
  @override
  final SpecificResrcCharGeneric current;
  @override
  final SpecificResrcCharGeneric frequency;
  @override
  final SpecificResrcCharGeneric depth;
  @override
  final SpecificResrcCharGeneric percentage;
  @override
  final SpecificResrcCharGeneric altitude;
  @override
  final SpecificResrcCharGeneric load;
  @override
  final SpecificResrcCharGeneric pressure;
  @override
  final SpecificResrcCharGeneric loudness;
  @override
  final SpecificResrcCharGeneric concentration;
  @override
  final SpecificResrcCharGeneric acidity;
  @override
  final SpecificResrcCharGeneric conductivity;
  @override
  final SpecificResrcCharGeneric power;
  @override
  final SpecificResrcCharGeneric powerFactor;
  @override
  final SpecificResrcCharGeneric distance;
  @override
  final SpecificResrcCharEnergy energy;
  @override
  final SpecificResrcCharDirection direction;
  @override
  final SpecificResrcCharTime time;
  @override
  final Map<String, InstanceAndOpsCtrl> gyrometer;
  @override //TODO
  final SpecificResrcCharColour colour;
  @override
  final SpecificResrcCharGpsLocation gpsLocation;
  @override
  final SpecificResrcCharPositioner positioner;
  @override
  final SpecificResrcCharBuzzer buzzer;
  @override
  final SpecificResrcCharAudioClip audioClip;
  @override
  final Map<String, InstanceAndOpsCtrl> timer;
  @override //TODO
  final Map<String, InstanceAndOpsCtrl> addressableTextDisplay;
  @override //TODO
  final SpecificResrcCharOnOffSwitch onOffSwitch;
  @override
  final SpecificResrcCharLevelControl levelControl;
  @override
  final SpecificResrcCharUpDownControl upDownControl;
  @override
  final SpecificResrcCharMultipleAxisJoystick multipleAxisJoystick;
  @override
  final SpecificResrcCharGeneric rate;
  @override
  final SpecificResrcCharPushButton pushButton;
  @override
  final SpecificResrcCharMultistateSelector multistateSelector;

  @override
  String toString() {
    return 'SpecificResrcChar(lwm2mSecurity: $lwm2mSecurity, lwm2mServer: $lwm2mServer, accessCtrl: $accessCtrl, device: $device, connMonitor: $connMonitor, firmware: $firmware, location: $location, connStatistics: $connStatistics, dIn: $dIn, dOut: $dOut, aIn: $aIn, aOut: $aOut, generic: $generic, illuminance: $illuminance, presence: $presence, temperature: $temperature, humidity: $humidity, pwrMea: $pwrMea, actuation: $actuation, setPoint: $setPoint, loadCtrl: $loadCtrl, lightCtrl: $lightCtrl, pwrCtrl: $pwrCtrl, accelerometer: $accelerometer, magnetometer: $magnetometer, barometer: $barometer, voltage: $voltage, current: $current, frequency: $frequency, depth: $depth, percentage: $percentage, altitude: $altitude, load: $load, pressure: $pressure, loudness: $loudness, concentration: $concentration, acidity: $acidity, conductivity: $conductivity, power: $power, powerFactor: $powerFactor, distance: $distance, energy: $energy, direction: $direction, time: $time, gyrometer: $gyrometer, colour: $colour, gpsLocation: $gpsLocation, positioner: $positioner, buzzer: $buzzer, audioClip: $audioClip, timer: $timer, addressableTextDisplay: $addressableTextDisplay, onOffSwitch: $onOffSwitch, levelControl: $levelControl, upDownControl: $upDownControl, multipleAxisJoystick: $multipleAxisJoystick, rate: $rate, pushButton: $pushButton, multistateSelector: $multistateSelector)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcChar &&
            (identical(other.lwm2mSecurity, lwm2mSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.lwm2mSecurity, lwm2mSecurity)) &&
            (identical(other.lwm2mServer, lwm2mServer) ||
                const DeepCollectionEquality()
                    .equals(other.lwm2mServer, lwm2mServer)) &&
            (identical(other.accessCtrl, accessCtrl) ||
                const DeepCollectionEquality()
                    .equals(other.accessCtrl, accessCtrl)) &&
            (identical(other.device, device) ||
                const DeepCollectionEquality().equals(other.device, device)) &&
            (identical(other.connMonitor, connMonitor) ||
                const DeepCollectionEquality()
                    .equals(other.connMonitor, connMonitor)) &&
            (identical(other.firmware, firmware) ||
                const DeepCollectionEquality()
                    .equals(other.firmware, firmware)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.connStatistics, connStatistics) ||
                const DeepCollectionEquality()
                    .equals(other.connStatistics, connStatistics)) &&
            (identical(other.dIn, dIn) ||
                const DeepCollectionEquality().equals(other.dIn, dIn)) &&
            (identical(other.dOut, dOut) ||
                const DeepCollectionEquality().equals(other.dOut, dOut)) &&
            (identical(other.aIn, aIn) ||
                const DeepCollectionEquality().equals(other.aIn, aIn)) &&
            (identical(other.aOut, aOut) ||
                const DeepCollectionEquality().equals(other.aOut, aOut)) &&
            (identical(other.generic, generic) ||
                const DeepCollectionEquality()
                    .equals(other.generic, generic)) &&
            (identical(other.illuminance, illuminance) ||
                const DeepCollectionEquality()
                    .equals(other.illuminance, illuminance)) &&
            (identical(other.presence, presence) ||
                const DeepCollectionEquality()
                    .equals(other.presence, presence)) &&
            (identical(other.temperature, temperature) ||
                const DeepCollectionEquality()
                    .equals(other.temperature, temperature)) &&
            (identical(other.humidity, humidity) ||
                const DeepCollectionEquality()
                    .equals(other.humidity, humidity)) &&
            (identical(other.pwrMea, pwrMea) ||
                const DeepCollectionEquality().equals(other.pwrMea, pwrMea)) &&
            (identical(other.actuation, actuation) ||
                const DeepCollectionEquality()
                    .equals(other.actuation, actuation)) &&
            (identical(other.setPoint, setPoint) ||
                const DeepCollectionEquality()
                    .equals(other.setPoint, setPoint)) &&
            (identical(other.loadCtrl, loadCtrl) ||
                const DeepCollectionEquality()
                    .equals(other.loadCtrl, loadCtrl)) &&
            (identical(other.lightCtrl, lightCtrl) ||
                const DeepCollectionEquality()
                    .equals(other.lightCtrl, lightCtrl)) &&
            (identical(other.pwrCtrl, pwrCtrl) ||
                const DeepCollectionEquality()
                    .equals(other.pwrCtrl, pwrCtrl)) &&
            (identical(other.accelerometer, accelerometer) ||
                const DeepCollectionEquality()
                    .equals(other.accelerometer, accelerometer)) &&
            (identical(other.magnetometer, magnetometer) ||
                const DeepCollectionEquality().equals(other.magnetometer, magnetometer)) &&
            (identical(other.barometer, barometer) || const DeepCollectionEquality().equals(other.barometer, barometer)) &&
            (identical(other.voltage, voltage) || const DeepCollectionEquality().equals(other.voltage, voltage)) &&
            (identical(other.current, current) || const DeepCollectionEquality().equals(other.current, current)) &&
            (identical(other.frequency, frequency) || const DeepCollectionEquality().equals(other.frequency, frequency)) &&
            (identical(other.depth, depth) || const DeepCollectionEquality().equals(other.depth, depth)) &&
            (identical(other.percentage, percentage) || const DeepCollectionEquality().equals(other.percentage, percentage)) &&
            (identical(other.altitude, altitude) || const DeepCollectionEquality().equals(other.altitude, altitude)) &&
            (identical(other.load, load) || const DeepCollectionEquality().equals(other.load, load)) &&
            (identical(other.pressure, pressure) || const DeepCollectionEquality().equals(other.pressure, pressure)) &&
            (identical(other.loudness, loudness) || const DeepCollectionEquality().equals(other.loudness, loudness)) &&
            (identical(other.concentration, concentration) || const DeepCollectionEquality().equals(other.concentration, concentration)) &&
            (identical(other.acidity, acidity) || const DeepCollectionEquality().equals(other.acidity, acidity)) &&
            (identical(other.conductivity, conductivity) || const DeepCollectionEquality().equals(other.conductivity, conductivity)) &&
            (identical(other.power, power) || const DeepCollectionEquality().equals(other.power, power)) &&
            (identical(other.powerFactor, powerFactor) || const DeepCollectionEquality().equals(other.powerFactor, powerFactor)) &&
            (identical(other.distance, distance) || const DeepCollectionEquality().equals(other.distance, distance)) &&
            (identical(other.energy, energy) || const DeepCollectionEquality().equals(other.energy, energy)) &&
            (identical(other.direction, direction) || const DeepCollectionEquality().equals(other.direction, direction)) &&
            (identical(other.time, time) || const DeepCollectionEquality().equals(other.time, time)) &&
            (identical(other.gyrometer, gyrometer) || const DeepCollectionEquality().equals(other.gyrometer, gyrometer)) &&
            (identical(other.colour, colour) || const DeepCollectionEquality().equals(other.colour, colour)) &&
            (identical(other.gpsLocation, gpsLocation) || const DeepCollectionEquality().equals(other.gpsLocation, gpsLocation)) &&
            (identical(other.positioner, positioner) || const DeepCollectionEquality().equals(other.positioner, positioner)) &&
            (identical(other.buzzer, buzzer) || const DeepCollectionEquality().equals(other.buzzer, buzzer)) &&
            (identical(other.audioClip, audioClip) || const DeepCollectionEquality().equals(other.audioClip, audioClip)) &&
            (identical(other.timer, timer) || const DeepCollectionEquality().equals(other.timer, timer)) &&
            (identical(other.addressableTextDisplay, addressableTextDisplay) || const DeepCollectionEquality().equals(other.addressableTextDisplay, addressableTextDisplay)) &&
            (identical(other.onOffSwitch, onOffSwitch) || const DeepCollectionEquality().equals(other.onOffSwitch, onOffSwitch)) &&
            (identical(other.levelControl, levelControl) || const DeepCollectionEquality().equals(other.levelControl, levelControl)) &&
            (identical(other.upDownControl, upDownControl) || const DeepCollectionEquality().equals(other.upDownControl, upDownControl)) &&
            (identical(other.multipleAxisJoystick, multipleAxisJoystick) || const DeepCollectionEquality().equals(other.multipleAxisJoystick, multipleAxisJoystick)) &&
            (identical(other.rate, rate) || const DeepCollectionEquality().equals(other.rate, rate)) &&
            (identical(other.pushButton, pushButton) || const DeepCollectionEquality().equals(other.pushButton, pushButton)) &&
            (identical(other.multistateSelector, multistateSelector) || const DeepCollectionEquality().equals(other.multistateSelector, multistateSelector)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(lwm2mSecurity) ^
      const DeepCollectionEquality().hash(lwm2mServer) ^
      const DeepCollectionEquality().hash(accessCtrl) ^
      const DeepCollectionEquality().hash(device) ^
      const DeepCollectionEquality().hash(connMonitor) ^
      const DeepCollectionEquality().hash(firmware) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(connStatistics) ^
      const DeepCollectionEquality().hash(dIn) ^
      const DeepCollectionEquality().hash(dOut) ^
      const DeepCollectionEquality().hash(aIn) ^
      const DeepCollectionEquality().hash(aOut) ^
      const DeepCollectionEquality().hash(generic) ^
      const DeepCollectionEquality().hash(illuminance) ^
      const DeepCollectionEquality().hash(presence) ^
      const DeepCollectionEquality().hash(temperature) ^
      const DeepCollectionEquality().hash(humidity) ^
      const DeepCollectionEquality().hash(pwrMea) ^
      const DeepCollectionEquality().hash(actuation) ^
      const DeepCollectionEquality().hash(setPoint) ^
      const DeepCollectionEquality().hash(loadCtrl) ^
      const DeepCollectionEquality().hash(lightCtrl) ^
      const DeepCollectionEquality().hash(pwrCtrl) ^
      const DeepCollectionEquality().hash(accelerometer) ^
      const DeepCollectionEquality().hash(magnetometer) ^
      const DeepCollectionEquality().hash(barometer) ^
      const DeepCollectionEquality().hash(voltage) ^
      const DeepCollectionEquality().hash(current) ^
      const DeepCollectionEquality().hash(frequency) ^
      const DeepCollectionEquality().hash(depth) ^
      const DeepCollectionEquality().hash(percentage) ^
      const DeepCollectionEquality().hash(altitude) ^
      const DeepCollectionEquality().hash(load) ^
      const DeepCollectionEquality().hash(pressure) ^
      const DeepCollectionEquality().hash(loudness) ^
      const DeepCollectionEquality().hash(concentration) ^
      const DeepCollectionEquality().hash(acidity) ^
      const DeepCollectionEquality().hash(conductivity) ^
      const DeepCollectionEquality().hash(power) ^
      const DeepCollectionEquality().hash(powerFactor) ^
      const DeepCollectionEquality().hash(distance) ^
      const DeepCollectionEquality().hash(energy) ^
      const DeepCollectionEquality().hash(direction) ^
      const DeepCollectionEquality().hash(time) ^
      const DeepCollectionEquality().hash(gyrometer) ^
      const DeepCollectionEquality().hash(colour) ^
      const DeepCollectionEquality().hash(gpsLocation) ^
      const DeepCollectionEquality().hash(positioner) ^
      const DeepCollectionEquality().hash(buzzer) ^
      const DeepCollectionEquality().hash(audioClip) ^
      const DeepCollectionEquality().hash(timer) ^
      const DeepCollectionEquality().hash(addressableTextDisplay) ^
      const DeepCollectionEquality().hash(onOffSwitch) ^
      const DeepCollectionEquality().hash(levelControl) ^
      const DeepCollectionEquality().hash(upDownControl) ^
      const DeepCollectionEquality().hash(multipleAxisJoystick) ^
      const DeepCollectionEquality().hash(rate) ^
      const DeepCollectionEquality().hash(pushButton) ^
      const DeepCollectionEquality().hash(multistateSelector);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharCopyWith<_SpecificResrcChar> get copyWith =>
      __$SpecificResrcCharCopyWithImpl<_SpecificResrcChar>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharToJson(this);
  }
}

abstract class _SpecificResrcChar implements SpecificResrcChar {
  const factory _SpecificResrcChar(
          {required SpecificResrcCharLwm2mSecurity lwm2mSecurity,
          required SpecificResrcCharLwm2mServer lwm2mServer,
          required SpecificResrcCharAccessCtrl accessCtrl,
          required Map<String, InstanceAndOpsCtrl> device,
          required Map<String, InstanceAndOpsCtrl> connMonitor,
          required SpecificResrcCharFirmware firmware,
          required SpecificResrcCharLocation location,
          required SpecificResrcCharConnStatistics connStatistics,
          required SpecificResrcCharDIn dIn,
          required SpecificResrcCharDOut dOut,
          required SpecificResrcCharAIn aIn,
          required SpecificResrcCharAOut aOut,
          required SpecificResrcCharGeneric generic,
          required SpecificResrcCharGeneric illuminance,
          required SpecificResrcCharPresence presence,
          required SpecificResrcCharGeneric temperature,
          required SpecificResrcCharGeneric humidity,
          required Map<String, InstanceAndOpsCtrl> pwrMea,
          required SpecificResrcCharActuation actuation,
          required SpecificResrcCharSetPoint setPoint,
          required SpecificResrcCharLoadCtrl loadCtrl,
          required SpecificResrcCharLightCtrl lightCtrl,
          required SpecificResrcCharPwrCtrl pwrCtrl,
          required SpecificResrcCharAccelerometer accelerometer,
          required SpecificResrcCharMagnetometer magnetometer,
          required SpecificResrcCharGeneric barometer,
          required SpecificResrcCharGeneric voltage,
          required SpecificResrcCharGeneric current,
          required SpecificResrcCharGeneric frequency,
          required SpecificResrcCharGeneric depth,
          required SpecificResrcCharGeneric percentage,
          required SpecificResrcCharGeneric altitude,
          required SpecificResrcCharGeneric load,
          required SpecificResrcCharGeneric pressure,
          required SpecificResrcCharGeneric loudness,
          required SpecificResrcCharGeneric concentration,
          required SpecificResrcCharGeneric acidity,
          required SpecificResrcCharGeneric conductivity,
          required SpecificResrcCharGeneric power,
          required SpecificResrcCharGeneric powerFactor,
          required SpecificResrcCharGeneric distance,
          required SpecificResrcCharEnergy energy,
          required SpecificResrcCharDirection direction,
          required SpecificResrcCharTime time,
          required Map<String, InstanceAndOpsCtrl> gyrometer,
          required SpecificResrcCharColour colour,
          required SpecificResrcCharGpsLocation gpsLocation,
          required SpecificResrcCharPositioner positioner,
          required SpecificResrcCharBuzzer buzzer,
          required SpecificResrcCharAudioClip audioClip,
          required Map<String, InstanceAndOpsCtrl> timer,
          required Map<String, InstanceAndOpsCtrl> addressableTextDisplay,
          required SpecificResrcCharOnOffSwitch onOffSwitch,
          required SpecificResrcCharLevelControl levelControl,
          required SpecificResrcCharUpDownControl upDownControl,
          required SpecificResrcCharMultipleAxisJoystick multipleAxisJoystick,
          required SpecificResrcCharGeneric rate,
          required SpecificResrcCharPushButton pushButton,
          required SpecificResrcCharMultistateSelector multistateSelector}) =
      _$_SpecificResrcChar;

  factory _SpecificResrcChar.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcChar.fromJson;

  @override
  SpecificResrcCharLwm2mSecurity get lwm2mSecurity =>
      throw _privateConstructorUsedError;
  @override
  SpecificResrcCharLwm2mServer get lwm2mServer =>
      throw _privateConstructorUsedError;
  @override
  SpecificResrcCharAccessCtrl get accessCtrl =>
      throw _privateConstructorUsedError;
  @override
  Map<String, InstanceAndOpsCtrl> get device =>
      throw _privateConstructorUsedError;
  @override //TODO
  Map<String, InstanceAndOpsCtrl> get connMonitor =>
      throw _privateConstructorUsedError;
  @override //TODO
  SpecificResrcCharFirmware get firmware => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharLocation get location => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharConnStatistics get connStatistics =>
      throw _privateConstructorUsedError;
  @override
  SpecificResrcCharDIn get dIn => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharDOut get dOut => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharAIn get aIn => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharAOut get aOut => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get generic => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get illuminance =>
      throw _privateConstructorUsedError;
  @override
  SpecificResrcCharPresence get presence => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get temperature =>
      throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get humidity => throw _privateConstructorUsedError;
  @override
  Map<String, InstanceAndOpsCtrl> get pwrMea =>
      throw _privateConstructorUsedError;
  @override //TODO
  SpecificResrcCharActuation get actuation =>
      throw _privateConstructorUsedError;
  @override
  SpecificResrcCharSetPoint get setPoint => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharLoadCtrl get loadCtrl => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharLightCtrl get lightCtrl =>
      throw _privateConstructorUsedError;
  @override
  SpecificResrcCharPwrCtrl get pwrCtrl => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharAccelerometer get accelerometer =>
      throw _privateConstructorUsedError;
  @override
  SpecificResrcCharMagnetometer get magnetometer =>
      throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get barometer => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get voltage => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get current => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get frequency => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get depth => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get percentage => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get altitude => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get load => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get pressure => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get loudness => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get concentration =>
      throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get acidity => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get conductivity =>
      throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get power => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get powerFactor =>
      throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get distance => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharEnergy get energy => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharDirection get direction =>
      throw _privateConstructorUsedError;
  @override
  SpecificResrcCharTime get time => throw _privateConstructorUsedError;
  @override
  Map<String, InstanceAndOpsCtrl> get gyrometer =>
      throw _privateConstructorUsedError;
  @override //TODO
  SpecificResrcCharColour get colour => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGpsLocation get gpsLocation =>
      throw _privateConstructorUsedError;
  @override
  SpecificResrcCharPositioner get positioner =>
      throw _privateConstructorUsedError;
  @override
  SpecificResrcCharBuzzer get buzzer => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharAudioClip get audioClip =>
      throw _privateConstructorUsedError;
  @override
  Map<String, InstanceAndOpsCtrl> get timer =>
      throw _privateConstructorUsedError;
  @override //TODO
  Map<String, InstanceAndOpsCtrl> get addressableTextDisplay =>
      throw _privateConstructorUsedError;
  @override //TODO
  SpecificResrcCharOnOffSwitch get onOffSwitch =>
      throw _privateConstructorUsedError;
  @override
  SpecificResrcCharLevelControl get levelControl =>
      throw _privateConstructorUsedError;
  @override
  SpecificResrcCharUpDownControl get upDownControl =>
      throw _privateConstructorUsedError;
  @override
  SpecificResrcCharMultipleAxisJoystick get multipleAxisJoystick =>
      throw _privateConstructorUsedError;
  @override
  SpecificResrcCharGeneric get rate => throw _privateConstructorUsedError;
  @override
  SpecificResrcCharPushButton get pushButton =>
      throw _privateConstructorUsedError;
  @override
  SpecificResrcCharMultistateSelector get multistateSelector =>
      throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharCopyWith<_SpecificResrcChar> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificResrcCharAIn _$SpecificResrcCharAInFromJson(Map<String, dynamic> json) {
  return _SpecificResrcCharAIn.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharAInTearOff {
  const _$SpecificResrcCharAInTearOff();

  _SpecificResrcCharAIn call(
      {required InstanceAndOpsCtrl aInCurrValue,
      required InstanceAndOpsCtrl minMeaValue,
      required InstanceAndOpsCtrl maxMeaValue,
      required InstanceAndOpsCtrl minRangeValue,
      required InstanceAndOpsCtrl maxRangeValue,
      required InstanceAndOpsCtrl resetMinMaxMeaValues,
      required InstanceAndOpsCtrl appType,
      required InstanceAndOpsCtrl sensorType}) {
    return _SpecificResrcCharAIn(
      aInCurrValue: aInCurrValue,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      appType: appType,
      sensorType: sensorType,
    );
  }

  SpecificResrcCharAIn fromJson(Map<String, Object> json) {
    return SpecificResrcCharAIn.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharAIn = _$SpecificResrcCharAInTearOff();

/// @nodoc
mixin _$SpecificResrcCharAIn {
  InstanceAndOpsCtrl get aInCurrValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get minMeaValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get maxMeaValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get minRangeValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get maxRangeValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get resetMinMaxMeaValues =>
      throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get sensorType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharAInCopyWith<SpecificResrcCharAIn> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharAInCopyWith<$Res> {
  factory $SpecificResrcCharAInCopyWith(SpecificResrcCharAIn value,
          $Res Function(SpecificResrcCharAIn) then) =
      _$SpecificResrcCharAInCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl aInCurrValue,
      InstanceAndOpsCtrl minMeaValue,
      InstanceAndOpsCtrl maxMeaValue,
      InstanceAndOpsCtrl minRangeValue,
      InstanceAndOpsCtrl maxRangeValue,
      InstanceAndOpsCtrl resetMinMaxMeaValues,
      InstanceAndOpsCtrl appType,
      InstanceAndOpsCtrl sensorType});

  $InstanceAndOpsCtrlCopyWith<$Res> get aInCurrValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get minMeaValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get maxMeaValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get minRangeValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get maxRangeValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get resetMinMaxMeaValues;
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
  $InstanceAndOpsCtrlCopyWith<$Res> get sensorType;
}

/// @nodoc
class _$SpecificResrcCharAInCopyWithImpl<$Res>
    implements $SpecificResrcCharAInCopyWith<$Res> {
  _$SpecificResrcCharAInCopyWithImpl(this._value, this._then);

  final SpecificResrcCharAIn _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharAIn) _then;

  @override
  $Res call({
    Object? aInCurrValue = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? appType = freezed,
    Object? sensorType = freezed,
  }) {
    return _then(_value.copyWith(
      aInCurrValue: aInCurrValue == freezed
          ? _value.aInCurrValue
          : aInCurrValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      sensorType: sensorType == freezed
          ? _value.sensorType
          : sensorType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get aInCurrValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.aInCurrValue, (value) {
      return _then(_value.copyWith(aInCurrValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get minMeaValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.minMeaValue, (value) {
      return _then(_value.copyWith(minMeaValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get maxMeaValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.maxMeaValue, (value) {
      return _then(_value.copyWith(maxMeaValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get minRangeValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.minRangeValue, (value) {
      return _then(_value.copyWith(minRangeValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get maxRangeValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.maxRangeValue, (value) {
      return _then(_value.copyWith(maxRangeValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get resetMinMaxMeaValues {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.resetMinMaxMeaValues,
        (value) {
      return _then(_value.copyWith(resetMinMaxMeaValues: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get sensorType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.sensorType, (value) {
      return _then(_value.copyWith(sensorType: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharAInCopyWith<$Res>
    implements $SpecificResrcCharAInCopyWith<$Res> {
  factory _$SpecificResrcCharAInCopyWith(_SpecificResrcCharAIn value,
          $Res Function(_SpecificResrcCharAIn) then) =
      __$SpecificResrcCharAInCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl aInCurrValue,
      InstanceAndOpsCtrl minMeaValue,
      InstanceAndOpsCtrl maxMeaValue,
      InstanceAndOpsCtrl minRangeValue,
      InstanceAndOpsCtrl maxRangeValue,
      InstanceAndOpsCtrl resetMinMaxMeaValues,
      InstanceAndOpsCtrl appType,
      InstanceAndOpsCtrl sensorType});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get aInCurrValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get minMeaValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get maxMeaValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get minRangeValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get maxRangeValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get resetMinMaxMeaValues;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get sensorType;
}

/// @nodoc
class __$SpecificResrcCharAInCopyWithImpl<$Res>
    extends _$SpecificResrcCharAInCopyWithImpl<$Res>
    implements _$SpecificResrcCharAInCopyWith<$Res> {
  __$SpecificResrcCharAInCopyWithImpl(
      _SpecificResrcCharAIn _value, $Res Function(_SpecificResrcCharAIn) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharAIn));

  @override
  _SpecificResrcCharAIn get _value => super._value as _SpecificResrcCharAIn;

  @override
  $Res call({
    Object? aInCurrValue = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? appType = freezed,
    Object? sensorType = freezed,
  }) {
    return _then(_SpecificResrcCharAIn(
      aInCurrValue: aInCurrValue == freezed
          ? _value.aInCurrValue
          : aInCurrValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      sensorType: sensorType == freezed
          ? _value.sensorType
          : sensorType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharAIn implements _SpecificResrcCharAIn {
  const _$_SpecificResrcCharAIn(
      {required this.aInCurrValue,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues,
      required this.appType,
      required this.sensorType});

  factory _$_SpecificResrcCharAIn.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharAInFromJson(json);

  @override
  final InstanceAndOpsCtrl aInCurrValue;
  @override
  final InstanceAndOpsCtrl minMeaValue;
  @override
  final InstanceAndOpsCtrl maxMeaValue;
  @override
  final InstanceAndOpsCtrl minRangeValue;
  @override
  final InstanceAndOpsCtrl maxRangeValue;
  @override
  final InstanceAndOpsCtrl resetMinMaxMeaValues;
  @override
  final InstanceAndOpsCtrl appType;
  @override
  final InstanceAndOpsCtrl sensorType;

  @override
  String toString() {
    return 'SpecificResrcCharAIn(aInCurrValue: $aInCurrValue, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, appType: $appType, sensorType: $sensorType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharAIn &&
            (identical(other.aInCurrValue, aInCurrValue) ||
                const DeepCollectionEquality()
                    .equals(other.aInCurrValue, aInCurrValue)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality()
                    .equals(other.appType, appType)) &&
            (identical(other.sensorType, sensorType) ||
                const DeepCollectionEquality()
                    .equals(other.sensorType, sensorType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(aInCurrValue) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(appType) ^
      const DeepCollectionEquality().hash(sensorType);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharAInCopyWith<_SpecificResrcCharAIn> get copyWith =>
      __$SpecificResrcCharAInCopyWithImpl<_SpecificResrcCharAIn>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharAInToJson(this);
  }
}

abstract class _SpecificResrcCharAIn implements SpecificResrcCharAIn {
  const factory _SpecificResrcCharAIn(
      {required InstanceAndOpsCtrl aInCurrValue,
      required InstanceAndOpsCtrl minMeaValue,
      required InstanceAndOpsCtrl maxMeaValue,
      required InstanceAndOpsCtrl minRangeValue,
      required InstanceAndOpsCtrl maxRangeValue,
      required InstanceAndOpsCtrl resetMinMaxMeaValues,
      required InstanceAndOpsCtrl appType,
      required InstanceAndOpsCtrl sensorType}) = _$_SpecificResrcCharAIn;

  factory _SpecificResrcCharAIn.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharAIn.fromJson;

  @override
  InstanceAndOpsCtrl get aInCurrValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get minMeaValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get maxMeaValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get minRangeValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get maxRangeValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get resetMinMaxMeaValues =>
      throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get sensorType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharAInCopyWith<_SpecificResrcCharAIn> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificResrcCharGeneric _$SpecificResrcCharGenericFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharGeneric.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharGenericTearOff {
  const _$SpecificResrcCharGenericTearOff();

  _SpecificResrcCharGeneric call(
      {required InstanceAndOpsCtrl sensorValue,
      InstanceAndOpsCtrl? units,
      InstanceAndOpsCtrl? minMeaValue,
      InstanceAndOpsCtrl? maxMeaValue,
      InstanceAndOpsCtrl? minRangeValue,
      InstanceAndOpsCtrl? maxRangeValue,
      InstanceAndOpsCtrl? resetMinMaxMeaValues,
      InstanceAndOpsCtrl? appType,
      InstanceAndOpsCtrl? sensorType,
      InstanceAndOpsCtrl? calOffset}) {
    return _SpecificResrcCharGeneric(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      appType: appType,
      sensorType: sensorType,
      calOffset: calOffset,
    );
  }

  SpecificResrcCharGeneric fromJson(Map<String, Object> json) {
    return SpecificResrcCharGeneric.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharGeneric = _$SpecificResrcCharGenericTearOff();

/// @nodoc
mixin _$SpecificResrcCharGeneric {
  InstanceAndOpsCtrl get sensorValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl? get units => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl? get minMeaValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl? get maxMeaValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl? get minRangeValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl? get maxRangeValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl? get resetMinMaxMeaValues =>
      throw _privateConstructorUsedError;
  InstanceAndOpsCtrl? get appType => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl? get sensorType => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl? get calOffset => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharGenericCopyWith<SpecificResrcCharGeneric> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharGenericCopyWith<$Res> {
  factory $SpecificResrcCharGenericCopyWith(SpecificResrcCharGeneric value,
          $Res Function(SpecificResrcCharGeneric) then) =
      _$SpecificResrcCharGenericCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl sensorValue,
      InstanceAndOpsCtrl? units,
      InstanceAndOpsCtrl? minMeaValue,
      InstanceAndOpsCtrl? maxMeaValue,
      InstanceAndOpsCtrl? minRangeValue,
      InstanceAndOpsCtrl? maxRangeValue,
      InstanceAndOpsCtrl? resetMinMaxMeaValues,
      InstanceAndOpsCtrl? appType,
      InstanceAndOpsCtrl? sensorType,
      InstanceAndOpsCtrl? calOffset});

  $InstanceAndOpsCtrlCopyWith<$Res> get sensorValue;
  $InstanceAndOpsCtrlCopyWith<$Res>? get units;
  $InstanceAndOpsCtrlCopyWith<$Res>? get minMeaValue;
  $InstanceAndOpsCtrlCopyWith<$Res>? get maxMeaValue;
  $InstanceAndOpsCtrlCopyWith<$Res>? get minRangeValue;
  $InstanceAndOpsCtrlCopyWith<$Res>? get maxRangeValue;
  $InstanceAndOpsCtrlCopyWith<$Res>? get resetMinMaxMeaValues;
  $InstanceAndOpsCtrlCopyWith<$Res>? get appType;
  $InstanceAndOpsCtrlCopyWith<$Res>? get sensorType;
  $InstanceAndOpsCtrlCopyWith<$Res>? get calOffset;
}

/// @nodoc
class _$SpecificResrcCharGenericCopyWithImpl<$Res>
    implements $SpecificResrcCharGenericCopyWith<$Res> {
  _$SpecificResrcCharGenericCopyWithImpl(this._value, this._then);

  final SpecificResrcCharGeneric _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharGeneric) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? appType = freezed,
    Object? sensorType = freezed,
    Object? calOffset = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl?,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl?,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl?,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl?,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl?,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl?,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl?,
      sensorType: sensorType == freezed
          ? _value.sensorType
          : sensorType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl?,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl?,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get sensorValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.sensorValue, (value) {
      return _then(_value.copyWith(sensorValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res>? get units {
    if (_value.units == null) {
      return null;
    }

    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.units!, (value) {
      return _then(_value.copyWith(units: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res>? get minMeaValue {
    if (_value.minMeaValue == null) {
      return null;
    }

    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.minMeaValue!, (value) {
      return _then(_value.copyWith(minMeaValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res>? get maxMeaValue {
    if (_value.maxMeaValue == null) {
      return null;
    }

    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.maxMeaValue!, (value) {
      return _then(_value.copyWith(maxMeaValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res>? get minRangeValue {
    if (_value.minRangeValue == null) {
      return null;
    }

    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.minRangeValue!, (value) {
      return _then(_value.copyWith(minRangeValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res>? get maxRangeValue {
    if (_value.maxRangeValue == null) {
      return null;
    }

    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.maxRangeValue!, (value) {
      return _then(_value.copyWith(maxRangeValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res>? get resetMinMaxMeaValues {
    if (_value.resetMinMaxMeaValues == null) {
      return null;
    }

    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.resetMinMaxMeaValues!,
        (value) {
      return _then(_value.copyWith(resetMinMaxMeaValues: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res>? get appType {
    if (_value.appType == null) {
      return null;
    }

    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType!, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res>? get sensorType {
    if (_value.sensorType == null) {
      return null;
    }

    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.sensorType!, (value) {
      return _then(_value.copyWith(sensorType: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res>? get calOffset {
    if (_value.calOffset == null) {
      return null;
    }

    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.calOffset!, (value) {
      return _then(_value.copyWith(calOffset: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharGenericCopyWith<$Res>
    implements $SpecificResrcCharGenericCopyWith<$Res> {
  factory _$SpecificResrcCharGenericCopyWith(_SpecificResrcCharGeneric value,
          $Res Function(_SpecificResrcCharGeneric) then) =
      __$SpecificResrcCharGenericCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl sensorValue,
      InstanceAndOpsCtrl? units,
      InstanceAndOpsCtrl? minMeaValue,
      InstanceAndOpsCtrl? maxMeaValue,
      InstanceAndOpsCtrl? minRangeValue,
      InstanceAndOpsCtrl? maxRangeValue,
      InstanceAndOpsCtrl? resetMinMaxMeaValues,
      InstanceAndOpsCtrl? appType,
      InstanceAndOpsCtrl? sensorType,
      InstanceAndOpsCtrl? calOffset});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get sensorValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res>? get units;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res>? get minMeaValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res>? get maxMeaValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res>? get minRangeValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res>? get maxRangeValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res>? get resetMinMaxMeaValues;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res>? get appType;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res>? get sensorType;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res>? get calOffset;
}

/// @nodoc
class __$SpecificResrcCharGenericCopyWithImpl<$Res>
    extends _$SpecificResrcCharGenericCopyWithImpl<$Res>
    implements _$SpecificResrcCharGenericCopyWith<$Res> {
  __$SpecificResrcCharGenericCopyWithImpl(_SpecificResrcCharGeneric _value,
      $Res Function(_SpecificResrcCharGeneric) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharGeneric));

  @override
  _SpecificResrcCharGeneric get _value =>
      super._value as _SpecificResrcCharGeneric;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? appType = freezed,
    Object? sensorType = freezed,
    Object? calOffset = freezed,
  }) {
    return _then(_SpecificResrcCharGeneric(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl?,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl?,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl?,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl?,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl?,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl?,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl?,
      sensorType: sensorType == freezed
          ? _value.sensorType
          : sensorType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl?,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharGeneric implements _SpecificResrcCharGeneric {
  const _$_SpecificResrcCharGeneric(
      {required this.sensorValue,
      this.units,
      this.minMeaValue,
      this.maxMeaValue,
      this.minRangeValue,
      this.maxRangeValue,
      this.resetMinMaxMeaValues,
      this.appType,
      this.sensorType,
      this.calOffset});

  factory _$_SpecificResrcCharGeneric.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharGenericFromJson(json);

  @override
  final InstanceAndOpsCtrl sensorValue;
  @override
  final InstanceAndOpsCtrl? units;
  @override
  final InstanceAndOpsCtrl? minMeaValue;
  @override
  final InstanceAndOpsCtrl? maxMeaValue;
  @override
  final InstanceAndOpsCtrl? minRangeValue;
  @override
  final InstanceAndOpsCtrl? maxRangeValue;
  @override
  final InstanceAndOpsCtrl? resetMinMaxMeaValues;
  @override
  final InstanceAndOpsCtrl? appType;
  @override
  final InstanceAndOpsCtrl? sensorType;
  @override
  final InstanceAndOpsCtrl? calOffset;

  @override
  String toString() {
    return 'SpecificResrcCharGeneric(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, appType: $appType, sensorType: $sensorType, calOffset: $calOffset)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharGeneric &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality()
                    .equals(other.appType, appType)) &&
            (identical(other.sensorType, sensorType) ||
                const DeepCollectionEquality()
                    .equals(other.sensorType, sensorType)) &&
            (identical(other.calOffset, calOffset) ||
                const DeepCollectionEquality()
                    .equals(other.calOffset, calOffset)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(appType) ^
      const DeepCollectionEquality().hash(sensorType) ^
      const DeepCollectionEquality().hash(calOffset);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharGenericCopyWith<_SpecificResrcCharGeneric> get copyWith =>
      __$SpecificResrcCharGenericCopyWithImpl<_SpecificResrcCharGeneric>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharGenericToJson(this);
  }
}

abstract class _SpecificResrcCharGeneric implements SpecificResrcCharGeneric {
  const factory _SpecificResrcCharGeneric(
      {required InstanceAndOpsCtrl sensorValue,
      InstanceAndOpsCtrl? units,
      InstanceAndOpsCtrl? minMeaValue,
      InstanceAndOpsCtrl? maxMeaValue,
      InstanceAndOpsCtrl? minRangeValue,
      InstanceAndOpsCtrl? maxRangeValue,
      InstanceAndOpsCtrl? resetMinMaxMeaValues,
      InstanceAndOpsCtrl? appType,
      InstanceAndOpsCtrl? sensorType,
      InstanceAndOpsCtrl? calOffset}) = _$_SpecificResrcCharGeneric;

  factory _SpecificResrcCharGeneric.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharGeneric.fromJson;

  @override
  InstanceAndOpsCtrl get sensorValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl? get units => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl? get minMeaValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl? get maxMeaValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl? get minRangeValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl? get maxRangeValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl? get resetMinMaxMeaValues =>
      throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl? get appType => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl? get sensorType => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl? get calOffset => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharGenericCopyWith<_SpecificResrcCharGeneric> get copyWith =>
      throw _privateConstructorUsedError;
}

InstanceAndOpsCtrl _$InstanceAndOpsCtrlFromJson(Map<String, dynamic> json) {
  return _InstanceAndOpsCtrl.fromJson(json);
}

/// @nodoc
class _$InstanceAndOpsCtrlTearOff {
  const _$InstanceAndOpsCtrlTearOff();

  _InstanceAndOpsCtrl call(
      {required AccessMode access,
      required bool multi,
      required bool mand,
      required ValueType type,
      int? range,
      dynamic init}) {
    return _InstanceAndOpsCtrl(
      access: access,
      multi: multi,
      mand: mand,
      type: type,
      range: range,
      init: init,
    );
  }

  InstanceAndOpsCtrl fromJson(Map<String, Object> json) {
    return InstanceAndOpsCtrl.fromJson(json);
  }
}

/// @nodoc
const $InstanceAndOpsCtrl = _$InstanceAndOpsCtrlTearOff();

/// @nodoc
mixin _$InstanceAndOpsCtrl {
  AccessMode get access => throw _privateConstructorUsedError;
  bool get multi => throw _privateConstructorUsedError;
  bool get mand => throw _privateConstructorUsedError;
  ValueType get type => throw _privateConstructorUsedError;
  int? get range => throw _privateConstructorUsedError;
  dynamic get init => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InstanceAndOpsCtrlCopyWith<InstanceAndOpsCtrl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InstanceAndOpsCtrlCopyWith<$Res> {
  factory $InstanceAndOpsCtrlCopyWith(
          InstanceAndOpsCtrl value, $Res Function(InstanceAndOpsCtrl) then) =
      _$InstanceAndOpsCtrlCopyWithImpl<$Res>;
  $Res call(
      {AccessMode access,
      bool multi,
      bool mand,
      ValueType type,
      int? range,
      dynamic init});
}

/// @nodoc
class _$InstanceAndOpsCtrlCopyWithImpl<$Res>
    implements $InstanceAndOpsCtrlCopyWith<$Res> {
  _$InstanceAndOpsCtrlCopyWithImpl(this._value, this._then);

  final InstanceAndOpsCtrl _value;
  // ignore: unused_field
  final $Res Function(InstanceAndOpsCtrl) _then;

  @override
  $Res call({
    Object? access = freezed,
    Object? multi = freezed,
    Object? mand = freezed,
    Object? type = freezed,
    Object? range = freezed,
    Object? init = freezed,
  }) {
    return _then(_value.copyWith(
      access: access == freezed
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as AccessMode,
      multi: multi == freezed
          ? _value.multi
          : multi // ignore: cast_nullable_to_non_nullable
              as bool,
      mand: mand == freezed
          ? _value.mand
          : mand // ignore: cast_nullable_to_non_nullable
              as bool,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ValueType,
      range: range == freezed
          ? _value.range
          : range // ignore: cast_nullable_to_non_nullable
              as int?,
      init: init == freezed
          ? _value.init
          : init // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc
abstract class _$InstanceAndOpsCtrlCopyWith<$Res>
    implements $InstanceAndOpsCtrlCopyWith<$Res> {
  factory _$InstanceAndOpsCtrlCopyWith(
          _InstanceAndOpsCtrl value, $Res Function(_InstanceAndOpsCtrl) then) =
      __$InstanceAndOpsCtrlCopyWithImpl<$Res>;
  @override
  $Res call(
      {AccessMode access,
      bool multi,
      bool mand,
      ValueType type,
      int? range,
      dynamic init});
}

/// @nodoc
class __$InstanceAndOpsCtrlCopyWithImpl<$Res>
    extends _$InstanceAndOpsCtrlCopyWithImpl<$Res>
    implements _$InstanceAndOpsCtrlCopyWith<$Res> {
  __$InstanceAndOpsCtrlCopyWithImpl(
      _InstanceAndOpsCtrl _value, $Res Function(_InstanceAndOpsCtrl) _then)
      : super(_value, (v) => _then(v as _InstanceAndOpsCtrl));

  @override
  _InstanceAndOpsCtrl get _value => super._value as _InstanceAndOpsCtrl;

  @override
  $Res call({
    Object? access = freezed,
    Object? multi = freezed,
    Object? mand = freezed,
    Object? type = freezed,
    Object? range = freezed,
    Object? init = freezed,
  }) {
    return _then(_InstanceAndOpsCtrl(
      access: access == freezed
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as AccessMode,
      multi: multi == freezed
          ? _value.multi
          : multi // ignore: cast_nullable_to_non_nullable
              as bool,
      mand: mand == freezed
          ? _value.mand
          : mand // ignore: cast_nullable_to_non_nullable
              as bool,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ValueType,
      range: range == freezed
          ? _value.range
          : range // ignore: cast_nullable_to_non_nullable
              as int?,
      init: init == freezed
          ? _value.init
          : init // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_InstanceAndOpsCtrl implements _InstanceAndOpsCtrl {
  const _$_InstanceAndOpsCtrl(
      {required this.access,
      required this.multi,
      required this.mand,
      required this.type,
      this.range,
      this.init});

  factory _$_InstanceAndOpsCtrl.fromJson(Map<String, dynamic> json) =>
      _$$_InstanceAndOpsCtrlFromJson(json);

  @override
  final AccessMode access;
  @override
  final bool multi;
  @override
  final bool mand;
  @override
  final ValueType type;
  @override
  final int? range;
  @override
  final dynamic init;

  @override
  String toString() {
    return 'InstanceAndOpsCtrl(access: $access, multi: $multi, mand: $mand, type: $type, range: $range, init: $init)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _InstanceAndOpsCtrl &&
            (identical(other.access, access) ||
                const DeepCollectionEquality().equals(other.access, access)) &&
            (identical(other.multi, multi) ||
                const DeepCollectionEquality().equals(other.multi, multi)) &&
            (identical(other.mand, mand) ||
                const DeepCollectionEquality().equals(other.mand, mand)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.range, range) ||
                const DeepCollectionEquality().equals(other.range, range)) &&
            (identical(other.init, init) ||
                const DeepCollectionEquality().equals(other.init, init)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(access) ^
      const DeepCollectionEquality().hash(multi) ^
      const DeepCollectionEquality().hash(mand) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(range) ^
      const DeepCollectionEquality().hash(init);

  @JsonKey(ignore: true)
  @override
  _$InstanceAndOpsCtrlCopyWith<_InstanceAndOpsCtrl> get copyWith =>
      __$InstanceAndOpsCtrlCopyWithImpl<_InstanceAndOpsCtrl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_InstanceAndOpsCtrlToJson(this);
  }
}

abstract class _InstanceAndOpsCtrl implements InstanceAndOpsCtrl {
  const factory _InstanceAndOpsCtrl(
      {required AccessMode access,
      required bool multi,
      required bool mand,
      required ValueType type,
      int? range,
      dynamic init}) = _$_InstanceAndOpsCtrl;

  factory _InstanceAndOpsCtrl.fromJson(Map<String, dynamic> json) =
      _$_InstanceAndOpsCtrl.fromJson;

  @override
  AccessMode get access => throw _privateConstructorUsedError;
  @override
  bool get multi => throw _privateConstructorUsedError;
  @override
  bool get mand => throw _privateConstructorUsedError;
  @override
  ValueType get type => throw _privateConstructorUsedError;
  @override
  int? get range => throw _privateConstructorUsedError;
  @override
  dynamic get init => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$InstanceAndOpsCtrlCopyWith<_InstanceAndOpsCtrl> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificResrcCharAOut _$SpecificResrcCharAOutFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharAOut.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharAOutTearOff {
  const _$SpecificResrcCharAOutTearOff();

  _SpecificResrcCharAOut call(
      {required InstanceAndOpsCtrl aOutCurrValue,
      required InstanceAndOpsCtrl minRangeValue,
      required InstanceAndOpsCtrl maxRangeValue,
      required InstanceAndOpsCtrl appType}) {
    return _SpecificResrcCharAOut(
      aOutCurrValue: aOutCurrValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      appType: appType,
    );
  }

  SpecificResrcCharAOut fromJson(Map<String, Object> json) {
    return SpecificResrcCharAOut.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharAOut = _$SpecificResrcCharAOutTearOff();

/// @nodoc
mixin _$SpecificResrcCharAOut {
  InstanceAndOpsCtrl get aOutCurrValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get minRangeValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get maxRangeValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharAOutCopyWith<SpecificResrcCharAOut> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharAOutCopyWith<$Res> {
  factory $SpecificResrcCharAOutCopyWith(SpecificResrcCharAOut value,
          $Res Function(SpecificResrcCharAOut) then) =
      _$SpecificResrcCharAOutCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl aOutCurrValue,
      InstanceAndOpsCtrl minRangeValue,
      InstanceAndOpsCtrl maxRangeValue,
      InstanceAndOpsCtrl appType});

  $InstanceAndOpsCtrlCopyWith<$Res> get aOutCurrValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get minRangeValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get maxRangeValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class _$SpecificResrcCharAOutCopyWithImpl<$Res>
    implements $SpecificResrcCharAOutCopyWith<$Res> {
  _$SpecificResrcCharAOutCopyWithImpl(this._value, this._then);

  final SpecificResrcCharAOut _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharAOut) _then;

  @override
  $Res call({
    Object? aOutCurrValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      aOutCurrValue: aOutCurrValue == freezed
          ? _value.aOutCurrValue
          : aOutCurrValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get aOutCurrValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.aOutCurrValue, (value) {
      return _then(_value.copyWith(aOutCurrValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get minRangeValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.minRangeValue, (value) {
      return _then(_value.copyWith(minRangeValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get maxRangeValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.maxRangeValue, (value) {
      return _then(_value.copyWith(maxRangeValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharAOutCopyWith<$Res>
    implements $SpecificResrcCharAOutCopyWith<$Res> {
  factory _$SpecificResrcCharAOutCopyWith(_SpecificResrcCharAOut value,
          $Res Function(_SpecificResrcCharAOut) then) =
      __$SpecificResrcCharAOutCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl aOutCurrValue,
      InstanceAndOpsCtrl minRangeValue,
      InstanceAndOpsCtrl maxRangeValue,
      InstanceAndOpsCtrl appType});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get aOutCurrValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get minRangeValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get maxRangeValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class __$SpecificResrcCharAOutCopyWithImpl<$Res>
    extends _$SpecificResrcCharAOutCopyWithImpl<$Res>
    implements _$SpecificResrcCharAOutCopyWith<$Res> {
  __$SpecificResrcCharAOutCopyWithImpl(_SpecificResrcCharAOut _value,
      $Res Function(_SpecificResrcCharAOut) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharAOut));

  @override
  _SpecificResrcCharAOut get _value => super._value as _SpecificResrcCharAOut;

  @override
  $Res call({
    Object? aOutCurrValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificResrcCharAOut(
      aOutCurrValue: aOutCurrValue == freezed
          ? _value.aOutCurrValue
          : aOutCurrValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharAOut implements _SpecificResrcCharAOut {
  const _$_SpecificResrcCharAOut(
      {required this.aOutCurrValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.appType});

  factory _$_SpecificResrcCharAOut.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharAOutFromJson(json);

  @override
  final InstanceAndOpsCtrl aOutCurrValue;
  @override
  final InstanceAndOpsCtrl minRangeValue;
  @override
  final InstanceAndOpsCtrl maxRangeValue;
  @override
  final InstanceAndOpsCtrl appType;

  @override
  String toString() {
    return 'SpecificResrcCharAOut(aOutCurrValue: $aOutCurrValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharAOut &&
            (identical(other.aOutCurrValue, aOutCurrValue) ||
                const DeepCollectionEquality()
                    .equals(other.aOutCurrValue, aOutCurrValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(aOutCurrValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharAOutCopyWith<_SpecificResrcCharAOut> get copyWith =>
      __$SpecificResrcCharAOutCopyWithImpl<_SpecificResrcCharAOut>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharAOutToJson(this);
  }
}

abstract class _SpecificResrcCharAOut implements SpecificResrcCharAOut {
  const factory _SpecificResrcCharAOut(
      {required InstanceAndOpsCtrl aOutCurrValue,
      required InstanceAndOpsCtrl minRangeValue,
      required InstanceAndOpsCtrl maxRangeValue,
      required InstanceAndOpsCtrl appType}) = _$_SpecificResrcCharAOut;

  factory _SpecificResrcCharAOut.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharAOut.fromJson;

  @override
  InstanceAndOpsCtrl get aOutCurrValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get minRangeValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get maxRangeValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharAOutCopyWith<_SpecificResrcCharAOut> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificResrcCharAccelerometer _$SpecificResrcCharAccelerometerFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharAccelerometer.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharAccelerometerTearOff {
  const _$SpecificResrcCharAccelerometerTearOff();

  _SpecificResrcCharAccelerometer call(
      {required InstanceAndOpsCtrl xValue,
      required InstanceAndOpsCtrl yValue,
      required InstanceAndOpsCtrl zValue,
      required InstanceAndOpsCtrl units,
      required InstanceAndOpsCtrl minRangeValue,
      required InstanceAndOpsCtrl maxRangeValue}) {
    return _SpecificResrcCharAccelerometer(
      xValue: xValue,
      yValue: yValue,
      zValue: zValue,
      units: units,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
    );
  }

  SpecificResrcCharAccelerometer fromJson(Map<String, Object> json) {
    return SpecificResrcCharAccelerometer.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharAccelerometer =
    _$SpecificResrcCharAccelerometerTearOff();

/// @nodoc
mixin _$SpecificResrcCharAccelerometer {
  InstanceAndOpsCtrl get xValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get yValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get zValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get units => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get minRangeValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get maxRangeValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharAccelerometerCopyWith<SpecificResrcCharAccelerometer>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharAccelerometerCopyWith<$Res> {
  factory $SpecificResrcCharAccelerometerCopyWith(
          SpecificResrcCharAccelerometer value,
          $Res Function(SpecificResrcCharAccelerometer) then) =
      _$SpecificResrcCharAccelerometerCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl xValue,
      InstanceAndOpsCtrl yValue,
      InstanceAndOpsCtrl zValue,
      InstanceAndOpsCtrl units,
      InstanceAndOpsCtrl minRangeValue,
      InstanceAndOpsCtrl maxRangeValue});

  $InstanceAndOpsCtrlCopyWith<$Res> get xValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get yValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get zValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get units;
  $InstanceAndOpsCtrlCopyWith<$Res> get minRangeValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get maxRangeValue;
}

/// @nodoc
class _$SpecificResrcCharAccelerometerCopyWithImpl<$Res>
    implements $SpecificResrcCharAccelerometerCopyWith<$Res> {
  _$SpecificResrcCharAccelerometerCopyWithImpl(this._value, this._then);

  final SpecificResrcCharAccelerometer _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharAccelerometer) _then;

  @override
  $Res call({
    Object? xValue = freezed,
    Object? yValue = freezed,
    Object? zValue = freezed,
    Object? units = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
  }) {
    return _then(_value.copyWith(
      xValue: xValue == freezed
          ? _value.xValue
          : xValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      yValue: yValue == freezed
          ? _value.yValue
          : yValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      zValue: zValue == freezed
          ? _value.zValue
          : zValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get xValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.xValue, (value) {
      return _then(_value.copyWith(xValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get yValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.yValue, (value) {
      return _then(_value.copyWith(yValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get zValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.zValue, (value) {
      return _then(_value.copyWith(zValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get units {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.units, (value) {
      return _then(_value.copyWith(units: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get minRangeValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.minRangeValue, (value) {
      return _then(_value.copyWith(minRangeValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get maxRangeValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.maxRangeValue, (value) {
      return _then(_value.copyWith(maxRangeValue: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharAccelerometerCopyWith<$Res>
    implements $SpecificResrcCharAccelerometerCopyWith<$Res> {
  factory _$SpecificResrcCharAccelerometerCopyWith(
          _SpecificResrcCharAccelerometer value,
          $Res Function(_SpecificResrcCharAccelerometer) then) =
      __$SpecificResrcCharAccelerometerCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl xValue,
      InstanceAndOpsCtrl yValue,
      InstanceAndOpsCtrl zValue,
      InstanceAndOpsCtrl units,
      InstanceAndOpsCtrl minRangeValue,
      InstanceAndOpsCtrl maxRangeValue});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get xValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get yValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get zValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get units;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get minRangeValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get maxRangeValue;
}

/// @nodoc
class __$SpecificResrcCharAccelerometerCopyWithImpl<$Res>
    extends _$SpecificResrcCharAccelerometerCopyWithImpl<$Res>
    implements _$SpecificResrcCharAccelerometerCopyWith<$Res> {
  __$SpecificResrcCharAccelerometerCopyWithImpl(
      _SpecificResrcCharAccelerometer _value,
      $Res Function(_SpecificResrcCharAccelerometer) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharAccelerometer));

  @override
  _SpecificResrcCharAccelerometer get _value =>
      super._value as _SpecificResrcCharAccelerometer;

  @override
  $Res call({
    Object? xValue = freezed,
    Object? yValue = freezed,
    Object? zValue = freezed,
    Object? units = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
  }) {
    return _then(_SpecificResrcCharAccelerometer(
      xValue: xValue == freezed
          ? _value.xValue
          : xValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      yValue: yValue == freezed
          ? _value.yValue
          : yValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      zValue: zValue == freezed
          ? _value.zValue
          : zValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharAccelerometer
    implements _SpecificResrcCharAccelerometer {
  const _$_SpecificResrcCharAccelerometer(
      {required this.xValue,
      required this.yValue,
      required this.zValue,
      required this.units,
      required this.minRangeValue,
      required this.maxRangeValue});

  factory _$_SpecificResrcCharAccelerometer.fromJson(
          Map<String, dynamic> json) =>
      _$$_SpecificResrcCharAccelerometerFromJson(json);

  @override
  final InstanceAndOpsCtrl xValue;
  @override
  final InstanceAndOpsCtrl yValue;
  @override
  final InstanceAndOpsCtrl zValue;
  @override
  final InstanceAndOpsCtrl units;
  @override
  final InstanceAndOpsCtrl minRangeValue;
  @override
  final InstanceAndOpsCtrl maxRangeValue;

  @override
  String toString() {
    return 'SpecificResrcCharAccelerometer(xValue: $xValue, yValue: $yValue, zValue: $zValue, units: $units, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharAccelerometer &&
            (identical(other.xValue, xValue) ||
                const DeepCollectionEquality().equals(other.xValue, xValue)) &&
            (identical(other.yValue, yValue) ||
                const DeepCollectionEquality().equals(other.yValue, yValue)) &&
            (identical(other.zValue, zValue) ||
                const DeepCollectionEquality().equals(other.zValue, zValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(xValue) ^
      const DeepCollectionEquality().hash(yValue) ^
      const DeepCollectionEquality().hash(zValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharAccelerometerCopyWith<_SpecificResrcCharAccelerometer>
      get copyWith => __$SpecificResrcCharAccelerometerCopyWithImpl<
          _SpecificResrcCharAccelerometer>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharAccelerometerToJson(this);
  }
}

abstract class _SpecificResrcCharAccelerometer
    implements SpecificResrcCharAccelerometer {
  const factory _SpecificResrcCharAccelerometer(
          {required InstanceAndOpsCtrl xValue,
          required InstanceAndOpsCtrl yValue,
          required InstanceAndOpsCtrl zValue,
          required InstanceAndOpsCtrl units,
          required InstanceAndOpsCtrl minRangeValue,
          required InstanceAndOpsCtrl maxRangeValue}) =
      _$_SpecificResrcCharAccelerometer;

  factory _SpecificResrcCharAccelerometer.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharAccelerometer.fromJson;

  @override
  InstanceAndOpsCtrl get xValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get yValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get zValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get units => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get minRangeValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get maxRangeValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharAccelerometerCopyWith<_SpecificResrcCharAccelerometer>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharAccessCtrl _$SpecificResrcCharAccessCtrlFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharAccessCtrl.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharAccessCtrlTearOff {
  const _$SpecificResrcCharAccessCtrlTearOff();

  _SpecificResrcCharAccessCtrl call(
      {required InstanceAndOpsCtrl objectId,
      required InstanceAndOpsCtrl objectInstanceId,
      @JsonKey(name: "ACL") required InstanceAndOpsCtrl acl,
      @JsonKey(name: "ACLOwner") required InstanceAndOpsCtrl aclOwner}) {
    return _SpecificResrcCharAccessCtrl(
      objectId: objectId,
      objectInstanceId: objectInstanceId,
      acl: acl,
      aclOwner: aclOwner,
    );
  }

  SpecificResrcCharAccessCtrl fromJson(Map<String, Object> json) {
    return SpecificResrcCharAccessCtrl.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharAccessCtrl = _$SpecificResrcCharAccessCtrlTearOff();

/// @nodoc
mixin _$SpecificResrcCharAccessCtrl {
  InstanceAndOpsCtrl get objectId => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get objectInstanceId => throw _privateConstructorUsedError;
  @JsonKey(name: "ACL")
  InstanceAndOpsCtrl get acl => throw _privateConstructorUsedError;
  @JsonKey(name: "ACLOwner")
  InstanceAndOpsCtrl get aclOwner => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharAccessCtrlCopyWith<SpecificResrcCharAccessCtrl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharAccessCtrlCopyWith<$Res> {
  factory $SpecificResrcCharAccessCtrlCopyWith(
          SpecificResrcCharAccessCtrl value,
          $Res Function(SpecificResrcCharAccessCtrl) then) =
      _$SpecificResrcCharAccessCtrlCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl objectId,
      InstanceAndOpsCtrl objectInstanceId,
      @JsonKey(name: "ACL") InstanceAndOpsCtrl acl,
      @JsonKey(name: "ACLOwner") InstanceAndOpsCtrl aclOwner});

  $InstanceAndOpsCtrlCopyWith<$Res> get objectId;
  $InstanceAndOpsCtrlCopyWith<$Res> get objectInstanceId;
  $InstanceAndOpsCtrlCopyWith<$Res> get acl;
  $InstanceAndOpsCtrlCopyWith<$Res> get aclOwner;
}

/// @nodoc
class _$SpecificResrcCharAccessCtrlCopyWithImpl<$Res>
    implements $SpecificResrcCharAccessCtrlCopyWith<$Res> {
  _$SpecificResrcCharAccessCtrlCopyWithImpl(this._value, this._then);

  final SpecificResrcCharAccessCtrl _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharAccessCtrl) _then;

  @override
  $Res call({
    Object? objectId = freezed,
    Object? objectInstanceId = freezed,
    Object? acl = freezed,
    Object? aclOwner = freezed,
  }) {
    return _then(_value.copyWith(
      objectId: objectId == freezed
          ? _value.objectId
          : objectId // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      objectInstanceId: objectInstanceId == freezed
          ? _value.objectInstanceId
          : objectInstanceId // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      acl: acl == freezed
          ? _value.acl
          : acl // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      aclOwner: aclOwner == freezed
          ? _value.aclOwner
          : aclOwner // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get objectId {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.objectId, (value) {
      return _then(_value.copyWith(objectId: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get objectInstanceId {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.objectInstanceId, (value) {
      return _then(_value.copyWith(objectInstanceId: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get acl {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.acl, (value) {
      return _then(_value.copyWith(acl: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get aclOwner {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.aclOwner, (value) {
      return _then(_value.copyWith(aclOwner: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharAccessCtrlCopyWith<$Res>
    implements $SpecificResrcCharAccessCtrlCopyWith<$Res> {
  factory _$SpecificResrcCharAccessCtrlCopyWith(
          _SpecificResrcCharAccessCtrl value,
          $Res Function(_SpecificResrcCharAccessCtrl) then) =
      __$SpecificResrcCharAccessCtrlCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl objectId,
      InstanceAndOpsCtrl objectInstanceId,
      @JsonKey(name: "ACL") InstanceAndOpsCtrl acl,
      @JsonKey(name: "ACLOwner") InstanceAndOpsCtrl aclOwner});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get objectId;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get objectInstanceId;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get acl;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get aclOwner;
}

/// @nodoc
class __$SpecificResrcCharAccessCtrlCopyWithImpl<$Res>
    extends _$SpecificResrcCharAccessCtrlCopyWithImpl<$Res>
    implements _$SpecificResrcCharAccessCtrlCopyWith<$Res> {
  __$SpecificResrcCharAccessCtrlCopyWithImpl(
      _SpecificResrcCharAccessCtrl _value,
      $Res Function(_SpecificResrcCharAccessCtrl) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharAccessCtrl));

  @override
  _SpecificResrcCharAccessCtrl get _value =>
      super._value as _SpecificResrcCharAccessCtrl;

  @override
  $Res call({
    Object? objectId = freezed,
    Object? objectInstanceId = freezed,
    Object? acl = freezed,
    Object? aclOwner = freezed,
  }) {
    return _then(_SpecificResrcCharAccessCtrl(
      objectId: objectId == freezed
          ? _value.objectId
          : objectId // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      objectInstanceId: objectInstanceId == freezed
          ? _value.objectInstanceId
          : objectInstanceId // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      acl: acl == freezed
          ? _value.acl
          : acl // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      aclOwner: aclOwner == freezed
          ? _value.aclOwner
          : aclOwner // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$_SpecificResrcCharAccessCtrl implements _SpecificResrcCharAccessCtrl {
  const _$_SpecificResrcCharAccessCtrl(
      {required this.objectId,
      required this.objectInstanceId,
      @JsonKey(name: "ACL") required this.acl,
      @JsonKey(name: "ACLOwner") required this.aclOwner});

  factory _$_SpecificResrcCharAccessCtrl.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharAccessCtrlFromJson(json);

  @override
  final InstanceAndOpsCtrl objectId;
  @override
  final InstanceAndOpsCtrl objectInstanceId;
  @override
  @JsonKey(name: "ACL")
  final InstanceAndOpsCtrl acl;
  @override
  @JsonKey(name: "ACLOwner")
  final InstanceAndOpsCtrl aclOwner;

  @override
  String toString() {
    return 'SpecificResrcCharAccessCtrl(objectId: $objectId, objectInstanceId: $objectInstanceId, acl: $acl, aclOwner: $aclOwner)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharAccessCtrl &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectInstanceId, objectInstanceId) ||
                const DeepCollectionEquality()
                    .equals(other.objectInstanceId, objectInstanceId)) &&
            (identical(other.acl, acl) ||
                const DeepCollectionEquality().equals(other.acl, acl)) &&
            (identical(other.aclOwner, aclOwner) ||
                const DeepCollectionEquality()
                    .equals(other.aclOwner, aclOwner)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectInstanceId) ^
      const DeepCollectionEquality().hash(acl) ^
      const DeepCollectionEquality().hash(aclOwner);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharAccessCtrlCopyWith<_SpecificResrcCharAccessCtrl>
      get copyWith => __$SpecificResrcCharAccessCtrlCopyWithImpl<
          _SpecificResrcCharAccessCtrl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharAccessCtrlToJson(this);
  }
}

abstract class _SpecificResrcCharAccessCtrl
    implements SpecificResrcCharAccessCtrl {
  const factory _SpecificResrcCharAccessCtrl(
          {required InstanceAndOpsCtrl objectId,
          required InstanceAndOpsCtrl objectInstanceId,
          @JsonKey(name: "ACL") required InstanceAndOpsCtrl acl,
          @JsonKey(name: "ACLOwner") required InstanceAndOpsCtrl aclOwner}) =
      _$_SpecificResrcCharAccessCtrl;

  factory _SpecificResrcCharAccessCtrl.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharAccessCtrl.fromJson;

  @override
  InstanceAndOpsCtrl get objectId => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get objectInstanceId => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "ACL")
  InstanceAndOpsCtrl get acl => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "ACLOwner")
  InstanceAndOpsCtrl get aclOwner => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharAccessCtrlCopyWith<_SpecificResrcCharAccessCtrl>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharActuation _$SpecificResrcCharActuationFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharActuation.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharActuationTearOff {
  const _$SpecificResrcCharActuationTearOff();

  _SpecificResrcCharActuation call(
      {required InstanceAndOpsCtrl onOff,
      required InstanceAndOpsCtrl dimmer,
      required InstanceAndOpsCtrl onTime,
      required InstanceAndOpsCtrl mStateOut,
      required InstanceAndOpsCtrl appType}) {
    return _SpecificResrcCharActuation(
      onOff: onOff,
      dimmer: dimmer,
      onTime: onTime,
      mStateOut: mStateOut,
      appType: appType,
    );
  }

  SpecificResrcCharActuation fromJson(Map<String, Object> json) {
    return SpecificResrcCharActuation.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharActuation = _$SpecificResrcCharActuationTearOff();

/// @nodoc
mixin _$SpecificResrcCharActuation {
  InstanceAndOpsCtrl get onOff => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get dimmer => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get onTime => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get mStateOut => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharActuationCopyWith<SpecificResrcCharActuation>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharActuationCopyWith<$Res> {
  factory $SpecificResrcCharActuationCopyWith(SpecificResrcCharActuation value,
          $Res Function(SpecificResrcCharActuation) then) =
      _$SpecificResrcCharActuationCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl onOff,
      InstanceAndOpsCtrl dimmer,
      InstanceAndOpsCtrl onTime,
      InstanceAndOpsCtrl mStateOut,
      InstanceAndOpsCtrl appType});

  $InstanceAndOpsCtrlCopyWith<$Res> get onOff;
  $InstanceAndOpsCtrlCopyWith<$Res> get dimmer;
  $InstanceAndOpsCtrlCopyWith<$Res> get onTime;
  $InstanceAndOpsCtrlCopyWith<$Res> get mStateOut;
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class _$SpecificResrcCharActuationCopyWithImpl<$Res>
    implements $SpecificResrcCharActuationCopyWith<$Res> {
  _$SpecificResrcCharActuationCopyWithImpl(this._value, this._then);

  final SpecificResrcCharActuation _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharActuation) _then;

  @override
  $Res call({
    Object? onOff = freezed,
    Object? dimmer = freezed,
    Object? onTime = freezed,
    Object? mStateOut = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      onOff: onOff == freezed
          ? _value.onOff
          : onOff // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      dimmer: dimmer == freezed
          ? _value.dimmer
          : dimmer // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      onTime: onTime == freezed
          ? _value.onTime
          : onTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      mStateOut: mStateOut == freezed
          ? _value.mStateOut
          : mStateOut // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get onOff {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.onOff, (value) {
      return _then(_value.copyWith(onOff: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dimmer {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.dimmer, (value) {
      return _then(_value.copyWith(dimmer: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get onTime {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.onTime, (value) {
      return _then(_value.copyWith(onTime: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get mStateOut {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.mStateOut, (value) {
      return _then(_value.copyWith(mStateOut: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharActuationCopyWith<$Res>
    implements $SpecificResrcCharActuationCopyWith<$Res> {
  factory _$SpecificResrcCharActuationCopyWith(
          _SpecificResrcCharActuation value,
          $Res Function(_SpecificResrcCharActuation) then) =
      __$SpecificResrcCharActuationCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl onOff,
      InstanceAndOpsCtrl dimmer,
      InstanceAndOpsCtrl onTime,
      InstanceAndOpsCtrl mStateOut,
      InstanceAndOpsCtrl appType});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get onOff;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dimmer;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get onTime;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get mStateOut;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class __$SpecificResrcCharActuationCopyWithImpl<$Res>
    extends _$SpecificResrcCharActuationCopyWithImpl<$Res>
    implements _$SpecificResrcCharActuationCopyWith<$Res> {
  __$SpecificResrcCharActuationCopyWithImpl(_SpecificResrcCharActuation _value,
      $Res Function(_SpecificResrcCharActuation) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharActuation));

  @override
  _SpecificResrcCharActuation get _value =>
      super._value as _SpecificResrcCharActuation;

  @override
  $Res call({
    Object? onOff = freezed,
    Object? dimmer = freezed,
    Object? onTime = freezed,
    Object? mStateOut = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificResrcCharActuation(
      onOff: onOff == freezed
          ? _value.onOff
          : onOff // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      dimmer: dimmer == freezed
          ? _value.dimmer
          : dimmer // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      onTime: onTime == freezed
          ? _value.onTime
          : onTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      mStateOut: mStateOut == freezed
          ? _value.mStateOut
          : mStateOut // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharActuation implements _SpecificResrcCharActuation {
  const _$_SpecificResrcCharActuation(
      {required this.onOff,
      required this.dimmer,
      required this.onTime,
      required this.mStateOut,
      required this.appType});

  factory _$_SpecificResrcCharActuation.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharActuationFromJson(json);

  @override
  final InstanceAndOpsCtrl onOff;
  @override
  final InstanceAndOpsCtrl dimmer;
  @override
  final InstanceAndOpsCtrl onTime;
  @override
  final InstanceAndOpsCtrl mStateOut;
  @override
  final InstanceAndOpsCtrl appType;

  @override
  String toString() {
    return 'SpecificResrcCharActuation(onOff: $onOff, dimmer: $dimmer, onTime: $onTime, mStateOut: $mStateOut, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharActuation &&
            (identical(other.onOff, onOff) ||
                const DeepCollectionEquality().equals(other.onOff, onOff)) &&
            (identical(other.dimmer, dimmer) ||
                const DeepCollectionEquality().equals(other.dimmer, dimmer)) &&
            (identical(other.onTime, onTime) ||
                const DeepCollectionEquality().equals(other.onTime, onTime)) &&
            (identical(other.mStateOut, mStateOut) ||
                const DeepCollectionEquality()
                    .equals(other.mStateOut, mStateOut)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(onOff) ^
      const DeepCollectionEquality().hash(dimmer) ^
      const DeepCollectionEquality().hash(onTime) ^
      const DeepCollectionEquality().hash(mStateOut) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharActuationCopyWith<_SpecificResrcCharActuation>
      get copyWith => __$SpecificResrcCharActuationCopyWithImpl<
          _SpecificResrcCharActuation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharActuationToJson(this);
  }
}

abstract class _SpecificResrcCharActuation
    implements SpecificResrcCharActuation {
  const factory _SpecificResrcCharActuation(
      {required InstanceAndOpsCtrl onOff,
      required InstanceAndOpsCtrl dimmer,
      required InstanceAndOpsCtrl onTime,
      required InstanceAndOpsCtrl mStateOut,
      required InstanceAndOpsCtrl appType}) = _$_SpecificResrcCharActuation;

  factory _SpecificResrcCharActuation.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharActuation.fromJson;

  @override
  InstanceAndOpsCtrl get onOff => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get dimmer => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get onTime => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get mStateOut => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharActuationCopyWith<_SpecificResrcCharActuation>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharAudioClip _$SpecificResrcCharAudioClipFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharAudioClip.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharAudioClipTearOff {
  const _$SpecificResrcCharAudioClipTearOff();

  _SpecificResrcCharAudioClip call(
      {required InstanceAndOpsCtrl clip,
      required InstanceAndOpsCtrl trigger,
      required InstanceAndOpsCtrl level,
      required InstanceAndOpsCtrl soundDuration,
      required InstanceAndOpsCtrl appType}) {
    return _SpecificResrcCharAudioClip(
      clip: clip,
      trigger: trigger,
      level: level,
      soundDuration: soundDuration,
      appType: appType,
    );
  }

  SpecificResrcCharAudioClip fromJson(Map<String, Object> json) {
    return SpecificResrcCharAudioClip.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharAudioClip = _$SpecificResrcCharAudioClipTearOff();

/// @nodoc
mixin _$SpecificResrcCharAudioClip {
  InstanceAndOpsCtrl get clip => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get trigger => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get level => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get soundDuration => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharAudioClipCopyWith<SpecificResrcCharAudioClip>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharAudioClipCopyWith<$Res> {
  factory $SpecificResrcCharAudioClipCopyWith(SpecificResrcCharAudioClip value,
          $Res Function(SpecificResrcCharAudioClip) then) =
      _$SpecificResrcCharAudioClipCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl clip,
      InstanceAndOpsCtrl trigger,
      InstanceAndOpsCtrl level,
      InstanceAndOpsCtrl soundDuration,
      InstanceAndOpsCtrl appType});

  $InstanceAndOpsCtrlCopyWith<$Res> get clip;
  $InstanceAndOpsCtrlCopyWith<$Res> get trigger;
  $InstanceAndOpsCtrlCopyWith<$Res> get level;
  $InstanceAndOpsCtrlCopyWith<$Res> get soundDuration;
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class _$SpecificResrcCharAudioClipCopyWithImpl<$Res>
    implements $SpecificResrcCharAudioClipCopyWith<$Res> {
  _$SpecificResrcCharAudioClipCopyWithImpl(this._value, this._then);

  final SpecificResrcCharAudioClip _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharAudioClip) _then;

  @override
  $Res call({
    Object? clip = freezed,
    Object? trigger = freezed,
    Object? level = freezed,
    Object? soundDuration = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      clip: clip == freezed
          ? _value.clip
          : clip // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      trigger: trigger == freezed
          ? _value.trigger
          : trigger // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      level: level == freezed
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      soundDuration: soundDuration == freezed
          ? _value.soundDuration
          : soundDuration // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get clip {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.clip, (value) {
      return _then(_value.copyWith(clip: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get trigger {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.trigger, (value) {
      return _then(_value.copyWith(trigger: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get level {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.level, (value) {
      return _then(_value.copyWith(level: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get soundDuration {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.soundDuration, (value) {
      return _then(_value.copyWith(soundDuration: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharAudioClipCopyWith<$Res>
    implements $SpecificResrcCharAudioClipCopyWith<$Res> {
  factory _$SpecificResrcCharAudioClipCopyWith(
          _SpecificResrcCharAudioClip value,
          $Res Function(_SpecificResrcCharAudioClip) then) =
      __$SpecificResrcCharAudioClipCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl clip,
      InstanceAndOpsCtrl trigger,
      InstanceAndOpsCtrl level,
      InstanceAndOpsCtrl soundDuration,
      InstanceAndOpsCtrl appType});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get clip;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get trigger;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get level;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get soundDuration;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class __$SpecificResrcCharAudioClipCopyWithImpl<$Res>
    extends _$SpecificResrcCharAudioClipCopyWithImpl<$Res>
    implements _$SpecificResrcCharAudioClipCopyWith<$Res> {
  __$SpecificResrcCharAudioClipCopyWithImpl(_SpecificResrcCharAudioClip _value,
      $Res Function(_SpecificResrcCharAudioClip) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharAudioClip));

  @override
  _SpecificResrcCharAudioClip get _value =>
      super._value as _SpecificResrcCharAudioClip;

  @override
  $Res call({
    Object? clip = freezed,
    Object? trigger = freezed,
    Object? level = freezed,
    Object? soundDuration = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificResrcCharAudioClip(
      clip: clip == freezed
          ? _value.clip
          : clip // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      trigger: trigger == freezed
          ? _value.trigger
          : trigger // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      level: level == freezed
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      soundDuration: soundDuration == freezed
          ? _value.soundDuration
          : soundDuration // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharAudioClip implements _SpecificResrcCharAudioClip {
  const _$_SpecificResrcCharAudioClip(
      {required this.clip,
      required this.trigger,
      required this.level,
      required this.soundDuration,
      required this.appType});

  factory _$_SpecificResrcCharAudioClip.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharAudioClipFromJson(json);

  @override
  final InstanceAndOpsCtrl clip;
  @override
  final InstanceAndOpsCtrl trigger;
  @override
  final InstanceAndOpsCtrl level;
  @override
  final InstanceAndOpsCtrl soundDuration;
  @override
  final InstanceAndOpsCtrl appType;

  @override
  String toString() {
    return 'SpecificResrcCharAudioClip(clip: $clip, trigger: $trigger, level: $level, soundDuration: $soundDuration, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharAudioClip &&
            (identical(other.clip, clip) ||
                const DeepCollectionEquality().equals(other.clip, clip)) &&
            (identical(other.trigger, trigger) ||
                const DeepCollectionEquality()
                    .equals(other.trigger, trigger)) &&
            (identical(other.level, level) ||
                const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.soundDuration, soundDuration) ||
                const DeepCollectionEquality()
                    .equals(other.soundDuration, soundDuration)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(clip) ^
      const DeepCollectionEquality().hash(trigger) ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(soundDuration) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharAudioClipCopyWith<_SpecificResrcCharAudioClip>
      get copyWith => __$SpecificResrcCharAudioClipCopyWithImpl<
          _SpecificResrcCharAudioClip>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharAudioClipToJson(this);
  }
}

abstract class _SpecificResrcCharAudioClip
    implements SpecificResrcCharAudioClip {
  const factory _SpecificResrcCharAudioClip(
      {required InstanceAndOpsCtrl clip,
      required InstanceAndOpsCtrl trigger,
      required InstanceAndOpsCtrl level,
      required InstanceAndOpsCtrl soundDuration,
      required InstanceAndOpsCtrl appType}) = _$_SpecificResrcCharAudioClip;

  factory _SpecificResrcCharAudioClip.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharAudioClip.fromJson;

  @override
  InstanceAndOpsCtrl get clip => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get trigger => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get level => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get soundDuration => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharAudioClipCopyWith<_SpecificResrcCharAudioClip>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharBuzzer _$SpecificResrcCharBuzzerFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharBuzzer.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharBuzzerTearOff {
  const _$SpecificResrcCharBuzzerTearOff();

  _SpecificResrcCharBuzzer call(
      {required InstanceAndOpsCtrl onOff,
      required InstanceAndOpsCtrl level,
      required InstanceAndOpsCtrl timeDuration,
      required InstanceAndOpsCtrl minOffTime,
      required InstanceAndOpsCtrl appType}) {
    return _SpecificResrcCharBuzzer(
      onOff: onOff,
      level: level,
      timeDuration: timeDuration,
      minOffTime: minOffTime,
      appType: appType,
    );
  }

  SpecificResrcCharBuzzer fromJson(Map<String, Object> json) {
    return SpecificResrcCharBuzzer.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharBuzzer = _$SpecificResrcCharBuzzerTearOff();

/// @nodoc
mixin _$SpecificResrcCharBuzzer {
  InstanceAndOpsCtrl get onOff => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get level => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get timeDuration => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get minOffTime => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharBuzzerCopyWith<SpecificResrcCharBuzzer> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharBuzzerCopyWith<$Res> {
  factory $SpecificResrcCharBuzzerCopyWith(SpecificResrcCharBuzzer value,
          $Res Function(SpecificResrcCharBuzzer) then) =
      _$SpecificResrcCharBuzzerCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl onOff,
      InstanceAndOpsCtrl level,
      InstanceAndOpsCtrl timeDuration,
      InstanceAndOpsCtrl minOffTime,
      InstanceAndOpsCtrl appType});

  $InstanceAndOpsCtrlCopyWith<$Res> get onOff;
  $InstanceAndOpsCtrlCopyWith<$Res> get level;
  $InstanceAndOpsCtrlCopyWith<$Res> get timeDuration;
  $InstanceAndOpsCtrlCopyWith<$Res> get minOffTime;
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class _$SpecificResrcCharBuzzerCopyWithImpl<$Res>
    implements $SpecificResrcCharBuzzerCopyWith<$Res> {
  _$SpecificResrcCharBuzzerCopyWithImpl(this._value, this._then);

  final SpecificResrcCharBuzzer _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharBuzzer) _then;

  @override
  $Res call({
    Object? onOff = freezed,
    Object? level = freezed,
    Object? timeDuration = freezed,
    Object? minOffTime = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      onOff: onOff == freezed
          ? _value.onOff
          : onOff // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      level: level == freezed
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      timeDuration: timeDuration == freezed
          ? _value.timeDuration
          : timeDuration // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      minOffTime: minOffTime == freezed
          ? _value.minOffTime
          : minOffTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get onOff {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.onOff, (value) {
      return _then(_value.copyWith(onOff: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get level {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.level, (value) {
      return _then(_value.copyWith(level: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get timeDuration {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.timeDuration, (value) {
      return _then(_value.copyWith(timeDuration: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get minOffTime {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.minOffTime, (value) {
      return _then(_value.copyWith(minOffTime: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharBuzzerCopyWith<$Res>
    implements $SpecificResrcCharBuzzerCopyWith<$Res> {
  factory _$SpecificResrcCharBuzzerCopyWith(_SpecificResrcCharBuzzer value,
          $Res Function(_SpecificResrcCharBuzzer) then) =
      __$SpecificResrcCharBuzzerCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl onOff,
      InstanceAndOpsCtrl level,
      InstanceAndOpsCtrl timeDuration,
      InstanceAndOpsCtrl minOffTime,
      InstanceAndOpsCtrl appType});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get onOff;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get level;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get timeDuration;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get minOffTime;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class __$SpecificResrcCharBuzzerCopyWithImpl<$Res>
    extends _$SpecificResrcCharBuzzerCopyWithImpl<$Res>
    implements _$SpecificResrcCharBuzzerCopyWith<$Res> {
  __$SpecificResrcCharBuzzerCopyWithImpl(_SpecificResrcCharBuzzer _value,
      $Res Function(_SpecificResrcCharBuzzer) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharBuzzer));

  @override
  _SpecificResrcCharBuzzer get _value =>
      super._value as _SpecificResrcCharBuzzer;

  @override
  $Res call({
    Object? onOff = freezed,
    Object? level = freezed,
    Object? timeDuration = freezed,
    Object? minOffTime = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificResrcCharBuzzer(
      onOff: onOff == freezed
          ? _value.onOff
          : onOff // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      level: level == freezed
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      timeDuration: timeDuration == freezed
          ? _value.timeDuration
          : timeDuration // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      minOffTime: minOffTime == freezed
          ? _value.minOffTime
          : minOffTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharBuzzer implements _SpecificResrcCharBuzzer {
  const _$_SpecificResrcCharBuzzer(
      {required this.onOff,
      required this.level,
      required this.timeDuration,
      required this.minOffTime,
      required this.appType});

  factory _$_SpecificResrcCharBuzzer.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharBuzzerFromJson(json);

  @override
  final InstanceAndOpsCtrl onOff;
  @override
  final InstanceAndOpsCtrl level;
  @override
  final InstanceAndOpsCtrl timeDuration;
  @override
  final InstanceAndOpsCtrl minOffTime;
  @override
  final InstanceAndOpsCtrl appType;

  @override
  String toString() {
    return 'SpecificResrcCharBuzzer(onOff: $onOff, level: $level, timeDuration: $timeDuration, minOffTime: $minOffTime, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharBuzzer &&
            (identical(other.onOff, onOff) ||
                const DeepCollectionEquality().equals(other.onOff, onOff)) &&
            (identical(other.level, level) ||
                const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.timeDuration, timeDuration) ||
                const DeepCollectionEquality()
                    .equals(other.timeDuration, timeDuration)) &&
            (identical(other.minOffTime, minOffTime) ||
                const DeepCollectionEquality()
                    .equals(other.minOffTime, minOffTime)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(onOff) ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(timeDuration) ^
      const DeepCollectionEquality().hash(minOffTime) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharBuzzerCopyWith<_SpecificResrcCharBuzzer> get copyWith =>
      __$SpecificResrcCharBuzzerCopyWithImpl<_SpecificResrcCharBuzzer>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharBuzzerToJson(this);
  }
}

abstract class _SpecificResrcCharBuzzer implements SpecificResrcCharBuzzer {
  const factory _SpecificResrcCharBuzzer(
      {required InstanceAndOpsCtrl onOff,
      required InstanceAndOpsCtrl level,
      required InstanceAndOpsCtrl timeDuration,
      required InstanceAndOpsCtrl minOffTime,
      required InstanceAndOpsCtrl appType}) = _$_SpecificResrcCharBuzzer;

  factory _SpecificResrcCharBuzzer.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharBuzzer.fromJson;

  @override
  InstanceAndOpsCtrl get onOff => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get level => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get timeDuration => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get minOffTime => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharBuzzerCopyWith<_SpecificResrcCharBuzzer> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificResrcCharColour _$SpecificResrcCharColourFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharColour.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharColourTearOff {
  const _$SpecificResrcCharColourTearOff();

  _SpecificResrcCharColour call(
      {required InstanceAndOpsCtrl colour,
      required InstanceAndOpsCtrl units,
      required InstanceAndOpsCtrl appType}) {
    return _SpecificResrcCharColour(
      colour: colour,
      units: units,
      appType: appType,
    );
  }

  SpecificResrcCharColour fromJson(Map<String, Object> json) {
    return SpecificResrcCharColour.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharColour = _$SpecificResrcCharColourTearOff();

/// @nodoc
mixin _$SpecificResrcCharColour {
  InstanceAndOpsCtrl get colour => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get units => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharColourCopyWith<SpecificResrcCharColour> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharColourCopyWith<$Res> {
  factory $SpecificResrcCharColourCopyWith(SpecificResrcCharColour value,
          $Res Function(SpecificResrcCharColour) then) =
      _$SpecificResrcCharColourCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl colour,
      InstanceAndOpsCtrl units,
      InstanceAndOpsCtrl appType});

  $InstanceAndOpsCtrlCopyWith<$Res> get colour;
  $InstanceAndOpsCtrlCopyWith<$Res> get units;
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class _$SpecificResrcCharColourCopyWithImpl<$Res>
    implements $SpecificResrcCharColourCopyWith<$Res> {
  _$SpecificResrcCharColourCopyWithImpl(this._value, this._then);

  final SpecificResrcCharColour _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharColour) _then;

  @override
  $Res call({
    Object? colour = freezed,
    Object? units = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      colour: colour == freezed
          ? _value.colour
          : colour // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get colour {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.colour, (value) {
      return _then(_value.copyWith(colour: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get units {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.units, (value) {
      return _then(_value.copyWith(units: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharColourCopyWith<$Res>
    implements $SpecificResrcCharColourCopyWith<$Res> {
  factory _$SpecificResrcCharColourCopyWith(_SpecificResrcCharColour value,
          $Res Function(_SpecificResrcCharColour) then) =
      __$SpecificResrcCharColourCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl colour,
      InstanceAndOpsCtrl units,
      InstanceAndOpsCtrl appType});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get colour;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get units;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class __$SpecificResrcCharColourCopyWithImpl<$Res>
    extends _$SpecificResrcCharColourCopyWithImpl<$Res>
    implements _$SpecificResrcCharColourCopyWith<$Res> {
  __$SpecificResrcCharColourCopyWithImpl(_SpecificResrcCharColour _value,
      $Res Function(_SpecificResrcCharColour) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharColour));

  @override
  _SpecificResrcCharColour get _value =>
      super._value as _SpecificResrcCharColour;

  @override
  $Res call({
    Object? colour = freezed,
    Object? units = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificResrcCharColour(
      colour: colour == freezed
          ? _value.colour
          : colour // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharColour implements _SpecificResrcCharColour {
  const _$_SpecificResrcCharColour(
      {required this.colour, required this.units, required this.appType});

  factory _$_SpecificResrcCharColour.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharColourFromJson(json);

  @override
  final InstanceAndOpsCtrl colour;
  @override
  final InstanceAndOpsCtrl units;
  @override
  final InstanceAndOpsCtrl appType;

  @override
  String toString() {
    return 'SpecificResrcCharColour(colour: $colour, units: $units, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharColour &&
            (identical(other.colour, colour) ||
                const DeepCollectionEquality().equals(other.colour, colour)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(colour) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharColourCopyWith<_SpecificResrcCharColour> get copyWith =>
      __$SpecificResrcCharColourCopyWithImpl<_SpecificResrcCharColour>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharColourToJson(this);
  }
}

abstract class _SpecificResrcCharColour implements SpecificResrcCharColour {
  const factory _SpecificResrcCharColour(
      {required InstanceAndOpsCtrl colour,
      required InstanceAndOpsCtrl units,
      required InstanceAndOpsCtrl appType}) = _$_SpecificResrcCharColour;

  factory _SpecificResrcCharColour.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharColour.fromJson;

  @override
  InstanceAndOpsCtrl get colour => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get units => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharColourCopyWith<_SpecificResrcCharColour> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificResrcCharConnStatistics _$SpecificResrcCharConnStatisticsFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharConnStatistics.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharConnStatisticsTearOff {
  const _$SpecificResrcCharConnStatisticsTearOff();

  _SpecificResrcCharConnStatistics call(
      {@JsonKey(name: "SMSTxCounter") required InstanceAndOpsCtrl smsTxCounter,
      @JsonKey(name: "SMSRxCounter") required InstanceAndOpsCtrl smsRxCounter,
      required InstanceAndOpsCtrl txData,
      required InstanceAndOpsCtrl rxData,
      required InstanceAndOpsCtrl maxMsgSize,
      required InstanceAndOpsCtrl avgMsgSize,
      required InstanceAndOpsCtrl startOrReset}) {
    return _SpecificResrcCharConnStatistics(
      smsTxCounter: smsTxCounter,
      smsRxCounter: smsRxCounter,
      txData: txData,
      rxData: rxData,
      maxMsgSize: maxMsgSize,
      avgMsgSize: avgMsgSize,
      startOrReset: startOrReset,
    );
  }

  SpecificResrcCharConnStatistics fromJson(Map<String, Object> json) {
    return SpecificResrcCharConnStatistics.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharConnStatistics =
    _$SpecificResrcCharConnStatisticsTearOff();

/// @nodoc
mixin _$SpecificResrcCharConnStatistics {
  @JsonKey(name: "SMSTxCounter")
  InstanceAndOpsCtrl get smsTxCounter => throw _privateConstructorUsedError;
  @JsonKey(name: "SMSRxCounter")
  InstanceAndOpsCtrl get smsRxCounter => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get txData => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get rxData => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get maxMsgSize => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get avgMsgSize => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get startOrReset => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharConnStatisticsCopyWith<SpecificResrcCharConnStatistics>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharConnStatisticsCopyWith<$Res> {
  factory $SpecificResrcCharConnStatisticsCopyWith(
          SpecificResrcCharConnStatistics value,
          $Res Function(SpecificResrcCharConnStatistics) then) =
      _$SpecificResrcCharConnStatisticsCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(name: "SMSTxCounter") InstanceAndOpsCtrl smsTxCounter,
      @JsonKey(name: "SMSRxCounter") InstanceAndOpsCtrl smsRxCounter,
      InstanceAndOpsCtrl txData,
      InstanceAndOpsCtrl rxData,
      InstanceAndOpsCtrl maxMsgSize,
      InstanceAndOpsCtrl avgMsgSize,
      InstanceAndOpsCtrl startOrReset});

  $InstanceAndOpsCtrlCopyWith<$Res> get smsTxCounter;
  $InstanceAndOpsCtrlCopyWith<$Res> get smsRxCounter;
  $InstanceAndOpsCtrlCopyWith<$Res> get txData;
  $InstanceAndOpsCtrlCopyWith<$Res> get rxData;
  $InstanceAndOpsCtrlCopyWith<$Res> get maxMsgSize;
  $InstanceAndOpsCtrlCopyWith<$Res> get avgMsgSize;
  $InstanceAndOpsCtrlCopyWith<$Res> get startOrReset;
}

/// @nodoc
class _$SpecificResrcCharConnStatisticsCopyWithImpl<$Res>
    implements $SpecificResrcCharConnStatisticsCopyWith<$Res> {
  _$SpecificResrcCharConnStatisticsCopyWithImpl(this._value, this._then);

  final SpecificResrcCharConnStatistics _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharConnStatistics) _then;

  @override
  $Res call({
    Object? smsTxCounter = freezed,
    Object? smsRxCounter = freezed,
    Object? txData = freezed,
    Object? rxData = freezed,
    Object? maxMsgSize = freezed,
    Object? avgMsgSize = freezed,
    Object? startOrReset = freezed,
  }) {
    return _then(_value.copyWith(
      smsTxCounter: smsTxCounter == freezed
          ? _value.smsTxCounter
          : smsTxCounter // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      smsRxCounter: smsRxCounter == freezed
          ? _value.smsRxCounter
          : smsRxCounter // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      txData: txData == freezed
          ? _value.txData
          : txData // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      rxData: rxData == freezed
          ? _value.rxData
          : rxData // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      maxMsgSize: maxMsgSize == freezed
          ? _value.maxMsgSize
          : maxMsgSize // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      avgMsgSize: avgMsgSize == freezed
          ? _value.avgMsgSize
          : avgMsgSize // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      startOrReset: startOrReset == freezed
          ? _value.startOrReset
          : startOrReset // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get smsTxCounter {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.smsTxCounter, (value) {
      return _then(_value.copyWith(smsTxCounter: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get smsRxCounter {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.smsRxCounter, (value) {
      return _then(_value.copyWith(smsRxCounter: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get txData {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.txData, (value) {
      return _then(_value.copyWith(txData: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get rxData {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.rxData, (value) {
      return _then(_value.copyWith(rxData: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get maxMsgSize {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.maxMsgSize, (value) {
      return _then(_value.copyWith(maxMsgSize: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get avgMsgSize {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.avgMsgSize, (value) {
      return _then(_value.copyWith(avgMsgSize: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get startOrReset {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.startOrReset, (value) {
      return _then(_value.copyWith(startOrReset: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharConnStatisticsCopyWith<$Res>
    implements $SpecificResrcCharConnStatisticsCopyWith<$Res> {
  factory _$SpecificResrcCharConnStatisticsCopyWith(
          _SpecificResrcCharConnStatistics value,
          $Res Function(_SpecificResrcCharConnStatistics) then) =
      __$SpecificResrcCharConnStatisticsCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(name: "SMSTxCounter") InstanceAndOpsCtrl smsTxCounter,
      @JsonKey(name: "SMSRxCounter") InstanceAndOpsCtrl smsRxCounter,
      InstanceAndOpsCtrl txData,
      InstanceAndOpsCtrl rxData,
      InstanceAndOpsCtrl maxMsgSize,
      InstanceAndOpsCtrl avgMsgSize,
      InstanceAndOpsCtrl startOrReset});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get smsTxCounter;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get smsRxCounter;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get txData;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get rxData;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get maxMsgSize;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get avgMsgSize;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get startOrReset;
}

/// @nodoc
class __$SpecificResrcCharConnStatisticsCopyWithImpl<$Res>
    extends _$SpecificResrcCharConnStatisticsCopyWithImpl<$Res>
    implements _$SpecificResrcCharConnStatisticsCopyWith<$Res> {
  __$SpecificResrcCharConnStatisticsCopyWithImpl(
      _SpecificResrcCharConnStatistics _value,
      $Res Function(_SpecificResrcCharConnStatistics) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharConnStatistics));

  @override
  _SpecificResrcCharConnStatistics get _value =>
      super._value as _SpecificResrcCharConnStatistics;

  @override
  $Res call({
    Object? smsTxCounter = freezed,
    Object? smsRxCounter = freezed,
    Object? txData = freezed,
    Object? rxData = freezed,
    Object? maxMsgSize = freezed,
    Object? avgMsgSize = freezed,
    Object? startOrReset = freezed,
  }) {
    return _then(_SpecificResrcCharConnStatistics(
      smsTxCounter: smsTxCounter == freezed
          ? _value.smsTxCounter
          : smsTxCounter // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      smsRxCounter: smsRxCounter == freezed
          ? _value.smsRxCounter
          : smsRxCounter // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      txData: txData == freezed
          ? _value.txData
          : txData // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      rxData: rxData == freezed
          ? _value.rxData
          : rxData // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      maxMsgSize: maxMsgSize == freezed
          ? _value.maxMsgSize
          : maxMsgSize // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      avgMsgSize: avgMsgSize == freezed
          ? _value.avgMsgSize
          : avgMsgSize // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      startOrReset: startOrReset == freezed
          ? _value.startOrReset
          : startOrReset // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharConnStatistics
    implements _SpecificResrcCharConnStatistics {
  const _$_SpecificResrcCharConnStatistics(
      {@JsonKey(name: "SMSTxCounter") required this.smsTxCounter,
      @JsonKey(name: "SMSRxCounter") required this.smsRxCounter,
      required this.txData,
      required this.rxData,
      required this.maxMsgSize,
      required this.avgMsgSize,
      required this.startOrReset});

  factory _$_SpecificResrcCharConnStatistics.fromJson(
          Map<String, dynamic> json) =>
      _$$_SpecificResrcCharConnStatisticsFromJson(json);

  @override
  @JsonKey(name: "SMSTxCounter")
  final InstanceAndOpsCtrl smsTxCounter;
  @override
  @JsonKey(name: "SMSRxCounter")
  final InstanceAndOpsCtrl smsRxCounter;
  @override
  final InstanceAndOpsCtrl txData;
  @override
  final InstanceAndOpsCtrl rxData;
  @override
  final InstanceAndOpsCtrl maxMsgSize;
  @override
  final InstanceAndOpsCtrl avgMsgSize;
  @override
  final InstanceAndOpsCtrl startOrReset;

  @override
  String toString() {
    return 'SpecificResrcCharConnStatistics(smsTxCounter: $smsTxCounter, smsRxCounter: $smsRxCounter, txData: $txData, rxData: $rxData, maxMsgSize: $maxMsgSize, avgMsgSize: $avgMsgSize, startOrReset: $startOrReset)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharConnStatistics &&
            (identical(other.smsTxCounter, smsTxCounter) ||
                const DeepCollectionEquality()
                    .equals(other.smsTxCounter, smsTxCounter)) &&
            (identical(other.smsRxCounter, smsRxCounter) ||
                const DeepCollectionEquality()
                    .equals(other.smsRxCounter, smsRxCounter)) &&
            (identical(other.txData, txData) ||
                const DeepCollectionEquality().equals(other.txData, txData)) &&
            (identical(other.rxData, rxData) ||
                const DeepCollectionEquality().equals(other.rxData, rxData)) &&
            (identical(other.maxMsgSize, maxMsgSize) ||
                const DeepCollectionEquality()
                    .equals(other.maxMsgSize, maxMsgSize)) &&
            (identical(other.avgMsgSize, avgMsgSize) ||
                const DeepCollectionEquality()
                    .equals(other.avgMsgSize, avgMsgSize)) &&
            (identical(other.startOrReset, startOrReset) ||
                const DeepCollectionEquality()
                    .equals(other.startOrReset, startOrReset)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(smsTxCounter) ^
      const DeepCollectionEquality().hash(smsRxCounter) ^
      const DeepCollectionEquality().hash(txData) ^
      const DeepCollectionEquality().hash(rxData) ^
      const DeepCollectionEquality().hash(maxMsgSize) ^
      const DeepCollectionEquality().hash(avgMsgSize) ^
      const DeepCollectionEquality().hash(startOrReset);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharConnStatisticsCopyWith<_SpecificResrcCharConnStatistics>
      get copyWith => __$SpecificResrcCharConnStatisticsCopyWithImpl<
          _SpecificResrcCharConnStatistics>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharConnStatisticsToJson(this);
  }
}

abstract class _SpecificResrcCharConnStatistics
    implements SpecificResrcCharConnStatistics {
  const factory _SpecificResrcCharConnStatistics(
      {@JsonKey(name: "SMSTxCounter") required InstanceAndOpsCtrl smsTxCounter,
      @JsonKey(name: "SMSRxCounter") required InstanceAndOpsCtrl smsRxCounter,
      required InstanceAndOpsCtrl txData,
      required InstanceAndOpsCtrl rxData,
      required InstanceAndOpsCtrl maxMsgSize,
      required InstanceAndOpsCtrl avgMsgSize,
      required InstanceAndOpsCtrl
          startOrReset}) = _$_SpecificResrcCharConnStatistics;

  factory _SpecificResrcCharConnStatistics.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharConnStatistics.fromJson;

  @override
  @JsonKey(name: "SMSTxCounter")
  InstanceAndOpsCtrl get smsTxCounter => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "SMSRxCounter")
  InstanceAndOpsCtrl get smsRxCounter => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get txData => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get rxData => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get maxMsgSize => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get avgMsgSize => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get startOrReset => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharConnStatisticsCopyWith<_SpecificResrcCharConnStatistics>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharDIn _$SpecificResrcCharDInFromJson(Map<String, dynamic> json) {
  return _SpecificResrcCharDIn.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharDInTearOff {
  const _$SpecificResrcCharDInTearOff();

  _SpecificResrcCharDIn call(
      {required InstanceAndOpsCtrl dInState,
      required InstanceAndOpsCtrl counter,
      required InstanceAndOpsCtrl dInPolarity,
      required InstanceAndOpsCtrl debouncePeriod,
      required InstanceAndOpsCtrl edgeSelection,
      required InstanceAndOpsCtrl counterReset,
      required InstanceAndOpsCtrl appType,
      required InstanceAndOpsCtrl sensorType}) {
    return _SpecificResrcCharDIn(
      dInState: dInState,
      counter: counter,
      dInPolarity: dInPolarity,
      debouncePeriod: debouncePeriod,
      edgeSelection: edgeSelection,
      counterReset: counterReset,
      appType: appType,
      sensorType: sensorType,
    );
  }

  SpecificResrcCharDIn fromJson(Map<String, Object> json) {
    return SpecificResrcCharDIn.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharDIn = _$SpecificResrcCharDInTearOff();

/// @nodoc
mixin _$SpecificResrcCharDIn {
  InstanceAndOpsCtrl get dInState => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get counter => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get dInPolarity => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get debouncePeriod => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get edgeSelection => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get counterReset => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get sensorType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharDInCopyWith<SpecificResrcCharDIn> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharDInCopyWith<$Res> {
  factory $SpecificResrcCharDInCopyWith(SpecificResrcCharDIn value,
          $Res Function(SpecificResrcCharDIn) then) =
      _$SpecificResrcCharDInCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl dInState,
      InstanceAndOpsCtrl counter,
      InstanceAndOpsCtrl dInPolarity,
      InstanceAndOpsCtrl debouncePeriod,
      InstanceAndOpsCtrl edgeSelection,
      InstanceAndOpsCtrl counterReset,
      InstanceAndOpsCtrl appType,
      InstanceAndOpsCtrl sensorType});

  $InstanceAndOpsCtrlCopyWith<$Res> get dInState;
  $InstanceAndOpsCtrlCopyWith<$Res> get counter;
  $InstanceAndOpsCtrlCopyWith<$Res> get dInPolarity;
  $InstanceAndOpsCtrlCopyWith<$Res> get debouncePeriod;
  $InstanceAndOpsCtrlCopyWith<$Res> get edgeSelection;
  $InstanceAndOpsCtrlCopyWith<$Res> get counterReset;
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
  $InstanceAndOpsCtrlCopyWith<$Res> get sensorType;
}

/// @nodoc
class _$SpecificResrcCharDInCopyWithImpl<$Res>
    implements $SpecificResrcCharDInCopyWith<$Res> {
  _$SpecificResrcCharDInCopyWithImpl(this._value, this._then);

  final SpecificResrcCharDIn _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharDIn) _then;

  @override
  $Res call({
    Object? dInState = freezed,
    Object? counter = freezed,
    Object? dInPolarity = freezed,
    Object? debouncePeriod = freezed,
    Object? edgeSelection = freezed,
    Object? counterReset = freezed,
    Object? appType = freezed,
    Object? sensorType = freezed,
  }) {
    return _then(_value.copyWith(
      dInState: dInState == freezed
          ? _value.dInState
          : dInState // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      dInPolarity: dInPolarity == freezed
          ? _value.dInPolarity
          : dInPolarity // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      debouncePeriod: debouncePeriod == freezed
          ? _value.debouncePeriod
          : debouncePeriod // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      edgeSelection: edgeSelection == freezed
          ? _value.edgeSelection
          : edgeSelection // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      counterReset: counterReset == freezed
          ? _value.counterReset
          : counterReset // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      sensorType: sensorType == freezed
          ? _value.sensorType
          : sensorType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dInState {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.dInState, (value) {
      return _then(_value.copyWith(dInState: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get counter {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.counter, (value) {
      return _then(_value.copyWith(counter: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dInPolarity {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.dInPolarity, (value) {
      return _then(_value.copyWith(dInPolarity: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get debouncePeriod {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.debouncePeriod, (value) {
      return _then(_value.copyWith(debouncePeriod: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get edgeSelection {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.edgeSelection, (value) {
      return _then(_value.copyWith(edgeSelection: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get counterReset {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.counterReset, (value) {
      return _then(_value.copyWith(counterReset: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get sensorType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.sensorType, (value) {
      return _then(_value.copyWith(sensorType: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharDInCopyWith<$Res>
    implements $SpecificResrcCharDInCopyWith<$Res> {
  factory _$SpecificResrcCharDInCopyWith(_SpecificResrcCharDIn value,
          $Res Function(_SpecificResrcCharDIn) then) =
      __$SpecificResrcCharDInCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl dInState,
      InstanceAndOpsCtrl counter,
      InstanceAndOpsCtrl dInPolarity,
      InstanceAndOpsCtrl debouncePeriod,
      InstanceAndOpsCtrl edgeSelection,
      InstanceAndOpsCtrl counterReset,
      InstanceAndOpsCtrl appType,
      InstanceAndOpsCtrl sensorType});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dInState;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get counter;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dInPolarity;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get debouncePeriod;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get edgeSelection;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get counterReset;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get sensorType;
}

/// @nodoc
class __$SpecificResrcCharDInCopyWithImpl<$Res>
    extends _$SpecificResrcCharDInCopyWithImpl<$Res>
    implements _$SpecificResrcCharDInCopyWith<$Res> {
  __$SpecificResrcCharDInCopyWithImpl(
      _SpecificResrcCharDIn _value, $Res Function(_SpecificResrcCharDIn) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharDIn));

  @override
  _SpecificResrcCharDIn get _value => super._value as _SpecificResrcCharDIn;

  @override
  $Res call({
    Object? dInState = freezed,
    Object? counter = freezed,
    Object? dInPolarity = freezed,
    Object? debouncePeriod = freezed,
    Object? edgeSelection = freezed,
    Object? counterReset = freezed,
    Object? appType = freezed,
    Object? sensorType = freezed,
  }) {
    return _then(_SpecificResrcCharDIn(
      dInState: dInState == freezed
          ? _value.dInState
          : dInState // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      dInPolarity: dInPolarity == freezed
          ? _value.dInPolarity
          : dInPolarity // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      debouncePeriod: debouncePeriod == freezed
          ? _value.debouncePeriod
          : debouncePeriod // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      edgeSelection: edgeSelection == freezed
          ? _value.edgeSelection
          : edgeSelection // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      counterReset: counterReset == freezed
          ? _value.counterReset
          : counterReset // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      sensorType: sensorType == freezed
          ? _value.sensorType
          : sensorType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharDIn implements _SpecificResrcCharDIn {
  const _$_SpecificResrcCharDIn(
      {required this.dInState,
      required this.counter,
      required this.dInPolarity,
      required this.debouncePeriod,
      required this.edgeSelection,
      required this.counterReset,
      required this.appType,
      required this.sensorType});

  factory _$_SpecificResrcCharDIn.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharDInFromJson(json);

  @override
  final InstanceAndOpsCtrl dInState;
  @override
  final InstanceAndOpsCtrl counter;
  @override
  final InstanceAndOpsCtrl dInPolarity;
  @override
  final InstanceAndOpsCtrl debouncePeriod;
  @override
  final InstanceAndOpsCtrl edgeSelection;
  @override
  final InstanceAndOpsCtrl counterReset;
  @override
  final InstanceAndOpsCtrl appType;
  @override
  final InstanceAndOpsCtrl sensorType;

  @override
  String toString() {
    return 'SpecificResrcCharDIn(dInState: $dInState, counter: $counter, dInPolarity: $dInPolarity, debouncePeriod: $debouncePeriod, edgeSelection: $edgeSelection, counterReset: $counterReset, appType: $appType, sensorType: $sensorType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharDIn &&
            (identical(other.dInState, dInState) ||
                const DeepCollectionEquality()
                    .equals(other.dInState, dInState)) &&
            (identical(other.counter, counter) ||
                const DeepCollectionEquality()
                    .equals(other.counter, counter)) &&
            (identical(other.dInPolarity, dInPolarity) ||
                const DeepCollectionEquality()
                    .equals(other.dInPolarity, dInPolarity)) &&
            (identical(other.debouncePeriod, debouncePeriod) ||
                const DeepCollectionEquality()
                    .equals(other.debouncePeriod, debouncePeriod)) &&
            (identical(other.edgeSelection, edgeSelection) ||
                const DeepCollectionEquality()
                    .equals(other.edgeSelection, edgeSelection)) &&
            (identical(other.counterReset, counterReset) ||
                const DeepCollectionEquality()
                    .equals(other.counterReset, counterReset)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality()
                    .equals(other.appType, appType)) &&
            (identical(other.sensorType, sensorType) ||
                const DeepCollectionEquality()
                    .equals(other.sensorType, sensorType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(dInState) ^
      const DeepCollectionEquality().hash(counter) ^
      const DeepCollectionEquality().hash(dInPolarity) ^
      const DeepCollectionEquality().hash(debouncePeriod) ^
      const DeepCollectionEquality().hash(edgeSelection) ^
      const DeepCollectionEquality().hash(counterReset) ^
      const DeepCollectionEquality().hash(appType) ^
      const DeepCollectionEquality().hash(sensorType);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharDInCopyWith<_SpecificResrcCharDIn> get copyWith =>
      __$SpecificResrcCharDInCopyWithImpl<_SpecificResrcCharDIn>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharDInToJson(this);
  }
}

abstract class _SpecificResrcCharDIn implements SpecificResrcCharDIn {
  const factory _SpecificResrcCharDIn(
      {required InstanceAndOpsCtrl dInState,
      required InstanceAndOpsCtrl counter,
      required InstanceAndOpsCtrl dInPolarity,
      required InstanceAndOpsCtrl debouncePeriod,
      required InstanceAndOpsCtrl edgeSelection,
      required InstanceAndOpsCtrl counterReset,
      required InstanceAndOpsCtrl appType,
      required InstanceAndOpsCtrl sensorType}) = _$_SpecificResrcCharDIn;

  factory _SpecificResrcCharDIn.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharDIn.fromJson;

  @override
  InstanceAndOpsCtrl get dInState => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get counter => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get dInPolarity => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get debouncePeriod => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get edgeSelection => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get counterReset => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get sensorType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharDInCopyWith<_SpecificResrcCharDIn> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificResrcCharDOut _$SpecificResrcCharDOutFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharDOut.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharDOutTearOff {
  const _$SpecificResrcCharDOutTearOff();

  _SpecificResrcCharDOut call(
      {required InstanceAndOpsCtrl dOutState,
      required InstanceAndOpsCtrl dOutPolarity,
      required InstanceAndOpsCtrl appType}) {
    return _SpecificResrcCharDOut(
      dOutState: dOutState,
      dOutPolarity: dOutPolarity,
      appType: appType,
    );
  }

  SpecificResrcCharDOut fromJson(Map<String, Object> json) {
    return SpecificResrcCharDOut.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharDOut = _$SpecificResrcCharDOutTearOff();

/// @nodoc
mixin _$SpecificResrcCharDOut {
  InstanceAndOpsCtrl get dOutState => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get dOutPolarity => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharDOutCopyWith<SpecificResrcCharDOut> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharDOutCopyWith<$Res> {
  factory $SpecificResrcCharDOutCopyWith(SpecificResrcCharDOut value,
          $Res Function(SpecificResrcCharDOut) then) =
      _$SpecificResrcCharDOutCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl dOutState,
      InstanceAndOpsCtrl dOutPolarity,
      InstanceAndOpsCtrl appType});

  $InstanceAndOpsCtrlCopyWith<$Res> get dOutState;
  $InstanceAndOpsCtrlCopyWith<$Res> get dOutPolarity;
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class _$SpecificResrcCharDOutCopyWithImpl<$Res>
    implements $SpecificResrcCharDOutCopyWith<$Res> {
  _$SpecificResrcCharDOutCopyWithImpl(this._value, this._then);

  final SpecificResrcCharDOut _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharDOut) _then;

  @override
  $Res call({
    Object? dOutState = freezed,
    Object? dOutPolarity = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      dOutState: dOutState == freezed
          ? _value.dOutState
          : dOutState // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      dOutPolarity: dOutPolarity == freezed
          ? _value.dOutPolarity
          : dOutPolarity // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dOutState {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.dOutState, (value) {
      return _then(_value.copyWith(dOutState: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dOutPolarity {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.dOutPolarity, (value) {
      return _then(_value.copyWith(dOutPolarity: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharDOutCopyWith<$Res>
    implements $SpecificResrcCharDOutCopyWith<$Res> {
  factory _$SpecificResrcCharDOutCopyWith(_SpecificResrcCharDOut value,
          $Res Function(_SpecificResrcCharDOut) then) =
      __$SpecificResrcCharDOutCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl dOutState,
      InstanceAndOpsCtrl dOutPolarity,
      InstanceAndOpsCtrl appType});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dOutState;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dOutPolarity;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class __$SpecificResrcCharDOutCopyWithImpl<$Res>
    extends _$SpecificResrcCharDOutCopyWithImpl<$Res>
    implements _$SpecificResrcCharDOutCopyWith<$Res> {
  __$SpecificResrcCharDOutCopyWithImpl(_SpecificResrcCharDOut _value,
      $Res Function(_SpecificResrcCharDOut) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharDOut));

  @override
  _SpecificResrcCharDOut get _value => super._value as _SpecificResrcCharDOut;

  @override
  $Res call({
    Object? dOutState = freezed,
    Object? dOutPolarity = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificResrcCharDOut(
      dOutState: dOutState == freezed
          ? _value.dOutState
          : dOutState // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      dOutPolarity: dOutPolarity == freezed
          ? _value.dOutPolarity
          : dOutPolarity // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharDOut implements _SpecificResrcCharDOut {
  const _$_SpecificResrcCharDOut(
      {required this.dOutState,
      required this.dOutPolarity,
      required this.appType});

  factory _$_SpecificResrcCharDOut.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharDOutFromJson(json);

  @override
  final InstanceAndOpsCtrl dOutState;
  @override
  final InstanceAndOpsCtrl dOutPolarity;
  @override
  final InstanceAndOpsCtrl appType;

  @override
  String toString() {
    return 'SpecificResrcCharDOut(dOutState: $dOutState, dOutPolarity: $dOutPolarity, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharDOut &&
            (identical(other.dOutState, dOutState) ||
                const DeepCollectionEquality()
                    .equals(other.dOutState, dOutState)) &&
            (identical(other.dOutPolarity, dOutPolarity) ||
                const DeepCollectionEquality()
                    .equals(other.dOutPolarity, dOutPolarity)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(dOutState) ^
      const DeepCollectionEquality().hash(dOutPolarity) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharDOutCopyWith<_SpecificResrcCharDOut> get copyWith =>
      __$SpecificResrcCharDOutCopyWithImpl<_SpecificResrcCharDOut>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharDOutToJson(this);
  }
}

abstract class _SpecificResrcCharDOut implements SpecificResrcCharDOut {
  const factory _SpecificResrcCharDOut(
      {required InstanceAndOpsCtrl dOutState,
      required InstanceAndOpsCtrl dOutPolarity,
      required InstanceAndOpsCtrl appType}) = _$_SpecificResrcCharDOut;

  factory _SpecificResrcCharDOut.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharDOut.fromJson;

  @override
  InstanceAndOpsCtrl get dOutState => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get dOutPolarity => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharDOutCopyWith<_SpecificResrcCharDOut> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificResrcCharDirection _$SpecificResrcCharDirectionFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharDirection.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharDirectionTearOff {
  const _$SpecificResrcCharDirectionTearOff();

  _SpecificResrcCharDirection call(
      {required InstanceAndOpsCtrl compassDir,
      required InstanceAndOpsCtrl minMeaValue,
      required InstanceAndOpsCtrl maxMeaValue,
      required InstanceAndOpsCtrl resetMinMaxMeaValues,
      required InstanceAndOpsCtrl appType}) {
    return _SpecificResrcCharDirection(
      compassDir: compassDir,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      appType: appType,
    );
  }

  SpecificResrcCharDirection fromJson(Map<String, Object> json) {
    return SpecificResrcCharDirection.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharDirection = _$SpecificResrcCharDirectionTearOff();

/// @nodoc
mixin _$SpecificResrcCharDirection {
  InstanceAndOpsCtrl get compassDir => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get minMeaValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get maxMeaValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get resetMinMaxMeaValues =>
      throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharDirectionCopyWith<SpecificResrcCharDirection>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharDirectionCopyWith<$Res> {
  factory $SpecificResrcCharDirectionCopyWith(SpecificResrcCharDirection value,
          $Res Function(SpecificResrcCharDirection) then) =
      _$SpecificResrcCharDirectionCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl compassDir,
      InstanceAndOpsCtrl minMeaValue,
      InstanceAndOpsCtrl maxMeaValue,
      InstanceAndOpsCtrl resetMinMaxMeaValues,
      InstanceAndOpsCtrl appType});

  $InstanceAndOpsCtrlCopyWith<$Res> get compassDir;
  $InstanceAndOpsCtrlCopyWith<$Res> get minMeaValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get maxMeaValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get resetMinMaxMeaValues;
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class _$SpecificResrcCharDirectionCopyWithImpl<$Res>
    implements $SpecificResrcCharDirectionCopyWith<$Res> {
  _$SpecificResrcCharDirectionCopyWithImpl(this._value, this._then);

  final SpecificResrcCharDirection _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharDirection) _then;

  @override
  $Res call({
    Object? compassDir = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      compassDir: compassDir == freezed
          ? _value.compassDir
          : compassDir // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get compassDir {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.compassDir, (value) {
      return _then(_value.copyWith(compassDir: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get minMeaValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.minMeaValue, (value) {
      return _then(_value.copyWith(minMeaValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get maxMeaValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.maxMeaValue, (value) {
      return _then(_value.copyWith(maxMeaValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get resetMinMaxMeaValues {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.resetMinMaxMeaValues,
        (value) {
      return _then(_value.copyWith(resetMinMaxMeaValues: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharDirectionCopyWith<$Res>
    implements $SpecificResrcCharDirectionCopyWith<$Res> {
  factory _$SpecificResrcCharDirectionCopyWith(
          _SpecificResrcCharDirection value,
          $Res Function(_SpecificResrcCharDirection) then) =
      __$SpecificResrcCharDirectionCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl compassDir,
      InstanceAndOpsCtrl minMeaValue,
      InstanceAndOpsCtrl maxMeaValue,
      InstanceAndOpsCtrl resetMinMaxMeaValues,
      InstanceAndOpsCtrl appType});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get compassDir;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get minMeaValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get maxMeaValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get resetMinMaxMeaValues;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class __$SpecificResrcCharDirectionCopyWithImpl<$Res>
    extends _$SpecificResrcCharDirectionCopyWithImpl<$Res>
    implements _$SpecificResrcCharDirectionCopyWith<$Res> {
  __$SpecificResrcCharDirectionCopyWithImpl(_SpecificResrcCharDirection _value,
      $Res Function(_SpecificResrcCharDirection) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharDirection));

  @override
  _SpecificResrcCharDirection get _value =>
      super._value as _SpecificResrcCharDirection;

  @override
  $Res call({
    Object? compassDir = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificResrcCharDirection(
      compassDir: compassDir == freezed
          ? _value.compassDir
          : compassDir // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharDirection implements _SpecificResrcCharDirection {
  const _$_SpecificResrcCharDirection(
      {required this.compassDir,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.resetMinMaxMeaValues,
      required this.appType});

  factory _$_SpecificResrcCharDirection.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharDirectionFromJson(json);

  @override
  final InstanceAndOpsCtrl compassDir;
  @override
  final InstanceAndOpsCtrl minMeaValue;
  @override
  final InstanceAndOpsCtrl maxMeaValue;
  @override
  final InstanceAndOpsCtrl resetMinMaxMeaValues;
  @override
  final InstanceAndOpsCtrl appType;

  @override
  String toString() {
    return 'SpecificResrcCharDirection(compassDir: $compassDir, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharDirection &&
            (identical(other.compassDir, compassDir) ||
                const DeepCollectionEquality()
                    .equals(other.compassDir, compassDir)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(compassDir) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharDirectionCopyWith<_SpecificResrcCharDirection>
      get copyWith => __$SpecificResrcCharDirectionCopyWithImpl<
          _SpecificResrcCharDirection>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharDirectionToJson(this);
  }
}

abstract class _SpecificResrcCharDirection
    implements SpecificResrcCharDirection {
  const factory _SpecificResrcCharDirection(
      {required InstanceAndOpsCtrl compassDir,
      required InstanceAndOpsCtrl minMeaValue,
      required InstanceAndOpsCtrl maxMeaValue,
      required InstanceAndOpsCtrl resetMinMaxMeaValues,
      required InstanceAndOpsCtrl appType}) = _$_SpecificResrcCharDirection;

  factory _SpecificResrcCharDirection.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharDirection.fromJson;

  @override
  InstanceAndOpsCtrl get compassDir => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get minMeaValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get maxMeaValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get resetMinMaxMeaValues =>
      throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharDirectionCopyWith<_SpecificResrcCharDirection>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharEnergy _$SpecificResrcCharEnergyFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharEnergy.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharEnergyTearOff {
  const _$SpecificResrcCharEnergyTearOff();

  _SpecificResrcCharEnergy call(
      {required InstanceAndOpsCtrl cumulActivePwr,
      required InstanceAndOpsCtrl units,
      required InstanceAndOpsCtrl resetCumulEnergy,
      required InstanceAndOpsCtrl appType}) {
    return _SpecificResrcCharEnergy(
      cumulActivePwr: cumulActivePwr,
      units: units,
      resetCumulEnergy: resetCumulEnergy,
      appType: appType,
    );
  }

  SpecificResrcCharEnergy fromJson(Map<String, Object> json) {
    return SpecificResrcCharEnergy.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharEnergy = _$SpecificResrcCharEnergyTearOff();

/// @nodoc
mixin _$SpecificResrcCharEnergy {
  InstanceAndOpsCtrl get cumulActivePwr => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get units => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get resetCumulEnergy => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharEnergyCopyWith<SpecificResrcCharEnergy> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharEnergyCopyWith<$Res> {
  factory $SpecificResrcCharEnergyCopyWith(SpecificResrcCharEnergy value,
          $Res Function(SpecificResrcCharEnergy) then) =
      _$SpecificResrcCharEnergyCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl cumulActivePwr,
      InstanceAndOpsCtrl units,
      InstanceAndOpsCtrl resetCumulEnergy,
      InstanceAndOpsCtrl appType});

  $InstanceAndOpsCtrlCopyWith<$Res> get cumulActivePwr;
  $InstanceAndOpsCtrlCopyWith<$Res> get units;
  $InstanceAndOpsCtrlCopyWith<$Res> get resetCumulEnergy;
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class _$SpecificResrcCharEnergyCopyWithImpl<$Res>
    implements $SpecificResrcCharEnergyCopyWith<$Res> {
  _$SpecificResrcCharEnergyCopyWithImpl(this._value, this._then);

  final SpecificResrcCharEnergy _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharEnergy) _then;

  @override
  $Res call({
    Object? cumulActivePwr = freezed,
    Object? units = freezed,
    Object? resetCumulEnergy = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      cumulActivePwr: cumulActivePwr == freezed
          ? _value.cumulActivePwr
          : cumulActivePwr // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      resetCumulEnergy: resetCumulEnergy == freezed
          ? _value.resetCumulEnergy
          : resetCumulEnergy // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get cumulActivePwr {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.cumulActivePwr, (value) {
      return _then(_value.copyWith(cumulActivePwr: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get units {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.units, (value) {
      return _then(_value.copyWith(units: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get resetCumulEnergy {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.resetCumulEnergy, (value) {
      return _then(_value.copyWith(resetCumulEnergy: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharEnergyCopyWith<$Res>
    implements $SpecificResrcCharEnergyCopyWith<$Res> {
  factory _$SpecificResrcCharEnergyCopyWith(_SpecificResrcCharEnergy value,
          $Res Function(_SpecificResrcCharEnergy) then) =
      __$SpecificResrcCharEnergyCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl cumulActivePwr,
      InstanceAndOpsCtrl units,
      InstanceAndOpsCtrl resetCumulEnergy,
      InstanceAndOpsCtrl appType});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get cumulActivePwr;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get units;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get resetCumulEnergy;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class __$SpecificResrcCharEnergyCopyWithImpl<$Res>
    extends _$SpecificResrcCharEnergyCopyWithImpl<$Res>
    implements _$SpecificResrcCharEnergyCopyWith<$Res> {
  __$SpecificResrcCharEnergyCopyWithImpl(_SpecificResrcCharEnergy _value,
      $Res Function(_SpecificResrcCharEnergy) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharEnergy));

  @override
  _SpecificResrcCharEnergy get _value =>
      super._value as _SpecificResrcCharEnergy;

  @override
  $Res call({
    Object? cumulActivePwr = freezed,
    Object? units = freezed,
    Object? resetCumulEnergy = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificResrcCharEnergy(
      cumulActivePwr: cumulActivePwr == freezed
          ? _value.cumulActivePwr
          : cumulActivePwr // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      resetCumulEnergy: resetCumulEnergy == freezed
          ? _value.resetCumulEnergy
          : resetCumulEnergy // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharEnergy implements _SpecificResrcCharEnergy {
  const _$_SpecificResrcCharEnergy(
      {required this.cumulActivePwr,
      required this.units,
      required this.resetCumulEnergy,
      required this.appType});

  factory _$_SpecificResrcCharEnergy.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharEnergyFromJson(json);

  @override
  final InstanceAndOpsCtrl cumulActivePwr;
  @override
  final InstanceAndOpsCtrl units;
  @override
  final InstanceAndOpsCtrl resetCumulEnergy;
  @override
  final InstanceAndOpsCtrl appType;

  @override
  String toString() {
    return 'SpecificResrcCharEnergy(cumulActivePwr: $cumulActivePwr, units: $units, resetCumulEnergy: $resetCumulEnergy, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharEnergy &&
            (identical(other.cumulActivePwr, cumulActivePwr) ||
                const DeepCollectionEquality()
                    .equals(other.cumulActivePwr, cumulActivePwr)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.resetCumulEnergy, resetCumulEnergy) ||
                const DeepCollectionEquality()
                    .equals(other.resetCumulEnergy, resetCumulEnergy)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(cumulActivePwr) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(resetCumulEnergy) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharEnergyCopyWith<_SpecificResrcCharEnergy> get copyWith =>
      __$SpecificResrcCharEnergyCopyWithImpl<_SpecificResrcCharEnergy>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharEnergyToJson(this);
  }
}

abstract class _SpecificResrcCharEnergy implements SpecificResrcCharEnergy {
  const factory _SpecificResrcCharEnergy(
      {required InstanceAndOpsCtrl cumulActivePwr,
      required InstanceAndOpsCtrl units,
      required InstanceAndOpsCtrl resetCumulEnergy,
      required InstanceAndOpsCtrl appType}) = _$_SpecificResrcCharEnergy;

  factory _SpecificResrcCharEnergy.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharEnergy.fromJson;

  @override
  InstanceAndOpsCtrl get cumulActivePwr => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get units => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get resetCumulEnergy => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharEnergyCopyWith<_SpecificResrcCharEnergy> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificResrcCharFirmware _$SpecificResrcCharFirmwareFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharFirmware.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharFirmwareTearOff {
  const _$SpecificResrcCharFirmwareTearOff();

  _SpecificResrcCharFirmware call(
      {required InstanceAndOpsCtrl package,
      @JsonKey(name: "packageURI") required InstanceAndOpsCtrl packageUri,
      required InstanceAndOpsCtrl update,
      required InstanceAndOpsCtrl state,
      required InstanceAndOpsCtrl updateSuppObjects,
      required InstanceAndOpsCtrl updateResult,
      required InstanceAndOpsCtrl pkgName,
      required InstanceAndOpsCtrl pkgVer}) {
    return _SpecificResrcCharFirmware(
      package: package,
      packageUri: packageUri,
      update: update,
      state: state,
      updateSuppObjects: updateSuppObjects,
      updateResult: updateResult,
      pkgName: pkgName,
      pkgVer: pkgVer,
    );
  }

  SpecificResrcCharFirmware fromJson(Map<String, Object> json) {
    return SpecificResrcCharFirmware.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharFirmware = _$SpecificResrcCharFirmwareTearOff();

/// @nodoc
mixin _$SpecificResrcCharFirmware {
  InstanceAndOpsCtrl get package => throw _privateConstructorUsedError;
  @JsonKey(name: "packageURI")
  InstanceAndOpsCtrl get packageUri => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get update => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get state => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get updateSuppObjects =>
      throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get updateResult => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get pkgName => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get pkgVer => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharFirmwareCopyWith<SpecificResrcCharFirmware> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharFirmwareCopyWith<$Res> {
  factory $SpecificResrcCharFirmwareCopyWith(SpecificResrcCharFirmware value,
          $Res Function(SpecificResrcCharFirmware) then) =
      _$SpecificResrcCharFirmwareCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl package,
      @JsonKey(name: "packageURI") InstanceAndOpsCtrl packageUri,
      InstanceAndOpsCtrl update,
      InstanceAndOpsCtrl state,
      InstanceAndOpsCtrl updateSuppObjects,
      InstanceAndOpsCtrl updateResult,
      InstanceAndOpsCtrl pkgName,
      InstanceAndOpsCtrl pkgVer});

  $InstanceAndOpsCtrlCopyWith<$Res> get package;
  $InstanceAndOpsCtrlCopyWith<$Res> get packageUri;
  $InstanceAndOpsCtrlCopyWith<$Res> get update;
  $InstanceAndOpsCtrlCopyWith<$Res> get state;
  $InstanceAndOpsCtrlCopyWith<$Res> get updateSuppObjects;
  $InstanceAndOpsCtrlCopyWith<$Res> get updateResult;
  $InstanceAndOpsCtrlCopyWith<$Res> get pkgName;
  $InstanceAndOpsCtrlCopyWith<$Res> get pkgVer;
}

/// @nodoc
class _$SpecificResrcCharFirmwareCopyWithImpl<$Res>
    implements $SpecificResrcCharFirmwareCopyWith<$Res> {
  _$SpecificResrcCharFirmwareCopyWithImpl(this._value, this._then);

  final SpecificResrcCharFirmware _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharFirmware) _then;

  @override
  $Res call({
    Object? package = freezed,
    Object? packageUri = freezed,
    Object? update = freezed,
    Object? state = freezed,
    Object? updateSuppObjects = freezed,
    Object? updateResult = freezed,
    Object? pkgName = freezed,
    Object? pkgVer = freezed,
  }) {
    return _then(_value.copyWith(
      package: package == freezed
          ? _value.package
          : package // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      packageUri: packageUri == freezed
          ? _value.packageUri
          : packageUri // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      update: update == freezed
          ? _value.update
          : update // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      state: state == freezed
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      updateSuppObjects: updateSuppObjects == freezed
          ? _value.updateSuppObjects
          : updateSuppObjects // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      updateResult: updateResult == freezed
          ? _value.updateResult
          : updateResult // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      pkgName: pkgName == freezed
          ? _value.pkgName
          : pkgName // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      pkgVer: pkgVer == freezed
          ? _value.pkgVer
          : pkgVer // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get package {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.package, (value) {
      return _then(_value.copyWith(package: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get packageUri {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.packageUri, (value) {
      return _then(_value.copyWith(packageUri: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get update {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.update, (value) {
      return _then(_value.copyWith(update: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get state {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.state, (value) {
      return _then(_value.copyWith(state: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get updateSuppObjects {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.updateSuppObjects, (value) {
      return _then(_value.copyWith(updateSuppObjects: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get updateResult {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.updateResult, (value) {
      return _then(_value.copyWith(updateResult: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get pkgName {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.pkgName, (value) {
      return _then(_value.copyWith(pkgName: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get pkgVer {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.pkgVer, (value) {
      return _then(_value.copyWith(pkgVer: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharFirmwareCopyWith<$Res>
    implements $SpecificResrcCharFirmwareCopyWith<$Res> {
  factory _$SpecificResrcCharFirmwareCopyWith(_SpecificResrcCharFirmware value,
          $Res Function(_SpecificResrcCharFirmware) then) =
      __$SpecificResrcCharFirmwareCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl package,
      @JsonKey(name: "packageURI") InstanceAndOpsCtrl packageUri,
      InstanceAndOpsCtrl update,
      InstanceAndOpsCtrl state,
      InstanceAndOpsCtrl updateSuppObjects,
      InstanceAndOpsCtrl updateResult,
      InstanceAndOpsCtrl pkgName,
      InstanceAndOpsCtrl pkgVer});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get package;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get packageUri;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get update;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get state;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get updateSuppObjects;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get updateResult;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get pkgName;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get pkgVer;
}

/// @nodoc
class __$SpecificResrcCharFirmwareCopyWithImpl<$Res>
    extends _$SpecificResrcCharFirmwareCopyWithImpl<$Res>
    implements _$SpecificResrcCharFirmwareCopyWith<$Res> {
  __$SpecificResrcCharFirmwareCopyWithImpl(_SpecificResrcCharFirmware _value,
      $Res Function(_SpecificResrcCharFirmware) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharFirmware));

  @override
  _SpecificResrcCharFirmware get _value =>
      super._value as _SpecificResrcCharFirmware;

  @override
  $Res call({
    Object? package = freezed,
    Object? packageUri = freezed,
    Object? update = freezed,
    Object? state = freezed,
    Object? updateSuppObjects = freezed,
    Object? updateResult = freezed,
    Object? pkgName = freezed,
    Object? pkgVer = freezed,
  }) {
    return _then(_SpecificResrcCharFirmware(
      package: package == freezed
          ? _value.package
          : package // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      packageUri: packageUri == freezed
          ? _value.packageUri
          : packageUri // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      update: update == freezed
          ? _value.update
          : update // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      state: state == freezed
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      updateSuppObjects: updateSuppObjects == freezed
          ? _value.updateSuppObjects
          : updateSuppObjects // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      updateResult: updateResult == freezed
          ? _value.updateResult
          : updateResult // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      pkgName: pkgName == freezed
          ? _value.pkgName
          : pkgName // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      pkgVer: pkgVer == freezed
          ? _value.pkgVer
          : pkgVer // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharFirmware implements _SpecificResrcCharFirmware {
  const _$_SpecificResrcCharFirmware(
      {required this.package,
      @JsonKey(name: "packageURI") required this.packageUri,
      required this.update,
      required this.state,
      required this.updateSuppObjects,
      required this.updateResult,
      required this.pkgName,
      required this.pkgVer});

  factory _$_SpecificResrcCharFirmware.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharFirmwareFromJson(json);

  @override
  final InstanceAndOpsCtrl package;
  @override
  @JsonKey(name: "packageURI")
  final InstanceAndOpsCtrl packageUri;
  @override
  final InstanceAndOpsCtrl update;
  @override
  final InstanceAndOpsCtrl state;
  @override
  final InstanceAndOpsCtrl updateSuppObjects;
  @override
  final InstanceAndOpsCtrl updateResult;
  @override
  final InstanceAndOpsCtrl pkgName;
  @override
  final InstanceAndOpsCtrl pkgVer;

  @override
  String toString() {
    return 'SpecificResrcCharFirmware(package: $package, packageUri: $packageUri, update: $update, state: $state, updateSuppObjects: $updateSuppObjects, updateResult: $updateResult, pkgName: $pkgName, pkgVer: $pkgVer)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharFirmware &&
            (identical(other.package, package) ||
                const DeepCollectionEquality()
                    .equals(other.package, package)) &&
            (identical(other.packageUri, packageUri) ||
                const DeepCollectionEquality()
                    .equals(other.packageUri, packageUri)) &&
            (identical(other.update, update) ||
                const DeepCollectionEquality().equals(other.update, update)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.updateSuppObjects, updateSuppObjects) ||
                const DeepCollectionEquality()
                    .equals(other.updateSuppObjects, updateSuppObjects)) &&
            (identical(other.updateResult, updateResult) ||
                const DeepCollectionEquality()
                    .equals(other.updateResult, updateResult)) &&
            (identical(other.pkgName, pkgName) ||
                const DeepCollectionEquality()
                    .equals(other.pkgName, pkgName)) &&
            (identical(other.pkgVer, pkgVer) ||
                const DeepCollectionEquality().equals(other.pkgVer, pkgVer)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(package) ^
      const DeepCollectionEquality().hash(packageUri) ^
      const DeepCollectionEquality().hash(update) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(updateSuppObjects) ^
      const DeepCollectionEquality().hash(updateResult) ^
      const DeepCollectionEquality().hash(pkgName) ^
      const DeepCollectionEquality().hash(pkgVer);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharFirmwareCopyWith<_SpecificResrcCharFirmware>
      get copyWith =>
          __$SpecificResrcCharFirmwareCopyWithImpl<_SpecificResrcCharFirmware>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharFirmwareToJson(this);
  }
}

abstract class _SpecificResrcCharFirmware implements SpecificResrcCharFirmware {
  const factory _SpecificResrcCharFirmware(
      {required InstanceAndOpsCtrl package,
      @JsonKey(name: "packageURI") required InstanceAndOpsCtrl packageUri,
      required InstanceAndOpsCtrl update,
      required InstanceAndOpsCtrl state,
      required InstanceAndOpsCtrl updateSuppObjects,
      required InstanceAndOpsCtrl updateResult,
      required InstanceAndOpsCtrl pkgName,
      required InstanceAndOpsCtrl pkgVer}) = _$_SpecificResrcCharFirmware;

  factory _SpecificResrcCharFirmware.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharFirmware.fromJson;

  @override
  InstanceAndOpsCtrl get package => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "packageURI")
  InstanceAndOpsCtrl get packageUri => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get update => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get state => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get updateSuppObjects =>
      throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get updateResult => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get pkgName => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get pkgVer => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharFirmwareCopyWith<_SpecificResrcCharFirmware>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharGpsLocation _$SpecificResrcCharGpsLocationFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharGpsLocation.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharGpsLocationTearOff {
  const _$SpecificResrcCharGpsLocationTearOff();

  _SpecificResrcCharGpsLocation call(
      {required InstanceAndOpsCtrl latitude,
      required InstanceAndOpsCtrl longitude,
      required InstanceAndOpsCtrl uncertainty,
      required InstanceAndOpsCtrl compassDir,
      required InstanceAndOpsCtrl velocity,
      required InstanceAndOpsCtrl timestamp,
      required InstanceAndOpsCtrl appType}) {
    return _SpecificResrcCharGpsLocation(
      latitude: latitude,
      longitude: longitude,
      uncertainty: uncertainty,
      compassDir: compassDir,
      velocity: velocity,
      timestamp: timestamp,
      appType: appType,
    );
  }

  SpecificResrcCharGpsLocation fromJson(Map<String, Object> json) {
    return SpecificResrcCharGpsLocation.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharGpsLocation = _$SpecificResrcCharGpsLocationTearOff();

/// @nodoc
mixin _$SpecificResrcCharGpsLocation {
  InstanceAndOpsCtrl get latitude => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get longitude => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get uncertainty => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get compassDir => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get velocity => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get timestamp => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharGpsLocationCopyWith<SpecificResrcCharGpsLocation>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharGpsLocationCopyWith<$Res> {
  factory $SpecificResrcCharGpsLocationCopyWith(
          SpecificResrcCharGpsLocation value,
          $Res Function(SpecificResrcCharGpsLocation) then) =
      _$SpecificResrcCharGpsLocationCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl latitude,
      InstanceAndOpsCtrl longitude,
      InstanceAndOpsCtrl uncertainty,
      InstanceAndOpsCtrl compassDir,
      InstanceAndOpsCtrl velocity,
      InstanceAndOpsCtrl timestamp,
      InstanceAndOpsCtrl appType});

  $InstanceAndOpsCtrlCopyWith<$Res> get latitude;
  $InstanceAndOpsCtrlCopyWith<$Res> get longitude;
  $InstanceAndOpsCtrlCopyWith<$Res> get uncertainty;
  $InstanceAndOpsCtrlCopyWith<$Res> get compassDir;
  $InstanceAndOpsCtrlCopyWith<$Res> get velocity;
  $InstanceAndOpsCtrlCopyWith<$Res> get timestamp;
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class _$SpecificResrcCharGpsLocationCopyWithImpl<$Res>
    implements $SpecificResrcCharGpsLocationCopyWith<$Res> {
  _$SpecificResrcCharGpsLocationCopyWithImpl(this._value, this._then);

  final SpecificResrcCharGpsLocation _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharGpsLocation) _then;

  @override
  $Res call({
    Object? latitude = freezed,
    Object? longitude = freezed,
    Object? uncertainty = freezed,
    Object? compassDir = freezed,
    Object? velocity = freezed,
    Object? timestamp = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      latitude: latitude == freezed
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      longitude: longitude == freezed
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      uncertainty: uncertainty == freezed
          ? _value.uncertainty
          : uncertainty // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      compassDir: compassDir == freezed
          ? _value.compassDir
          : compassDir // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      velocity: velocity == freezed
          ? _value.velocity
          : velocity // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      timestamp: timestamp == freezed
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get latitude {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.latitude, (value) {
      return _then(_value.copyWith(latitude: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get longitude {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.longitude, (value) {
      return _then(_value.copyWith(longitude: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get uncertainty {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.uncertainty, (value) {
      return _then(_value.copyWith(uncertainty: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get compassDir {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.compassDir, (value) {
      return _then(_value.copyWith(compassDir: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get velocity {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.velocity, (value) {
      return _then(_value.copyWith(velocity: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get timestamp {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.timestamp, (value) {
      return _then(_value.copyWith(timestamp: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharGpsLocationCopyWith<$Res>
    implements $SpecificResrcCharGpsLocationCopyWith<$Res> {
  factory _$SpecificResrcCharGpsLocationCopyWith(
          _SpecificResrcCharGpsLocation value,
          $Res Function(_SpecificResrcCharGpsLocation) then) =
      __$SpecificResrcCharGpsLocationCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl latitude,
      InstanceAndOpsCtrl longitude,
      InstanceAndOpsCtrl uncertainty,
      InstanceAndOpsCtrl compassDir,
      InstanceAndOpsCtrl velocity,
      InstanceAndOpsCtrl timestamp,
      InstanceAndOpsCtrl appType});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get latitude;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get longitude;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get uncertainty;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get compassDir;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get velocity;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get timestamp;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class __$SpecificResrcCharGpsLocationCopyWithImpl<$Res>
    extends _$SpecificResrcCharGpsLocationCopyWithImpl<$Res>
    implements _$SpecificResrcCharGpsLocationCopyWith<$Res> {
  __$SpecificResrcCharGpsLocationCopyWithImpl(
      _SpecificResrcCharGpsLocation _value,
      $Res Function(_SpecificResrcCharGpsLocation) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharGpsLocation));

  @override
  _SpecificResrcCharGpsLocation get _value =>
      super._value as _SpecificResrcCharGpsLocation;

  @override
  $Res call({
    Object? latitude = freezed,
    Object? longitude = freezed,
    Object? uncertainty = freezed,
    Object? compassDir = freezed,
    Object? velocity = freezed,
    Object? timestamp = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificResrcCharGpsLocation(
      latitude: latitude == freezed
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      longitude: longitude == freezed
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      uncertainty: uncertainty == freezed
          ? _value.uncertainty
          : uncertainty // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      compassDir: compassDir == freezed
          ? _value.compassDir
          : compassDir // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      velocity: velocity == freezed
          ? _value.velocity
          : velocity // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      timestamp: timestamp == freezed
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharGpsLocation implements _SpecificResrcCharGpsLocation {
  const _$_SpecificResrcCharGpsLocation(
      {required this.latitude,
      required this.longitude,
      required this.uncertainty,
      required this.compassDir,
      required this.velocity,
      required this.timestamp,
      required this.appType});

  factory _$_SpecificResrcCharGpsLocation.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharGpsLocationFromJson(json);

  @override
  final InstanceAndOpsCtrl latitude;
  @override
  final InstanceAndOpsCtrl longitude;
  @override
  final InstanceAndOpsCtrl uncertainty;
  @override
  final InstanceAndOpsCtrl compassDir;
  @override
  final InstanceAndOpsCtrl velocity;
  @override
  final InstanceAndOpsCtrl timestamp;
  @override
  final InstanceAndOpsCtrl appType;

  @override
  String toString() {
    return 'SpecificResrcCharGpsLocation(latitude: $latitude, longitude: $longitude, uncertainty: $uncertainty, compassDir: $compassDir, velocity: $velocity, timestamp: $timestamp, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharGpsLocation &&
            (identical(other.latitude, latitude) ||
                const DeepCollectionEquality()
                    .equals(other.latitude, latitude)) &&
            (identical(other.longitude, longitude) ||
                const DeepCollectionEquality()
                    .equals(other.longitude, longitude)) &&
            (identical(other.uncertainty, uncertainty) ||
                const DeepCollectionEquality()
                    .equals(other.uncertainty, uncertainty)) &&
            (identical(other.compassDir, compassDir) ||
                const DeepCollectionEquality()
                    .equals(other.compassDir, compassDir)) &&
            (identical(other.velocity, velocity) ||
                const DeepCollectionEquality()
                    .equals(other.velocity, velocity)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality()
                    .equals(other.timestamp, timestamp)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(latitude) ^
      const DeepCollectionEquality().hash(longitude) ^
      const DeepCollectionEquality().hash(uncertainty) ^
      const DeepCollectionEquality().hash(compassDir) ^
      const DeepCollectionEquality().hash(velocity) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharGpsLocationCopyWith<_SpecificResrcCharGpsLocation>
      get copyWith => __$SpecificResrcCharGpsLocationCopyWithImpl<
          _SpecificResrcCharGpsLocation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharGpsLocationToJson(this);
  }
}

abstract class _SpecificResrcCharGpsLocation
    implements SpecificResrcCharGpsLocation {
  const factory _SpecificResrcCharGpsLocation(
      {required InstanceAndOpsCtrl latitude,
      required InstanceAndOpsCtrl longitude,
      required InstanceAndOpsCtrl uncertainty,
      required InstanceAndOpsCtrl compassDir,
      required InstanceAndOpsCtrl velocity,
      required InstanceAndOpsCtrl timestamp,
      required InstanceAndOpsCtrl appType}) = _$_SpecificResrcCharGpsLocation;

  factory _SpecificResrcCharGpsLocation.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharGpsLocation.fromJson;

  @override
  InstanceAndOpsCtrl get latitude => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get longitude => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get uncertainty => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get compassDir => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get velocity => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get timestamp => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharGpsLocationCopyWith<_SpecificResrcCharGpsLocation>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharLevelControl _$SpecificResrcCharLevelControlFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharLevelControl.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharLevelControlTearOff {
  const _$SpecificResrcCharLevelControlTearOff();

  _SpecificResrcCharLevelControl call(
      {required InstanceAndOpsCtrl level,
      required InstanceAndOpsCtrl onTime,
      required InstanceAndOpsCtrl offTime,
      required InstanceAndOpsCtrl appType}) {
    return _SpecificResrcCharLevelControl(
      level: level,
      onTime: onTime,
      offTime: offTime,
      appType: appType,
    );
  }

  SpecificResrcCharLevelControl fromJson(Map<String, Object> json) {
    return SpecificResrcCharLevelControl.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharLevelControl = _$SpecificResrcCharLevelControlTearOff();

/// @nodoc
mixin _$SpecificResrcCharLevelControl {
  InstanceAndOpsCtrl get level => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get onTime => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get offTime => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharLevelControlCopyWith<SpecificResrcCharLevelControl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharLevelControlCopyWith<$Res> {
  factory $SpecificResrcCharLevelControlCopyWith(
          SpecificResrcCharLevelControl value,
          $Res Function(SpecificResrcCharLevelControl) then) =
      _$SpecificResrcCharLevelControlCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl level,
      InstanceAndOpsCtrl onTime,
      InstanceAndOpsCtrl offTime,
      InstanceAndOpsCtrl appType});

  $InstanceAndOpsCtrlCopyWith<$Res> get level;
  $InstanceAndOpsCtrlCopyWith<$Res> get onTime;
  $InstanceAndOpsCtrlCopyWith<$Res> get offTime;
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class _$SpecificResrcCharLevelControlCopyWithImpl<$Res>
    implements $SpecificResrcCharLevelControlCopyWith<$Res> {
  _$SpecificResrcCharLevelControlCopyWithImpl(this._value, this._then);

  final SpecificResrcCharLevelControl _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharLevelControl) _then;

  @override
  $Res call({
    Object? level = freezed,
    Object? onTime = freezed,
    Object? offTime = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      level: level == freezed
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      onTime: onTime == freezed
          ? _value.onTime
          : onTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      offTime: offTime == freezed
          ? _value.offTime
          : offTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get level {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.level, (value) {
      return _then(_value.copyWith(level: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get onTime {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.onTime, (value) {
      return _then(_value.copyWith(onTime: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get offTime {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.offTime, (value) {
      return _then(_value.copyWith(offTime: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharLevelControlCopyWith<$Res>
    implements $SpecificResrcCharLevelControlCopyWith<$Res> {
  factory _$SpecificResrcCharLevelControlCopyWith(
          _SpecificResrcCharLevelControl value,
          $Res Function(_SpecificResrcCharLevelControl) then) =
      __$SpecificResrcCharLevelControlCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl level,
      InstanceAndOpsCtrl onTime,
      InstanceAndOpsCtrl offTime,
      InstanceAndOpsCtrl appType});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get level;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get onTime;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get offTime;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class __$SpecificResrcCharLevelControlCopyWithImpl<$Res>
    extends _$SpecificResrcCharLevelControlCopyWithImpl<$Res>
    implements _$SpecificResrcCharLevelControlCopyWith<$Res> {
  __$SpecificResrcCharLevelControlCopyWithImpl(
      _SpecificResrcCharLevelControl _value,
      $Res Function(_SpecificResrcCharLevelControl) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharLevelControl));

  @override
  _SpecificResrcCharLevelControl get _value =>
      super._value as _SpecificResrcCharLevelControl;

  @override
  $Res call({
    Object? level = freezed,
    Object? onTime = freezed,
    Object? offTime = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificResrcCharLevelControl(
      level: level == freezed
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      onTime: onTime == freezed
          ? _value.onTime
          : onTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      offTime: offTime == freezed
          ? _value.offTime
          : offTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharLevelControl
    implements _SpecificResrcCharLevelControl {
  const _$_SpecificResrcCharLevelControl(
      {required this.level,
      required this.onTime,
      required this.offTime,
      required this.appType});

  factory _$_SpecificResrcCharLevelControl.fromJson(
          Map<String, dynamic> json) =>
      _$$_SpecificResrcCharLevelControlFromJson(json);

  @override
  final InstanceAndOpsCtrl level;
  @override
  final InstanceAndOpsCtrl onTime;
  @override
  final InstanceAndOpsCtrl offTime;
  @override
  final InstanceAndOpsCtrl appType;

  @override
  String toString() {
    return 'SpecificResrcCharLevelControl(level: $level, onTime: $onTime, offTime: $offTime, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharLevelControl &&
            (identical(other.level, level) ||
                const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.onTime, onTime) ||
                const DeepCollectionEquality().equals(other.onTime, onTime)) &&
            (identical(other.offTime, offTime) ||
                const DeepCollectionEquality()
                    .equals(other.offTime, offTime)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(onTime) ^
      const DeepCollectionEquality().hash(offTime) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharLevelControlCopyWith<_SpecificResrcCharLevelControl>
      get copyWith => __$SpecificResrcCharLevelControlCopyWithImpl<
          _SpecificResrcCharLevelControl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharLevelControlToJson(this);
  }
}

abstract class _SpecificResrcCharLevelControl
    implements SpecificResrcCharLevelControl {
  const factory _SpecificResrcCharLevelControl(
      {required InstanceAndOpsCtrl level,
      required InstanceAndOpsCtrl onTime,
      required InstanceAndOpsCtrl offTime,
      required InstanceAndOpsCtrl appType}) = _$_SpecificResrcCharLevelControl;

  factory _SpecificResrcCharLevelControl.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharLevelControl.fromJson;

  @override
  InstanceAndOpsCtrl get level => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get onTime => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get offTime => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharLevelControlCopyWith<_SpecificResrcCharLevelControl>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharLightCtrl _$SpecificResrcCharLightCtrlFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharLightCtrl.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharLightCtrlTearOff {
  const _$SpecificResrcCharLightCtrlTearOff();

  _SpecificResrcCharLightCtrl call(
      {required InstanceAndOpsCtrl onOff,
      required InstanceAndOpsCtrl dimmer,
      required InstanceAndOpsCtrl colour,
      required InstanceAndOpsCtrl units,
      required InstanceAndOpsCtrl onTime,
      required InstanceAndOpsCtrl cumulActivePwr,
      required InstanceAndOpsCtrl pwrFactor}) {
    return _SpecificResrcCharLightCtrl(
      onOff: onOff,
      dimmer: dimmer,
      colour: colour,
      units: units,
      onTime: onTime,
      cumulActivePwr: cumulActivePwr,
      pwrFactor: pwrFactor,
    );
  }

  SpecificResrcCharLightCtrl fromJson(Map<String, Object> json) {
    return SpecificResrcCharLightCtrl.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharLightCtrl = _$SpecificResrcCharLightCtrlTearOff();

/// @nodoc
mixin _$SpecificResrcCharLightCtrl {
  InstanceAndOpsCtrl get onOff => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get dimmer => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get colour => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get units => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get onTime => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get cumulActivePwr => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get pwrFactor => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharLightCtrlCopyWith<SpecificResrcCharLightCtrl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharLightCtrlCopyWith<$Res> {
  factory $SpecificResrcCharLightCtrlCopyWith(SpecificResrcCharLightCtrl value,
          $Res Function(SpecificResrcCharLightCtrl) then) =
      _$SpecificResrcCharLightCtrlCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl onOff,
      InstanceAndOpsCtrl dimmer,
      InstanceAndOpsCtrl colour,
      InstanceAndOpsCtrl units,
      InstanceAndOpsCtrl onTime,
      InstanceAndOpsCtrl cumulActivePwr,
      InstanceAndOpsCtrl pwrFactor});

  $InstanceAndOpsCtrlCopyWith<$Res> get onOff;
  $InstanceAndOpsCtrlCopyWith<$Res> get dimmer;
  $InstanceAndOpsCtrlCopyWith<$Res> get colour;
  $InstanceAndOpsCtrlCopyWith<$Res> get units;
  $InstanceAndOpsCtrlCopyWith<$Res> get onTime;
  $InstanceAndOpsCtrlCopyWith<$Res> get cumulActivePwr;
  $InstanceAndOpsCtrlCopyWith<$Res> get pwrFactor;
}

/// @nodoc
class _$SpecificResrcCharLightCtrlCopyWithImpl<$Res>
    implements $SpecificResrcCharLightCtrlCopyWith<$Res> {
  _$SpecificResrcCharLightCtrlCopyWithImpl(this._value, this._then);

  final SpecificResrcCharLightCtrl _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharLightCtrl) _then;

  @override
  $Res call({
    Object? onOff = freezed,
    Object? dimmer = freezed,
    Object? colour = freezed,
    Object? units = freezed,
    Object? onTime = freezed,
    Object? cumulActivePwr = freezed,
    Object? pwrFactor = freezed,
  }) {
    return _then(_value.copyWith(
      onOff: onOff == freezed
          ? _value.onOff
          : onOff // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      dimmer: dimmer == freezed
          ? _value.dimmer
          : dimmer // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      colour: colour == freezed
          ? _value.colour
          : colour // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      onTime: onTime == freezed
          ? _value.onTime
          : onTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      cumulActivePwr: cumulActivePwr == freezed
          ? _value.cumulActivePwr
          : cumulActivePwr // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      pwrFactor: pwrFactor == freezed
          ? _value.pwrFactor
          : pwrFactor // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get onOff {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.onOff, (value) {
      return _then(_value.copyWith(onOff: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dimmer {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.dimmer, (value) {
      return _then(_value.copyWith(dimmer: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get colour {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.colour, (value) {
      return _then(_value.copyWith(colour: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get units {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.units, (value) {
      return _then(_value.copyWith(units: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get onTime {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.onTime, (value) {
      return _then(_value.copyWith(onTime: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get cumulActivePwr {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.cumulActivePwr, (value) {
      return _then(_value.copyWith(cumulActivePwr: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get pwrFactor {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.pwrFactor, (value) {
      return _then(_value.copyWith(pwrFactor: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharLightCtrlCopyWith<$Res>
    implements $SpecificResrcCharLightCtrlCopyWith<$Res> {
  factory _$SpecificResrcCharLightCtrlCopyWith(
          _SpecificResrcCharLightCtrl value,
          $Res Function(_SpecificResrcCharLightCtrl) then) =
      __$SpecificResrcCharLightCtrlCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl onOff,
      InstanceAndOpsCtrl dimmer,
      InstanceAndOpsCtrl colour,
      InstanceAndOpsCtrl units,
      InstanceAndOpsCtrl onTime,
      InstanceAndOpsCtrl cumulActivePwr,
      InstanceAndOpsCtrl pwrFactor});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get onOff;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dimmer;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get colour;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get units;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get onTime;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get cumulActivePwr;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get pwrFactor;
}

/// @nodoc
class __$SpecificResrcCharLightCtrlCopyWithImpl<$Res>
    extends _$SpecificResrcCharLightCtrlCopyWithImpl<$Res>
    implements _$SpecificResrcCharLightCtrlCopyWith<$Res> {
  __$SpecificResrcCharLightCtrlCopyWithImpl(_SpecificResrcCharLightCtrl _value,
      $Res Function(_SpecificResrcCharLightCtrl) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharLightCtrl));

  @override
  _SpecificResrcCharLightCtrl get _value =>
      super._value as _SpecificResrcCharLightCtrl;

  @override
  $Res call({
    Object? onOff = freezed,
    Object? dimmer = freezed,
    Object? colour = freezed,
    Object? units = freezed,
    Object? onTime = freezed,
    Object? cumulActivePwr = freezed,
    Object? pwrFactor = freezed,
  }) {
    return _then(_SpecificResrcCharLightCtrl(
      onOff: onOff == freezed
          ? _value.onOff
          : onOff // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      dimmer: dimmer == freezed
          ? _value.dimmer
          : dimmer // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      colour: colour == freezed
          ? _value.colour
          : colour // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      onTime: onTime == freezed
          ? _value.onTime
          : onTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      cumulActivePwr: cumulActivePwr == freezed
          ? _value.cumulActivePwr
          : cumulActivePwr // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      pwrFactor: pwrFactor == freezed
          ? _value.pwrFactor
          : pwrFactor // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharLightCtrl implements _SpecificResrcCharLightCtrl {
  const _$_SpecificResrcCharLightCtrl(
      {required this.onOff,
      required this.dimmer,
      required this.colour,
      required this.units,
      required this.onTime,
      required this.cumulActivePwr,
      required this.pwrFactor});

  factory _$_SpecificResrcCharLightCtrl.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharLightCtrlFromJson(json);

  @override
  final InstanceAndOpsCtrl onOff;
  @override
  final InstanceAndOpsCtrl dimmer;
  @override
  final InstanceAndOpsCtrl colour;
  @override
  final InstanceAndOpsCtrl units;
  @override
  final InstanceAndOpsCtrl onTime;
  @override
  final InstanceAndOpsCtrl cumulActivePwr;
  @override
  final InstanceAndOpsCtrl pwrFactor;

  @override
  String toString() {
    return 'SpecificResrcCharLightCtrl(onOff: $onOff, dimmer: $dimmer, colour: $colour, units: $units, onTime: $onTime, cumulActivePwr: $cumulActivePwr, pwrFactor: $pwrFactor)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharLightCtrl &&
            (identical(other.onOff, onOff) ||
                const DeepCollectionEquality().equals(other.onOff, onOff)) &&
            (identical(other.dimmer, dimmer) ||
                const DeepCollectionEquality().equals(other.dimmer, dimmer)) &&
            (identical(other.colour, colour) ||
                const DeepCollectionEquality().equals(other.colour, colour)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.onTime, onTime) ||
                const DeepCollectionEquality().equals(other.onTime, onTime)) &&
            (identical(other.cumulActivePwr, cumulActivePwr) ||
                const DeepCollectionEquality()
                    .equals(other.cumulActivePwr, cumulActivePwr)) &&
            (identical(other.pwrFactor, pwrFactor) ||
                const DeepCollectionEquality()
                    .equals(other.pwrFactor, pwrFactor)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(onOff) ^
      const DeepCollectionEquality().hash(dimmer) ^
      const DeepCollectionEquality().hash(colour) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(onTime) ^
      const DeepCollectionEquality().hash(cumulActivePwr) ^
      const DeepCollectionEquality().hash(pwrFactor);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharLightCtrlCopyWith<_SpecificResrcCharLightCtrl>
      get copyWith => __$SpecificResrcCharLightCtrlCopyWithImpl<
          _SpecificResrcCharLightCtrl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharLightCtrlToJson(this);
  }
}

abstract class _SpecificResrcCharLightCtrl
    implements SpecificResrcCharLightCtrl {
  const factory _SpecificResrcCharLightCtrl(
      {required InstanceAndOpsCtrl onOff,
      required InstanceAndOpsCtrl dimmer,
      required InstanceAndOpsCtrl colour,
      required InstanceAndOpsCtrl units,
      required InstanceAndOpsCtrl onTime,
      required InstanceAndOpsCtrl cumulActivePwr,
      required InstanceAndOpsCtrl pwrFactor}) = _$_SpecificResrcCharLightCtrl;

  factory _SpecificResrcCharLightCtrl.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharLightCtrl.fromJson;

  @override
  InstanceAndOpsCtrl get onOff => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get dimmer => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get colour => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get units => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get onTime => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get cumulActivePwr => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get pwrFactor => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharLightCtrlCopyWith<_SpecificResrcCharLightCtrl>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharLoadCtrl _$SpecificResrcCharLoadCtrlFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharLoadCtrl.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharLoadCtrlTearOff {
  const _$SpecificResrcCharLoadCtrlTearOff();

  _SpecificResrcCharLoadCtrl call(
      {required InstanceAndOpsCtrl eventId,
      required InstanceAndOpsCtrl startTime,
      required InstanceAndOpsCtrl durationInMin,
      required InstanceAndOpsCtrl criticalLevel,
      required InstanceAndOpsCtrl avgLoadAdjPct,
      required InstanceAndOpsCtrl dutyCycle}) {
    return _SpecificResrcCharLoadCtrl(
      eventId: eventId,
      startTime: startTime,
      durationInMin: durationInMin,
      criticalLevel: criticalLevel,
      avgLoadAdjPct: avgLoadAdjPct,
      dutyCycle: dutyCycle,
    );
  }

  SpecificResrcCharLoadCtrl fromJson(Map<String, Object> json) {
    return SpecificResrcCharLoadCtrl.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharLoadCtrl = _$SpecificResrcCharLoadCtrlTearOff();

/// @nodoc
mixin _$SpecificResrcCharLoadCtrl {
  InstanceAndOpsCtrl get eventId => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get startTime => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get durationInMin => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get criticalLevel => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get avgLoadAdjPct => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get dutyCycle => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharLoadCtrlCopyWith<SpecificResrcCharLoadCtrl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharLoadCtrlCopyWith<$Res> {
  factory $SpecificResrcCharLoadCtrlCopyWith(SpecificResrcCharLoadCtrl value,
          $Res Function(SpecificResrcCharLoadCtrl) then) =
      _$SpecificResrcCharLoadCtrlCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl eventId,
      InstanceAndOpsCtrl startTime,
      InstanceAndOpsCtrl durationInMin,
      InstanceAndOpsCtrl criticalLevel,
      InstanceAndOpsCtrl avgLoadAdjPct,
      InstanceAndOpsCtrl dutyCycle});

  $InstanceAndOpsCtrlCopyWith<$Res> get eventId;
  $InstanceAndOpsCtrlCopyWith<$Res> get startTime;
  $InstanceAndOpsCtrlCopyWith<$Res> get durationInMin;
  $InstanceAndOpsCtrlCopyWith<$Res> get criticalLevel;
  $InstanceAndOpsCtrlCopyWith<$Res> get avgLoadAdjPct;
  $InstanceAndOpsCtrlCopyWith<$Res> get dutyCycle;
}

/// @nodoc
class _$SpecificResrcCharLoadCtrlCopyWithImpl<$Res>
    implements $SpecificResrcCharLoadCtrlCopyWith<$Res> {
  _$SpecificResrcCharLoadCtrlCopyWithImpl(this._value, this._then);

  final SpecificResrcCharLoadCtrl _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharLoadCtrl) _then;

  @override
  $Res call({
    Object? eventId = freezed,
    Object? startTime = freezed,
    Object? durationInMin = freezed,
    Object? criticalLevel = freezed,
    Object? avgLoadAdjPct = freezed,
    Object? dutyCycle = freezed,
  }) {
    return _then(_value.copyWith(
      eventId: eventId == freezed
          ? _value.eventId
          : eventId // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      startTime: startTime == freezed
          ? _value.startTime
          : startTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      durationInMin: durationInMin == freezed
          ? _value.durationInMin
          : durationInMin // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      criticalLevel: criticalLevel == freezed
          ? _value.criticalLevel
          : criticalLevel // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      avgLoadAdjPct: avgLoadAdjPct == freezed
          ? _value.avgLoadAdjPct
          : avgLoadAdjPct // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      dutyCycle: dutyCycle == freezed
          ? _value.dutyCycle
          : dutyCycle // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get eventId {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.eventId, (value) {
      return _then(_value.copyWith(eventId: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get startTime {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.startTime, (value) {
      return _then(_value.copyWith(startTime: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get durationInMin {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.durationInMin, (value) {
      return _then(_value.copyWith(durationInMin: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get criticalLevel {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.criticalLevel, (value) {
      return _then(_value.copyWith(criticalLevel: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get avgLoadAdjPct {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.avgLoadAdjPct, (value) {
      return _then(_value.copyWith(avgLoadAdjPct: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dutyCycle {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.dutyCycle, (value) {
      return _then(_value.copyWith(dutyCycle: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharLoadCtrlCopyWith<$Res>
    implements $SpecificResrcCharLoadCtrlCopyWith<$Res> {
  factory _$SpecificResrcCharLoadCtrlCopyWith(_SpecificResrcCharLoadCtrl value,
          $Res Function(_SpecificResrcCharLoadCtrl) then) =
      __$SpecificResrcCharLoadCtrlCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl eventId,
      InstanceAndOpsCtrl startTime,
      InstanceAndOpsCtrl durationInMin,
      InstanceAndOpsCtrl criticalLevel,
      InstanceAndOpsCtrl avgLoadAdjPct,
      InstanceAndOpsCtrl dutyCycle});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get eventId;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get startTime;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get durationInMin;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get criticalLevel;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get avgLoadAdjPct;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dutyCycle;
}

/// @nodoc
class __$SpecificResrcCharLoadCtrlCopyWithImpl<$Res>
    extends _$SpecificResrcCharLoadCtrlCopyWithImpl<$Res>
    implements _$SpecificResrcCharLoadCtrlCopyWith<$Res> {
  __$SpecificResrcCharLoadCtrlCopyWithImpl(_SpecificResrcCharLoadCtrl _value,
      $Res Function(_SpecificResrcCharLoadCtrl) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharLoadCtrl));

  @override
  _SpecificResrcCharLoadCtrl get _value =>
      super._value as _SpecificResrcCharLoadCtrl;

  @override
  $Res call({
    Object? eventId = freezed,
    Object? startTime = freezed,
    Object? durationInMin = freezed,
    Object? criticalLevel = freezed,
    Object? avgLoadAdjPct = freezed,
    Object? dutyCycle = freezed,
  }) {
    return _then(_SpecificResrcCharLoadCtrl(
      eventId: eventId == freezed
          ? _value.eventId
          : eventId // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      startTime: startTime == freezed
          ? _value.startTime
          : startTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      durationInMin: durationInMin == freezed
          ? _value.durationInMin
          : durationInMin // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      criticalLevel: criticalLevel == freezed
          ? _value.criticalLevel
          : criticalLevel // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      avgLoadAdjPct: avgLoadAdjPct == freezed
          ? _value.avgLoadAdjPct
          : avgLoadAdjPct // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      dutyCycle: dutyCycle == freezed
          ? _value.dutyCycle
          : dutyCycle // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharLoadCtrl implements _SpecificResrcCharLoadCtrl {
  const _$_SpecificResrcCharLoadCtrl(
      {required this.eventId,
      required this.startTime,
      required this.durationInMin,
      required this.criticalLevel,
      required this.avgLoadAdjPct,
      required this.dutyCycle});

  factory _$_SpecificResrcCharLoadCtrl.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharLoadCtrlFromJson(json);

  @override
  final InstanceAndOpsCtrl eventId;
  @override
  final InstanceAndOpsCtrl startTime;
  @override
  final InstanceAndOpsCtrl durationInMin;
  @override
  final InstanceAndOpsCtrl criticalLevel;
  @override
  final InstanceAndOpsCtrl avgLoadAdjPct;
  @override
  final InstanceAndOpsCtrl dutyCycle;

  @override
  String toString() {
    return 'SpecificResrcCharLoadCtrl(eventId: $eventId, startTime: $startTime, durationInMin: $durationInMin, criticalLevel: $criticalLevel, avgLoadAdjPct: $avgLoadAdjPct, dutyCycle: $dutyCycle)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharLoadCtrl &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality()
                    .equals(other.eventId, eventId)) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality()
                    .equals(other.startTime, startTime)) &&
            (identical(other.durationInMin, durationInMin) ||
                const DeepCollectionEquality()
                    .equals(other.durationInMin, durationInMin)) &&
            (identical(other.criticalLevel, criticalLevel) ||
                const DeepCollectionEquality()
                    .equals(other.criticalLevel, criticalLevel)) &&
            (identical(other.avgLoadAdjPct, avgLoadAdjPct) ||
                const DeepCollectionEquality()
                    .equals(other.avgLoadAdjPct, avgLoadAdjPct)) &&
            (identical(other.dutyCycle, dutyCycle) ||
                const DeepCollectionEquality()
                    .equals(other.dutyCycle, dutyCycle)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(durationInMin) ^
      const DeepCollectionEquality().hash(criticalLevel) ^
      const DeepCollectionEquality().hash(avgLoadAdjPct) ^
      const DeepCollectionEquality().hash(dutyCycle);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharLoadCtrlCopyWith<_SpecificResrcCharLoadCtrl>
      get copyWith =>
          __$SpecificResrcCharLoadCtrlCopyWithImpl<_SpecificResrcCharLoadCtrl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharLoadCtrlToJson(this);
  }
}

abstract class _SpecificResrcCharLoadCtrl implements SpecificResrcCharLoadCtrl {
  const factory _SpecificResrcCharLoadCtrl(
      {required InstanceAndOpsCtrl eventId,
      required InstanceAndOpsCtrl startTime,
      required InstanceAndOpsCtrl durationInMin,
      required InstanceAndOpsCtrl criticalLevel,
      required InstanceAndOpsCtrl avgLoadAdjPct,
      required InstanceAndOpsCtrl dutyCycle}) = _$_SpecificResrcCharLoadCtrl;

  factory _SpecificResrcCharLoadCtrl.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharLoadCtrl.fromJson;

  @override
  InstanceAndOpsCtrl get eventId => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get startTime => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get durationInMin => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get criticalLevel => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get avgLoadAdjPct => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get dutyCycle => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharLoadCtrlCopyWith<_SpecificResrcCharLoadCtrl>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharLocation _$SpecificResrcCharLocationFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharLocation.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharLocationTearOff {
  const _$SpecificResrcCharLocationTearOff();

  _SpecificResrcCharLocation call(
      {required InstanceAndOpsCtrl lat,
      required InstanceAndOpsCtrl lon,
      required InstanceAndOpsCtrl alt,
      required InstanceAndOpsCtrl radius,
      required InstanceAndOpsCtrl velocity,
      required InstanceAndOpsCtrl timestamp,
      required InstanceAndOpsCtrl speed}) {
    return _SpecificResrcCharLocation(
      lat: lat,
      lon: lon,
      alt: alt,
      radius: radius,
      velocity: velocity,
      timestamp: timestamp,
      speed: speed,
    );
  }

  SpecificResrcCharLocation fromJson(Map<String, Object> json) {
    return SpecificResrcCharLocation.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharLocation = _$SpecificResrcCharLocationTearOff();

/// @nodoc
mixin _$SpecificResrcCharLocation {
  InstanceAndOpsCtrl get lat => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get lon => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get alt => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get radius => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get velocity => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get timestamp => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get speed => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharLocationCopyWith<SpecificResrcCharLocation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharLocationCopyWith<$Res> {
  factory $SpecificResrcCharLocationCopyWith(SpecificResrcCharLocation value,
          $Res Function(SpecificResrcCharLocation) then) =
      _$SpecificResrcCharLocationCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl lat,
      InstanceAndOpsCtrl lon,
      InstanceAndOpsCtrl alt,
      InstanceAndOpsCtrl radius,
      InstanceAndOpsCtrl velocity,
      InstanceAndOpsCtrl timestamp,
      InstanceAndOpsCtrl speed});

  $InstanceAndOpsCtrlCopyWith<$Res> get lat;
  $InstanceAndOpsCtrlCopyWith<$Res> get lon;
  $InstanceAndOpsCtrlCopyWith<$Res> get alt;
  $InstanceAndOpsCtrlCopyWith<$Res> get radius;
  $InstanceAndOpsCtrlCopyWith<$Res> get velocity;
  $InstanceAndOpsCtrlCopyWith<$Res> get timestamp;
  $InstanceAndOpsCtrlCopyWith<$Res> get speed;
}

/// @nodoc
class _$SpecificResrcCharLocationCopyWithImpl<$Res>
    implements $SpecificResrcCharLocationCopyWith<$Res> {
  _$SpecificResrcCharLocationCopyWithImpl(this._value, this._then);

  final SpecificResrcCharLocation _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharLocation) _then;

  @override
  $Res call({
    Object? lat = freezed,
    Object? lon = freezed,
    Object? alt = freezed,
    Object? radius = freezed,
    Object? velocity = freezed,
    Object? timestamp = freezed,
    Object? speed = freezed,
  }) {
    return _then(_value.copyWith(
      lat: lat == freezed
          ? _value.lat
          : lat // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      lon: lon == freezed
          ? _value.lon
          : lon // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      alt: alt == freezed
          ? _value.alt
          : alt // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      radius: radius == freezed
          ? _value.radius
          : radius // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      velocity: velocity == freezed
          ? _value.velocity
          : velocity // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      timestamp: timestamp == freezed
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      speed: speed == freezed
          ? _value.speed
          : speed // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get lat {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.lat, (value) {
      return _then(_value.copyWith(lat: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get lon {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.lon, (value) {
      return _then(_value.copyWith(lon: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get alt {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.alt, (value) {
      return _then(_value.copyWith(alt: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get radius {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.radius, (value) {
      return _then(_value.copyWith(radius: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get velocity {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.velocity, (value) {
      return _then(_value.copyWith(velocity: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get timestamp {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.timestamp, (value) {
      return _then(_value.copyWith(timestamp: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get speed {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.speed, (value) {
      return _then(_value.copyWith(speed: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharLocationCopyWith<$Res>
    implements $SpecificResrcCharLocationCopyWith<$Res> {
  factory _$SpecificResrcCharLocationCopyWith(_SpecificResrcCharLocation value,
          $Res Function(_SpecificResrcCharLocation) then) =
      __$SpecificResrcCharLocationCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl lat,
      InstanceAndOpsCtrl lon,
      InstanceAndOpsCtrl alt,
      InstanceAndOpsCtrl radius,
      InstanceAndOpsCtrl velocity,
      InstanceAndOpsCtrl timestamp,
      InstanceAndOpsCtrl speed});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get lat;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get lon;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get alt;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get radius;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get velocity;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get timestamp;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get speed;
}

/// @nodoc
class __$SpecificResrcCharLocationCopyWithImpl<$Res>
    extends _$SpecificResrcCharLocationCopyWithImpl<$Res>
    implements _$SpecificResrcCharLocationCopyWith<$Res> {
  __$SpecificResrcCharLocationCopyWithImpl(_SpecificResrcCharLocation _value,
      $Res Function(_SpecificResrcCharLocation) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharLocation));

  @override
  _SpecificResrcCharLocation get _value =>
      super._value as _SpecificResrcCharLocation;

  @override
  $Res call({
    Object? lat = freezed,
    Object? lon = freezed,
    Object? alt = freezed,
    Object? radius = freezed,
    Object? velocity = freezed,
    Object? timestamp = freezed,
    Object? speed = freezed,
  }) {
    return _then(_SpecificResrcCharLocation(
      lat: lat == freezed
          ? _value.lat
          : lat // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      lon: lon == freezed
          ? _value.lon
          : lon // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      alt: alt == freezed
          ? _value.alt
          : alt // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      radius: radius == freezed
          ? _value.radius
          : radius // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      velocity: velocity == freezed
          ? _value.velocity
          : velocity // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      timestamp: timestamp == freezed
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      speed: speed == freezed
          ? _value.speed
          : speed // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharLocation implements _SpecificResrcCharLocation {
  const _$_SpecificResrcCharLocation(
      {required this.lat,
      required this.lon,
      required this.alt,
      required this.radius,
      required this.velocity,
      required this.timestamp,
      required this.speed});

  factory _$_SpecificResrcCharLocation.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharLocationFromJson(json);

  @override
  final InstanceAndOpsCtrl lat;
  @override
  final InstanceAndOpsCtrl lon;
  @override
  final InstanceAndOpsCtrl alt;
  @override
  final InstanceAndOpsCtrl radius;
  @override
  final InstanceAndOpsCtrl velocity;
  @override
  final InstanceAndOpsCtrl timestamp;
  @override
  final InstanceAndOpsCtrl speed;

  @override
  String toString() {
    return 'SpecificResrcCharLocation(lat: $lat, lon: $lon, alt: $alt, radius: $radius, velocity: $velocity, timestamp: $timestamp, speed: $speed)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharLocation &&
            (identical(other.lat, lat) ||
                const DeepCollectionEquality().equals(other.lat, lat)) &&
            (identical(other.lon, lon) ||
                const DeepCollectionEquality().equals(other.lon, lon)) &&
            (identical(other.alt, alt) ||
                const DeepCollectionEquality().equals(other.alt, alt)) &&
            (identical(other.radius, radius) ||
                const DeepCollectionEquality().equals(other.radius, radius)) &&
            (identical(other.velocity, velocity) ||
                const DeepCollectionEquality()
                    .equals(other.velocity, velocity)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality()
                    .equals(other.timestamp, timestamp)) &&
            (identical(other.speed, speed) ||
                const DeepCollectionEquality().equals(other.speed, speed)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(lat) ^
      const DeepCollectionEquality().hash(lon) ^
      const DeepCollectionEquality().hash(alt) ^
      const DeepCollectionEquality().hash(radius) ^
      const DeepCollectionEquality().hash(velocity) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(speed);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharLocationCopyWith<_SpecificResrcCharLocation>
      get copyWith =>
          __$SpecificResrcCharLocationCopyWithImpl<_SpecificResrcCharLocation>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharLocationToJson(this);
  }
}

abstract class _SpecificResrcCharLocation implements SpecificResrcCharLocation {
  const factory _SpecificResrcCharLocation(
      {required InstanceAndOpsCtrl lat,
      required InstanceAndOpsCtrl lon,
      required InstanceAndOpsCtrl alt,
      required InstanceAndOpsCtrl radius,
      required InstanceAndOpsCtrl velocity,
      required InstanceAndOpsCtrl timestamp,
      required InstanceAndOpsCtrl speed}) = _$_SpecificResrcCharLocation;

  factory _SpecificResrcCharLocation.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharLocation.fromJson;

  @override
  InstanceAndOpsCtrl get lat => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get lon => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get alt => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get radius => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get velocity => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get timestamp => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get speed => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharLocationCopyWith<_SpecificResrcCharLocation>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharLwm2mSecurity _$SpecificResrcCharLwm2mSecurityFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharLwm2mSecurity.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharLwm2mSecurityTearOff {
  const _$SpecificResrcCharLwm2mSecurityTearOff();

  _SpecificResrcCharLwm2mSecurity call(
      {@JsonKey(name: 'lwm2mServerURI')
          required InstanceAndOpsCtrl lwm2mServerUri,
      required InstanceAndOpsCtrl bootstrapServer,
      required InstanceAndOpsCtrl securityMode,
      required InstanceAndOpsCtrl pubKeyId,
      required InstanceAndOpsCtrl serverPubKeyId,
      required InstanceAndOpsCtrl secretKey,
      required InstanceAndOpsCtrl smsSecurityMode,
      required InstanceAndOpsCtrl smsBindingKeyParam,
      required InstanceAndOpsCtrl smsBindingSecretKey,
      required InstanceAndOpsCtrl lwm2mServerSmsNum,
      required InstanceAndOpsCtrl shortServerId,
      required InstanceAndOpsCtrl clientHoldOffTime}) {
    return _SpecificResrcCharLwm2mSecurity(
      lwm2mServerUri: lwm2mServerUri,
      bootstrapServer: bootstrapServer,
      securityMode: securityMode,
      pubKeyId: pubKeyId,
      serverPubKeyId: serverPubKeyId,
      secretKey: secretKey,
      smsSecurityMode: smsSecurityMode,
      smsBindingKeyParam: smsBindingKeyParam,
      smsBindingSecretKey: smsBindingSecretKey,
      lwm2mServerSmsNum: lwm2mServerSmsNum,
      shortServerId: shortServerId,
      clientHoldOffTime: clientHoldOffTime,
    );
  }

  SpecificResrcCharLwm2mSecurity fromJson(Map<String, Object> json) {
    return SpecificResrcCharLwm2mSecurity.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharLwm2mSecurity =
    _$SpecificResrcCharLwm2mSecurityTearOff();

/// @nodoc
mixin _$SpecificResrcCharLwm2mSecurity {
  @JsonKey(name: 'lwm2mServerURI')
  InstanceAndOpsCtrl get lwm2mServerUri => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get bootstrapServer => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get securityMode => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get pubKeyId => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get serverPubKeyId => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get secretKey => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get smsSecurityMode => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get smsBindingKeyParam =>
      throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get smsBindingSecretKey =>
      throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get lwm2mServerSmsNum =>
      throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get shortServerId => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get clientHoldOffTime =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharLwm2mSecurityCopyWith<SpecificResrcCharLwm2mSecurity>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharLwm2mSecurityCopyWith<$Res> {
  factory $SpecificResrcCharLwm2mSecurityCopyWith(
          SpecificResrcCharLwm2mSecurity value,
          $Res Function(SpecificResrcCharLwm2mSecurity) then) =
      _$SpecificResrcCharLwm2mSecurityCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(name: 'lwm2mServerURI') InstanceAndOpsCtrl lwm2mServerUri,
      InstanceAndOpsCtrl bootstrapServer,
      InstanceAndOpsCtrl securityMode,
      InstanceAndOpsCtrl pubKeyId,
      InstanceAndOpsCtrl serverPubKeyId,
      InstanceAndOpsCtrl secretKey,
      InstanceAndOpsCtrl smsSecurityMode,
      InstanceAndOpsCtrl smsBindingKeyParam,
      InstanceAndOpsCtrl smsBindingSecretKey,
      InstanceAndOpsCtrl lwm2mServerSmsNum,
      InstanceAndOpsCtrl shortServerId,
      InstanceAndOpsCtrl clientHoldOffTime});

  $InstanceAndOpsCtrlCopyWith<$Res> get lwm2mServerUri;
  $InstanceAndOpsCtrlCopyWith<$Res> get bootstrapServer;
  $InstanceAndOpsCtrlCopyWith<$Res> get securityMode;
  $InstanceAndOpsCtrlCopyWith<$Res> get pubKeyId;
  $InstanceAndOpsCtrlCopyWith<$Res> get serverPubKeyId;
  $InstanceAndOpsCtrlCopyWith<$Res> get secretKey;
  $InstanceAndOpsCtrlCopyWith<$Res> get smsSecurityMode;
  $InstanceAndOpsCtrlCopyWith<$Res> get smsBindingKeyParam;
  $InstanceAndOpsCtrlCopyWith<$Res> get smsBindingSecretKey;
  $InstanceAndOpsCtrlCopyWith<$Res> get lwm2mServerSmsNum;
  $InstanceAndOpsCtrlCopyWith<$Res> get shortServerId;
  $InstanceAndOpsCtrlCopyWith<$Res> get clientHoldOffTime;
}

/// @nodoc
class _$SpecificResrcCharLwm2mSecurityCopyWithImpl<$Res>
    implements $SpecificResrcCharLwm2mSecurityCopyWith<$Res> {
  _$SpecificResrcCharLwm2mSecurityCopyWithImpl(this._value, this._then);

  final SpecificResrcCharLwm2mSecurity _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharLwm2mSecurity) _then;

  @override
  $Res call({
    Object? lwm2mServerUri = freezed,
    Object? bootstrapServer = freezed,
    Object? securityMode = freezed,
    Object? pubKeyId = freezed,
    Object? serverPubKeyId = freezed,
    Object? secretKey = freezed,
    Object? smsSecurityMode = freezed,
    Object? smsBindingKeyParam = freezed,
    Object? smsBindingSecretKey = freezed,
    Object? lwm2mServerSmsNum = freezed,
    Object? shortServerId = freezed,
    Object? clientHoldOffTime = freezed,
  }) {
    return _then(_value.copyWith(
      lwm2mServerUri: lwm2mServerUri == freezed
          ? _value.lwm2mServerUri
          : lwm2mServerUri // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      bootstrapServer: bootstrapServer == freezed
          ? _value.bootstrapServer
          : bootstrapServer // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      securityMode: securityMode == freezed
          ? _value.securityMode
          : securityMode // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      pubKeyId: pubKeyId == freezed
          ? _value.pubKeyId
          : pubKeyId // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      serverPubKeyId: serverPubKeyId == freezed
          ? _value.serverPubKeyId
          : serverPubKeyId // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      secretKey: secretKey == freezed
          ? _value.secretKey
          : secretKey // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      smsSecurityMode: smsSecurityMode == freezed
          ? _value.smsSecurityMode
          : smsSecurityMode // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      smsBindingKeyParam: smsBindingKeyParam == freezed
          ? _value.smsBindingKeyParam
          : smsBindingKeyParam // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      smsBindingSecretKey: smsBindingSecretKey == freezed
          ? _value.smsBindingSecretKey
          : smsBindingSecretKey // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      lwm2mServerSmsNum: lwm2mServerSmsNum == freezed
          ? _value.lwm2mServerSmsNum
          : lwm2mServerSmsNum // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      shortServerId: shortServerId == freezed
          ? _value.shortServerId
          : shortServerId // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      clientHoldOffTime: clientHoldOffTime == freezed
          ? _value.clientHoldOffTime
          : clientHoldOffTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get lwm2mServerUri {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.lwm2mServerUri, (value) {
      return _then(_value.copyWith(lwm2mServerUri: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get bootstrapServer {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.bootstrapServer, (value) {
      return _then(_value.copyWith(bootstrapServer: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get securityMode {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.securityMode, (value) {
      return _then(_value.copyWith(securityMode: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get pubKeyId {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.pubKeyId, (value) {
      return _then(_value.copyWith(pubKeyId: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get serverPubKeyId {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.serverPubKeyId, (value) {
      return _then(_value.copyWith(serverPubKeyId: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get secretKey {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.secretKey, (value) {
      return _then(_value.copyWith(secretKey: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get smsSecurityMode {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.smsSecurityMode, (value) {
      return _then(_value.copyWith(smsSecurityMode: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get smsBindingKeyParam {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.smsBindingKeyParam,
        (value) {
      return _then(_value.copyWith(smsBindingKeyParam: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get smsBindingSecretKey {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.smsBindingSecretKey,
        (value) {
      return _then(_value.copyWith(smsBindingSecretKey: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get lwm2mServerSmsNum {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.lwm2mServerSmsNum, (value) {
      return _then(_value.copyWith(lwm2mServerSmsNum: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get shortServerId {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.shortServerId, (value) {
      return _then(_value.copyWith(shortServerId: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get clientHoldOffTime {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.clientHoldOffTime, (value) {
      return _then(_value.copyWith(clientHoldOffTime: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharLwm2mSecurityCopyWith<$Res>
    implements $SpecificResrcCharLwm2mSecurityCopyWith<$Res> {
  factory _$SpecificResrcCharLwm2mSecurityCopyWith(
          _SpecificResrcCharLwm2mSecurity value,
          $Res Function(_SpecificResrcCharLwm2mSecurity) then) =
      __$SpecificResrcCharLwm2mSecurityCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(name: 'lwm2mServerURI') InstanceAndOpsCtrl lwm2mServerUri,
      InstanceAndOpsCtrl bootstrapServer,
      InstanceAndOpsCtrl securityMode,
      InstanceAndOpsCtrl pubKeyId,
      InstanceAndOpsCtrl serverPubKeyId,
      InstanceAndOpsCtrl secretKey,
      InstanceAndOpsCtrl smsSecurityMode,
      InstanceAndOpsCtrl smsBindingKeyParam,
      InstanceAndOpsCtrl smsBindingSecretKey,
      InstanceAndOpsCtrl lwm2mServerSmsNum,
      InstanceAndOpsCtrl shortServerId,
      InstanceAndOpsCtrl clientHoldOffTime});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get lwm2mServerUri;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get bootstrapServer;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get securityMode;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get pubKeyId;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get serverPubKeyId;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get secretKey;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get smsSecurityMode;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get smsBindingKeyParam;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get smsBindingSecretKey;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get lwm2mServerSmsNum;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get shortServerId;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get clientHoldOffTime;
}

/// @nodoc
class __$SpecificResrcCharLwm2mSecurityCopyWithImpl<$Res>
    extends _$SpecificResrcCharLwm2mSecurityCopyWithImpl<$Res>
    implements _$SpecificResrcCharLwm2mSecurityCopyWith<$Res> {
  __$SpecificResrcCharLwm2mSecurityCopyWithImpl(
      _SpecificResrcCharLwm2mSecurity _value,
      $Res Function(_SpecificResrcCharLwm2mSecurity) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharLwm2mSecurity));

  @override
  _SpecificResrcCharLwm2mSecurity get _value =>
      super._value as _SpecificResrcCharLwm2mSecurity;

  @override
  $Res call({
    Object? lwm2mServerUri = freezed,
    Object? bootstrapServer = freezed,
    Object? securityMode = freezed,
    Object? pubKeyId = freezed,
    Object? serverPubKeyId = freezed,
    Object? secretKey = freezed,
    Object? smsSecurityMode = freezed,
    Object? smsBindingKeyParam = freezed,
    Object? smsBindingSecretKey = freezed,
    Object? lwm2mServerSmsNum = freezed,
    Object? shortServerId = freezed,
    Object? clientHoldOffTime = freezed,
  }) {
    return _then(_SpecificResrcCharLwm2mSecurity(
      lwm2mServerUri: lwm2mServerUri == freezed
          ? _value.lwm2mServerUri
          : lwm2mServerUri // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      bootstrapServer: bootstrapServer == freezed
          ? _value.bootstrapServer
          : bootstrapServer // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      securityMode: securityMode == freezed
          ? _value.securityMode
          : securityMode // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      pubKeyId: pubKeyId == freezed
          ? _value.pubKeyId
          : pubKeyId // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      serverPubKeyId: serverPubKeyId == freezed
          ? _value.serverPubKeyId
          : serverPubKeyId // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      secretKey: secretKey == freezed
          ? _value.secretKey
          : secretKey // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      smsSecurityMode: smsSecurityMode == freezed
          ? _value.smsSecurityMode
          : smsSecurityMode // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      smsBindingKeyParam: smsBindingKeyParam == freezed
          ? _value.smsBindingKeyParam
          : smsBindingKeyParam // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      smsBindingSecretKey: smsBindingSecretKey == freezed
          ? _value.smsBindingSecretKey
          : smsBindingSecretKey // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      lwm2mServerSmsNum: lwm2mServerSmsNum == freezed
          ? _value.lwm2mServerSmsNum
          : lwm2mServerSmsNum // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      shortServerId: shortServerId == freezed
          ? _value.shortServerId
          : shortServerId // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      clientHoldOffTime: clientHoldOffTime == freezed
          ? _value.clientHoldOffTime
          : clientHoldOffTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharLwm2mSecurity
    implements _SpecificResrcCharLwm2mSecurity {
  _$_SpecificResrcCharLwm2mSecurity(
      {@JsonKey(name: 'lwm2mServerURI') required this.lwm2mServerUri,
      required this.bootstrapServer,
      required this.securityMode,
      required this.pubKeyId,
      required this.serverPubKeyId,
      required this.secretKey,
      required this.smsSecurityMode,
      required this.smsBindingKeyParam,
      required this.smsBindingSecretKey,
      required this.lwm2mServerSmsNum,
      required this.shortServerId,
      required this.clientHoldOffTime});

  factory _$_SpecificResrcCharLwm2mSecurity.fromJson(
          Map<String, dynamic> json) =>
      _$$_SpecificResrcCharLwm2mSecurityFromJson(json);

  @override
  @JsonKey(name: 'lwm2mServerURI')
  final InstanceAndOpsCtrl lwm2mServerUri;
  @override
  final InstanceAndOpsCtrl bootstrapServer;
  @override
  final InstanceAndOpsCtrl securityMode;
  @override
  final InstanceAndOpsCtrl pubKeyId;
  @override
  final InstanceAndOpsCtrl serverPubKeyId;
  @override
  final InstanceAndOpsCtrl secretKey;
  @override
  final InstanceAndOpsCtrl smsSecurityMode;
  @override
  final InstanceAndOpsCtrl smsBindingKeyParam;
  @override
  final InstanceAndOpsCtrl smsBindingSecretKey;
  @override
  final InstanceAndOpsCtrl lwm2mServerSmsNum;
  @override
  final InstanceAndOpsCtrl shortServerId;
  @override
  final InstanceAndOpsCtrl clientHoldOffTime;

  @override
  String toString() {
    return 'SpecificResrcCharLwm2mSecurity(lwm2mServerUri: $lwm2mServerUri, bootstrapServer: $bootstrapServer, securityMode: $securityMode, pubKeyId: $pubKeyId, serverPubKeyId: $serverPubKeyId, secretKey: $secretKey, smsSecurityMode: $smsSecurityMode, smsBindingKeyParam: $smsBindingKeyParam, smsBindingSecretKey: $smsBindingSecretKey, lwm2mServerSmsNum: $lwm2mServerSmsNum, shortServerId: $shortServerId, clientHoldOffTime: $clientHoldOffTime)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharLwm2mSecurity &&
            (identical(other.lwm2mServerUri, lwm2mServerUri) ||
                const DeepCollectionEquality()
                    .equals(other.lwm2mServerUri, lwm2mServerUri)) &&
            (identical(other.bootstrapServer, bootstrapServer) ||
                const DeepCollectionEquality()
                    .equals(other.bootstrapServer, bootstrapServer)) &&
            (identical(other.securityMode, securityMode) ||
                const DeepCollectionEquality()
                    .equals(other.securityMode, securityMode)) &&
            (identical(other.pubKeyId, pubKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.pubKeyId, pubKeyId)) &&
            (identical(other.serverPubKeyId, serverPubKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.serverPubKeyId, serverPubKeyId)) &&
            (identical(other.secretKey, secretKey) ||
                const DeepCollectionEquality()
                    .equals(other.secretKey, secretKey)) &&
            (identical(other.smsSecurityMode, smsSecurityMode) ||
                const DeepCollectionEquality()
                    .equals(other.smsSecurityMode, smsSecurityMode)) &&
            (identical(other.smsBindingKeyParam, smsBindingKeyParam) ||
                const DeepCollectionEquality()
                    .equals(other.smsBindingKeyParam, smsBindingKeyParam)) &&
            (identical(other.smsBindingSecretKey, smsBindingSecretKey) ||
                const DeepCollectionEquality()
                    .equals(other.smsBindingSecretKey, smsBindingSecretKey)) &&
            (identical(other.lwm2mServerSmsNum, lwm2mServerSmsNum) ||
                const DeepCollectionEquality()
                    .equals(other.lwm2mServerSmsNum, lwm2mServerSmsNum)) &&
            (identical(other.shortServerId, shortServerId) ||
                const DeepCollectionEquality()
                    .equals(other.shortServerId, shortServerId)) &&
            (identical(other.clientHoldOffTime, clientHoldOffTime) ||
                const DeepCollectionEquality()
                    .equals(other.clientHoldOffTime, clientHoldOffTime)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(lwm2mServerUri) ^
      const DeepCollectionEquality().hash(bootstrapServer) ^
      const DeepCollectionEquality().hash(securityMode) ^
      const DeepCollectionEquality().hash(pubKeyId) ^
      const DeepCollectionEquality().hash(serverPubKeyId) ^
      const DeepCollectionEquality().hash(secretKey) ^
      const DeepCollectionEquality().hash(smsSecurityMode) ^
      const DeepCollectionEquality().hash(smsBindingKeyParam) ^
      const DeepCollectionEquality().hash(smsBindingSecretKey) ^
      const DeepCollectionEquality().hash(lwm2mServerSmsNum) ^
      const DeepCollectionEquality().hash(shortServerId) ^
      const DeepCollectionEquality().hash(clientHoldOffTime);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharLwm2mSecurityCopyWith<_SpecificResrcCharLwm2mSecurity>
      get copyWith => __$SpecificResrcCharLwm2mSecurityCopyWithImpl<
          _SpecificResrcCharLwm2mSecurity>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharLwm2mSecurityToJson(this);
  }
}

abstract class _SpecificResrcCharLwm2mSecurity
    implements SpecificResrcCharLwm2mSecurity {
  factory _SpecificResrcCharLwm2mSecurity(
          {@JsonKey(name: 'lwm2mServerURI')
              required InstanceAndOpsCtrl lwm2mServerUri,
          required InstanceAndOpsCtrl bootstrapServer,
          required InstanceAndOpsCtrl securityMode,
          required InstanceAndOpsCtrl pubKeyId,
          required InstanceAndOpsCtrl serverPubKeyId,
          required InstanceAndOpsCtrl secretKey,
          required InstanceAndOpsCtrl smsSecurityMode,
          required InstanceAndOpsCtrl smsBindingKeyParam,
          required InstanceAndOpsCtrl smsBindingSecretKey,
          required InstanceAndOpsCtrl lwm2mServerSmsNum,
          required InstanceAndOpsCtrl shortServerId,
          required InstanceAndOpsCtrl clientHoldOffTime}) =
      _$_SpecificResrcCharLwm2mSecurity;

  factory _SpecificResrcCharLwm2mSecurity.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharLwm2mSecurity.fromJson;

  @override
  @JsonKey(name: 'lwm2mServerURI')
  InstanceAndOpsCtrl get lwm2mServerUri => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get bootstrapServer => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get securityMode => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get pubKeyId => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get serverPubKeyId => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get secretKey => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get smsSecurityMode => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get smsBindingKeyParam =>
      throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get smsBindingSecretKey =>
      throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get lwm2mServerSmsNum =>
      throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get shortServerId => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get clientHoldOffTime =>
      throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharLwm2mSecurityCopyWith<_SpecificResrcCharLwm2mSecurity>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharLwm2mServer _$SpecificResrcCharLwm2mServerFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharLwm2mServer.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharLwm2mServerTearOff {
  const _$SpecificResrcCharLwm2mServerTearOff();

  _SpecificResrcCharLwm2mServer call(
      {required InstanceAndOpsCtrl shortServerId,
      required InstanceAndOpsCtrl lifetime,
      required InstanceAndOpsCtrl defaultMinPeriod,
      required InstanceAndOpsCtrl defaultMaxPeriod,
      required InstanceAndOpsCtrl disable,
      required InstanceAndOpsCtrl disableTimeout,
      required InstanceAndOpsCtrl notificationStoring,
      required InstanceAndOpsCtrl binding,
      required InstanceAndOpsCtrl regUpdateTrigger}) {
    return _SpecificResrcCharLwm2mServer(
      shortServerId: shortServerId,
      lifetime: lifetime,
      defaultMinPeriod: defaultMinPeriod,
      defaultMaxPeriod: defaultMaxPeriod,
      disable: disable,
      disableTimeout: disableTimeout,
      notificationStoring: notificationStoring,
      binding: binding,
      regUpdateTrigger: regUpdateTrigger,
    );
  }

  SpecificResrcCharLwm2mServer fromJson(Map<String, Object> json) {
    return SpecificResrcCharLwm2mServer.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharLwm2mServer = _$SpecificResrcCharLwm2mServerTearOff();

/// @nodoc
mixin _$SpecificResrcCharLwm2mServer {
  InstanceAndOpsCtrl get shortServerId => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get lifetime => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get defaultMinPeriod => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get defaultMaxPeriod => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get disable => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get disableTimeout => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get notificationStoring =>
      throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get binding => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get regUpdateTrigger => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharLwm2mServerCopyWith<SpecificResrcCharLwm2mServer>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharLwm2mServerCopyWith<$Res> {
  factory $SpecificResrcCharLwm2mServerCopyWith(
          SpecificResrcCharLwm2mServer value,
          $Res Function(SpecificResrcCharLwm2mServer) then) =
      _$SpecificResrcCharLwm2mServerCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl shortServerId,
      InstanceAndOpsCtrl lifetime,
      InstanceAndOpsCtrl defaultMinPeriod,
      InstanceAndOpsCtrl defaultMaxPeriod,
      InstanceAndOpsCtrl disable,
      InstanceAndOpsCtrl disableTimeout,
      InstanceAndOpsCtrl notificationStoring,
      InstanceAndOpsCtrl binding,
      InstanceAndOpsCtrl regUpdateTrigger});

  $InstanceAndOpsCtrlCopyWith<$Res> get shortServerId;
  $InstanceAndOpsCtrlCopyWith<$Res> get lifetime;
  $InstanceAndOpsCtrlCopyWith<$Res> get defaultMinPeriod;
  $InstanceAndOpsCtrlCopyWith<$Res> get defaultMaxPeriod;
  $InstanceAndOpsCtrlCopyWith<$Res> get disable;
  $InstanceAndOpsCtrlCopyWith<$Res> get disableTimeout;
  $InstanceAndOpsCtrlCopyWith<$Res> get notificationStoring;
  $InstanceAndOpsCtrlCopyWith<$Res> get binding;
  $InstanceAndOpsCtrlCopyWith<$Res> get regUpdateTrigger;
}

/// @nodoc
class _$SpecificResrcCharLwm2mServerCopyWithImpl<$Res>
    implements $SpecificResrcCharLwm2mServerCopyWith<$Res> {
  _$SpecificResrcCharLwm2mServerCopyWithImpl(this._value, this._then);

  final SpecificResrcCharLwm2mServer _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharLwm2mServer) _then;

  @override
  $Res call({
    Object? shortServerId = freezed,
    Object? lifetime = freezed,
    Object? defaultMinPeriod = freezed,
    Object? defaultMaxPeriod = freezed,
    Object? disable = freezed,
    Object? disableTimeout = freezed,
    Object? notificationStoring = freezed,
    Object? binding = freezed,
    Object? regUpdateTrigger = freezed,
  }) {
    return _then(_value.copyWith(
      shortServerId: shortServerId == freezed
          ? _value.shortServerId
          : shortServerId // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      lifetime: lifetime == freezed
          ? _value.lifetime
          : lifetime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      defaultMinPeriod: defaultMinPeriod == freezed
          ? _value.defaultMinPeriod
          : defaultMinPeriod // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      defaultMaxPeriod: defaultMaxPeriod == freezed
          ? _value.defaultMaxPeriod
          : defaultMaxPeriod // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      disable: disable == freezed
          ? _value.disable
          : disable // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      disableTimeout: disableTimeout == freezed
          ? _value.disableTimeout
          : disableTimeout // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      notificationStoring: notificationStoring == freezed
          ? _value.notificationStoring
          : notificationStoring // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      binding: binding == freezed
          ? _value.binding
          : binding // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      regUpdateTrigger: regUpdateTrigger == freezed
          ? _value.regUpdateTrigger
          : regUpdateTrigger // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get shortServerId {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.shortServerId, (value) {
      return _then(_value.copyWith(shortServerId: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get lifetime {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.lifetime, (value) {
      return _then(_value.copyWith(lifetime: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get defaultMinPeriod {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.defaultMinPeriod, (value) {
      return _then(_value.copyWith(defaultMinPeriod: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get defaultMaxPeriod {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.defaultMaxPeriod, (value) {
      return _then(_value.copyWith(defaultMaxPeriod: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get disable {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.disable, (value) {
      return _then(_value.copyWith(disable: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get disableTimeout {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.disableTimeout, (value) {
      return _then(_value.copyWith(disableTimeout: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get notificationStoring {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.notificationStoring,
        (value) {
      return _then(_value.copyWith(notificationStoring: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get binding {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.binding, (value) {
      return _then(_value.copyWith(binding: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get regUpdateTrigger {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.regUpdateTrigger, (value) {
      return _then(_value.copyWith(regUpdateTrigger: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharLwm2mServerCopyWith<$Res>
    implements $SpecificResrcCharLwm2mServerCopyWith<$Res> {
  factory _$SpecificResrcCharLwm2mServerCopyWith(
          _SpecificResrcCharLwm2mServer value,
          $Res Function(_SpecificResrcCharLwm2mServer) then) =
      __$SpecificResrcCharLwm2mServerCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl shortServerId,
      InstanceAndOpsCtrl lifetime,
      InstanceAndOpsCtrl defaultMinPeriod,
      InstanceAndOpsCtrl defaultMaxPeriod,
      InstanceAndOpsCtrl disable,
      InstanceAndOpsCtrl disableTimeout,
      InstanceAndOpsCtrl notificationStoring,
      InstanceAndOpsCtrl binding,
      InstanceAndOpsCtrl regUpdateTrigger});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get shortServerId;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get lifetime;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get defaultMinPeriod;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get defaultMaxPeriod;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get disable;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get disableTimeout;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get notificationStoring;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get binding;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get regUpdateTrigger;
}

/// @nodoc
class __$SpecificResrcCharLwm2mServerCopyWithImpl<$Res>
    extends _$SpecificResrcCharLwm2mServerCopyWithImpl<$Res>
    implements _$SpecificResrcCharLwm2mServerCopyWith<$Res> {
  __$SpecificResrcCharLwm2mServerCopyWithImpl(
      _SpecificResrcCharLwm2mServer _value,
      $Res Function(_SpecificResrcCharLwm2mServer) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharLwm2mServer));

  @override
  _SpecificResrcCharLwm2mServer get _value =>
      super._value as _SpecificResrcCharLwm2mServer;

  @override
  $Res call({
    Object? shortServerId = freezed,
    Object? lifetime = freezed,
    Object? defaultMinPeriod = freezed,
    Object? defaultMaxPeriod = freezed,
    Object? disable = freezed,
    Object? disableTimeout = freezed,
    Object? notificationStoring = freezed,
    Object? binding = freezed,
    Object? regUpdateTrigger = freezed,
  }) {
    return _then(_SpecificResrcCharLwm2mServer(
      shortServerId: shortServerId == freezed
          ? _value.shortServerId
          : shortServerId // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      lifetime: lifetime == freezed
          ? _value.lifetime
          : lifetime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      defaultMinPeriod: defaultMinPeriod == freezed
          ? _value.defaultMinPeriod
          : defaultMinPeriod // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      defaultMaxPeriod: defaultMaxPeriod == freezed
          ? _value.defaultMaxPeriod
          : defaultMaxPeriod // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      disable: disable == freezed
          ? _value.disable
          : disable // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      disableTimeout: disableTimeout == freezed
          ? _value.disableTimeout
          : disableTimeout // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      notificationStoring: notificationStoring == freezed
          ? _value.notificationStoring
          : notificationStoring // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      binding: binding == freezed
          ? _value.binding
          : binding // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      regUpdateTrigger: regUpdateTrigger == freezed
          ? _value.regUpdateTrigger
          : regUpdateTrigger // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharLwm2mServer implements _SpecificResrcCharLwm2mServer {
  const _$_SpecificResrcCharLwm2mServer(
      {required this.shortServerId,
      required this.lifetime,
      required this.defaultMinPeriod,
      required this.defaultMaxPeriod,
      required this.disable,
      required this.disableTimeout,
      required this.notificationStoring,
      required this.binding,
      required this.regUpdateTrigger});

  factory _$_SpecificResrcCharLwm2mServer.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharLwm2mServerFromJson(json);

  @override
  final InstanceAndOpsCtrl shortServerId;
  @override
  final InstanceAndOpsCtrl lifetime;
  @override
  final InstanceAndOpsCtrl defaultMinPeriod;
  @override
  final InstanceAndOpsCtrl defaultMaxPeriod;
  @override
  final InstanceAndOpsCtrl disable;
  @override
  final InstanceAndOpsCtrl disableTimeout;
  @override
  final InstanceAndOpsCtrl notificationStoring;
  @override
  final InstanceAndOpsCtrl binding;
  @override
  final InstanceAndOpsCtrl regUpdateTrigger;

  @override
  String toString() {
    return 'SpecificResrcCharLwm2mServer(shortServerId: $shortServerId, lifetime: $lifetime, defaultMinPeriod: $defaultMinPeriod, defaultMaxPeriod: $defaultMaxPeriod, disable: $disable, disableTimeout: $disableTimeout, notificationStoring: $notificationStoring, binding: $binding, regUpdateTrigger: $regUpdateTrigger)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharLwm2mServer &&
            (identical(other.shortServerId, shortServerId) ||
                const DeepCollectionEquality()
                    .equals(other.shortServerId, shortServerId)) &&
            (identical(other.lifetime, lifetime) ||
                const DeepCollectionEquality()
                    .equals(other.lifetime, lifetime)) &&
            (identical(other.defaultMinPeriod, defaultMinPeriod) ||
                const DeepCollectionEquality()
                    .equals(other.defaultMinPeriod, defaultMinPeriod)) &&
            (identical(other.defaultMaxPeriod, defaultMaxPeriod) ||
                const DeepCollectionEquality()
                    .equals(other.defaultMaxPeriod, defaultMaxPeriod)) &&
            (identical(other.disable, disable) ||
                const DeepCollectionEquality()
                    .equals(other.disable, disable)) &&
            (identical(other.disableTimeout, disableTimeout) ||
                const DeepCollectionEquality()
                    .equals(other.disableTimeout, disableTimeout)) &&
            (identical(other.notificationStoring, notificationStoring) ||
                const DeepCollectionEquality()
                    .equals(other.notificationStoring, notificationStoring)) &&
            (identical(other.binding, binding) ||
                const DeepCollectionEquality()
                    .equals(other.binding, binding)) &&
            (identical(other.regUpdateTrigger, regUpdateTrigger) ||
                const DeepCollectionEquality()
                    .equals(other.regUpdateTrigger, regUpdateTrigger)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(shortServerId) ^
      const DeepCollectionEquality().hash(lifetime) ^
      const DeepCollectionEquality().hash(defaultMinPeriod) ^
      const DeepCollectionEquality().hash(defaultMaxPeriod) ^
      const DeepCollectionEquality().hash(disable) ^
      const DeepCollectionEquality().hash(disableTimeout) ^
      const DeepCollectionEquality().hash(notificationStoring) ^
      const DeepCollectionEquality().hash(binding) ^
      const DeepCollectionEquality().hash(regUpdateTrigger);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharLwm2mServerCopyWith<_SpecificResrcCharLwm2mServer>
      get copyWith => __$SpecificResrcCharLwm2mServerCopyWithImpl<
          _SpecificResrcCharLwm2mServer>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharLwm2mServerToJson(this);
  }
}

abstract class _SpecificResrcCharLwm2mServer
    implements SpecificResrcCharLwm2mServer {
  const factory _SpecificResrcCharLwm2mServer(
          {required InstanceAndOpsCtrl shortServerId,
          required InstanceAndOpsCtrl lifetime,
          required InstanceAndOpsCtrl defaultMinPeriod,
          required InstanceAndOpsCtrl defaultMaxPeriod,
          required InstanceAndOpsCtrl disable,
          required InstanceAndOpsCtrl disableTimeout,
          required InstanceAndOpsCtrl notificationStoring,
          required InstanceAndOpsCtrl binding,
          required InstanceAndOpsCtrl regUpdateTrigger}) =
      _$_SpecificResrcCharLwm2mServer;

  factory _SpecificResrcCharLwm2mServer.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharLwm2mServer.fromJson;

  @override
  InstanceAndOpsCtrl get shortServerId => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get lifetime => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get defaultMinPeriod => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get defaultMaxPeriod => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get disable => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get disableTimeout => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get notificationStoring =>
      throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get binding => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get regUpdateTrigger => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharLwm2mServerCopyWith<_SpecificResrcCharLwm2mServer>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharMagnetometer _$SpecificResrcCharMagnetometerFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharMagnetometer.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharMagnetometerTearOff {
  const _$SpecificResrcCharMagnetometerTearOff();

  _SpecificResrcCharMagnetometer call(
      {required InstanceAndOpsCtrl xValue,
      required InstanceAndOpsCtrl yValue,
      required InstanceAndOpsCtrl zValue,
      required InstanceAndOpsCtrl units,
      required InstanceAndOpsCtrl compassDir}) {
    return _SpecificResrcCharMagnetometer(
      xValue: xValue,
      yValue: yValue,
      zValue: zValue,
      units: units,
      compassDir: compassDir,
    );
  }

  SpecificResrcCharMagnetometer fromJson(Map<String, Object> json) {
    return SpecificResrcCharMagnetometer.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharMagnetometer = _$SpecificResrcCharMagnetometerTearOff();

/// @nodoc
mixin _$SpecificResrcCharMagnetometer {
  InstanceAndOpsCtrl get xValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get yValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get zValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get units => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get compassDir => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharMagnetometerCopyWith<SpecificResrcCharMagnetometer>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharMagnetometerCopyWith<$Res> {
  factory $SpecificResrcCharMagnetometerCopyWith(
          SpecificResrcCharMagnetometer value,
          $Res Function(SpecificResrcCharMagnetometer) then) =
      _$SpecificResrcCharMagnetometerCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl xValue,
      InstanceAndOpsCtrl yValue,
      InstanceAndOpsCtrl zValue,
      InstanceAndOpsCtrl units,
      InstanceAndOpsCtrl compassDir});

  $InstanceAndOpsCtrlCopyWith<$Res> get xValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get yValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get zValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get units;
  $InstanceAndOpsCtrlCopyWith<$Res> get compassDir;
}

/// @nodoc
class _$SpecificResrcCharMagnetometerCopyWithImpl<$Res>
    implements $SpecificResrcCharMagnetometerCopyWith<$Res> {
  _$SpecificResrcCharMagnetometerCopyWithImpl(this._value, this._then);

  final SpecificResrcCharMagnetometer _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharMagnetometer) _then;

  @override
  $Res call({
    Object? xValue = freezed,
    Object? yValue = freezed,
    Object? zValue = freezed,
    Object? units = freezed,
    Object? compassDir = freezed,
  }) {
    return _then(_value.copyWith(
      xValue: xValue == freezed
          ? _value.xValue
          : xValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      yValue: yValue == freezed
          ? _value.yValue
          : yValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      zValue: zValue == freezed
          ? _value.zValue
          : zValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      compassDir: compassDir == freezed
          ? _value.compassDir
          : compassDir // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get xValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.xValue, (value) {
      return _then(_value.copyWith(xValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get yValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.yValue, (value) {
      return _then(_value.copyWith(yValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get zValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.zValue, (value) {
      return _then(_value.copyWith(zValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get units {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.units, (value) {
      return _then(_value.copyWith(units: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get compassDir {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.compassDir, (value) {
      return _then(_value.copyWith(compassDir: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharMagnetometerCopyWith<$Res>
    implements $SpecificResrcCharMagnetometerCopyWith<$Res> {
  factory _$SpecificResrcCharMagnetometerCopyWith(
          _SpecificResrcCharMagnetometer value,
          $Res Function(_SpecificResrcCharMagnetometer) then) =
      __$SpecificResrcCharMagnetometerCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl xValue,
      InstanceAndOpsCtrl yValue,
      InstanceAndOpsCtrl zValue,
      InstanceAndOpsCtrl units,
      InstanceAndOpsCtrl compassDir});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get xValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get yValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get zValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get units;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get compassDir;
}

/// @nodoc
class __$SpecificResrcCharMagnetometerCopyWithImpl<$Res>
    extends _$SpecificResrcCharMagnetometerCopyWithImpl<$Res>
    implements _$SpecificResrcCharMagnetometerCopyWith<$Res> {
  __$SpecificResrcCharMagnetometerCopyWithImpl(
      _SpecificResrcCharMagnetometer _value,
      $Res Function(_SpecificResrcCharMagnetometer) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharMagnetometer));

  @override
  _SpecificResrcCharMagnetometer get _value =>
      super._value as _SpecificResrcCharMagnetometer;

  @override
  $Res call({
    Object? xValue = freezed,
    Object? yValue = freezed,
    Object? zValue = freezed,
    Object? units = freezed,
    Object? compassDir = freezed,
  }) {
    return _then(_SpecificResrcCharMagnetometer(
      xValue: xValue == freezed
          ? _value.xValue
          : xValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      yValue: yValue == freezed
          ? _value.yValue
          : yValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      zValue: zValue == freezed
          ? _value.zValue
          : zValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      compassDir: compassDir == freezed
          ? _value.compassDir
          : compassDir // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharMagnetometer
    implements _SpecificResrcCharMagnetometer {
  const _$_SpecificResrcCharMagnetometer(
      {required this.xValue,
      required this.yValue,
      required this.zValue,
      required this.units,
      required this.compassDir});

  factory _$_SpecificResrcCharMagnetometer.fromJson(
          Map<String, dynamic> json) =>
      _$$_SpecificResrcCharMagnetometerFromJson(json);

  @override
  final InstanceAndOpsCtrl xValue;
  @override
  final InstanceAndOpsCtrl yValue;
  @override
  final InstanceAndOpsCtrl zValue;
  @override
  final InstanceAndOpsCtrl units;
  @override
  final InstanceAndOpsCtrl compassDir;

  @override
  String toString() {
    return 'SpecificResrcCharMagnetometer(xValue: $xValue, yValue: $yValue, zValue: $zValue, units: $units, compassDir: $compassDir)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharMagnetometer &&
            (identical(other.xValue, xValue) ||
                const DeepCollectionEquality().equals(other.xValue, xValue)) &&
            (identical(other.yValue, yValue) ||
                const DeepCollectionEquality().equals(other.yValue, yValue)) &&
            (identical(other.zValue, zValue) ||
                const DeepCollectionEquality().equals(other.zValue, zValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.compassDir, compassDir) ||
                const DeepCollectionEquality()
                    .equals(other.compassDir, compassDir)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(xValue) ^
      const DeepCollectionEquality().hash(yValue) ^
      const DeepCollectionEquality().hash(zValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(compassDir);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharMagnetometerCopyWith<_SpecificResrcCharMagnetometer>
      get copyWith => __$SpecificResrcCharMagnetometerCopyWithImpl<
          _SpecificResrcCharMagnetometer>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharMagnetometerToJson(this);
  }
}

abstract class _SpecificResrcCharMagnetometer
    implements SpecificResrcCharMagnetometer {
  const factory _SpecificResrcCharMagnetometer(
          {required InstanceAndOpsCtrl xValue,
          required InstanceAndOpsCtrl yValue,
          required InstanceAndOpsCtrl zValue,
          required InstanceAndOpsCtrl units,
          required InstanceAndOpsCtrl compassDir}) =
      _$_SpecificResrcCharMagnetometer;

  factory _SpecificResrcCharMagnetometer.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharMagnetometer.fromJson;

  @override
  InstanceAndOpsCtrl get xValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get yValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get zValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get units => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get compassDir => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharMagnetometerCopyWith<_SpecificResrcCharMagnetometer>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharMultipleAxisJoystick
    _$SpecificResrcCharMultipleAxisJoystickFromJson(Map<String, dynamic> json) {
  return _SpecificResrcCharMultipleAxisJoystick.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharMultipleAxisJoystickTearOff {
  const _$SpecificResrcCharMultipleAxisJoystickTearOff();

  _SpecificResrcCharMultipleAxisJoystick call(
      {required InstanceAndOpsCtrl dInState,
      required InstanceAndOpsCtrl counter,
      required InstanceAndOpsCtrl xValue,
      required InstanceAndOpsCtrl yValue,
      required InstanceAndOpsCtrl zValue,
      required InstanceAndOpsCtrl appType}) {
    return _SpecificResrcCharMultipleAxisJoystick(
      dInState: dInState,
      counter: counter,
      xValue: xValue,
      yValue: yValue,
      zValue: zValue,
      appType: appType,
    );
  }

  SpecificResrcCharMultipleAxisJoystick fromJson(Map<String, Object> json) {
    return SpecificResrcCharMultipleAxisJoystick.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharMultipleAxisJoystick =
    _$SpecificResrcCharMultipleAxisJoystickTearOff();

/// @nodoc
mixin _$SpecificResrcCharMultipleAxisJoystick {
  InstanceAndOpsCtrl get dInState => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get counter => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get xValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get yValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get zValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharMultipleAxisJoystickCopyWith<
          SpecificResrcCharMultipleAxisJoystick>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharMultipleAxisJoystickCopyWith<$Res> {
  factory $SpecificResrcCharMultipleAxisJoystickCopyWith(
          SpecificResrcCharMultipleAxisJoystick value,
          $Res Function(SpecificResrcCharMultipleAxisJoystick) then) =
      _$SpecificResrcCharMultipleAxisJoystickCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl dInState,
      InstanceAndOpsCtrl counter,
      InstanceAndOpsCtrl xValue,
      InstanceAndOpsCtrl yValue,
      InstanceAndOpsCtrl zValue,
      InstanceAndOpsCtrl appType});

  $InstanceAndOpsCtrlCopyWith<$Res> get dInState;
  $InstanceAndOpsCtrlCopyWith<$Res> get counter;
  $InstanceAndOpsCtrlCopyWith<$Res> get xValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get yValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get zValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class _$SpecificResrcCharMultipleAxisJoystickCopyWithImpl<$Res>
    implements $SpecificResrcCharMultipleAxisJoystickCopyWith<$Res> {
  _$SpecificResrcCharMultipleAxisJoystickCopyWithImpl(this._value, this._then);

  final SpecificResrcCharMultipleAxisJoystick _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharMultipleAxisJoystick) _then;

  @override
  $Res call({
    Object? dInState = freezed,
    Object? counter = freezed,
    Object? xValue = freezed,
    Object? yValue = freezed,
    Object? zValue = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      dInState: dInState == freezed
          ? _value.dInState
          : dInState // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      xValue: xValue == freezed
          ? _value.xValue
          : xValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      yValue: yValue == freezed
          ? _value.yValue
          : yValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      zValue: zValue == freezed
          ? _value.zValue
          : zValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dInState {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.dInState, (value) {
      return _then(_value.copyWith(dInState: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get counter {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.counter, (value) {
      return _then(_value.copyWith(counter: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get xValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.xValue, (value) {
      return _then(_value.copyWith(xValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get yValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.yValue, (value) {
      return _then(_value.copyWith(yValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get zValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.zValue, (value) {
      return _then(_value.copyWith(zValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharMultipleAxisJoystickCopyWith<$Res>
    implements $SpecificResrcCharMultipleAxisJoystickCopyWith<$Res> {
  factory _$SpecificResrcCharMultipleAxisJoystickCopyWith(
          _SpecificResrcCharMultipleAxisJoystick value,
          $Res Function(_SpecificResrcCharMultipleAxisJoystick) then) =
      __$SpecificResrcCharMultipleAxisJoystickCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl dInState,
      InstanceAndOpsCtrl counter,
      InstanceAndOpsCtrl xValue,
      InstanceAndOpsCtrl yValue,
      InstanceAndOpsCtrl zValue,
      InstanceAndOpsCtrl appType});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dInState;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get counter;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get xValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get yValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get zValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class __$SpecificResrcCharMultipleAxisJoystickCopyWithImpl<$Res>
    extends _$SpecificResrcCharMultipleAxisJoystickCopyWithImpl<$Res>
    implements _$SpecificResrcCharMultipleAxisJoystickCopyWith<$Res> {
  __$SpecificResrcCharMultipleAxisJoystickCopyWithImpl(
      _SpecificResrcCharMultipleAxisJoystick _value,
      $Res Function(_SpecificResrcCharMultipleAxisJoystick) _then)
      : super(
            _value, (v) => _then(v as _SpecificResrcCharMultipleAxisJoystick));

  @override
  _SpecificResrcCharMultipleAxisJoystick get _value =>
      super._value as _SpecificResrcCharMultipleAxisJoystick;

  @override
  $Res call({
    Object? dInState = freezed,
    Object? counter = freezed,
    Object? xValue = freezed,
    Object? yValue = freezed,
    Object? zValue = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificResrcCharMultipleAxisJoystick(
      dInState: dInState == freezed
          ? _value.dInState
          : dInState // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      xValue: xValue == freezed
          ? _value.xValue
          : xValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      yValue: yValue == freezed
          ? _value.yValue
          : yValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      zValue: zValue == freezed
          ? _value.zValue
          : zValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharMultipleAxisJoystick
    implements _SpecificResrcCharMultipleAxisJoystick {
  const _$_SpecificResrcCharMultipleAxisJoystick(
      {required this.dInState,
      required this.counter,
      required this.xValue,
      required this.yValue,
      required this.zValue,
      required this.appType});

  factory _$_SpecificResrcCharMultipleAxisJoystick.fromJson(
          Map<String, dynamic> json) =>
      _$$_SpecificResrcCharMultipleAxisJoystickFromJson(json);

  @override
  final InstanceAndOpsCtrl dInState;
  @override
  final InstanceAndOpsCtrl counter;
  @override
  final InstanceAndOpsCtrl xValue;
  @override
  final InstanceAndOpsCtrl yValue;
  @override
  final InstanceAndOpsCtrl zValue;
  @override
  final InstanceAndOpsCtrl appType;

  @override
  String toString() {
    return 'SpecificResrcCharMultipleAxisJoystick(dInState: $dInState, counter: $counter, xValue: $xValue, yValue: $yValue, zValue: $zValue, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharMultipleAxisJoystick &&
            (identical(other.dInState, dInState) ||
                const DeepCollectionEquality()
                    .equals(other.dInState, dInState)) &&
            (identical(other.counter, counter) ||
                const DeepCollectionEquality()
                    .equals(other.counter, counter)) &&
            (identical(other.xValue, xValue) ||
                const DeepCollectionEquality().equals(other.xValue, xValue)) &&
            (identical(other.yValue, yValue) ||
                const DeepCollectionEquality().equals(other.yValue, yValue)) &&
            (identical(other.zValue, zValue) ||
                const DeepCollectionEquality().equals(other.zValue, zValue)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(dInState) ^
      const DeepCollectionEquality().hash(counter) ^
      const DeepCollectionEquality().hash(xValue) ^
      const DeepCollectionEquality().hash(yValue) ^
      const DeepCollectionEquality().hash(zValue) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharMultipleAxisJoystickCopyWith<
          _SpecificResrcCharMultipleAxisJoystick>
      get copyWith => __$SpecificResrcCharMultipleAxisJoystickCopyWithImpl<
          _SpecificResrcCharMultipleAxisJoystick>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharMultipleAxisJoystickToJson(this);
  }
}

abstract class _SpecificResrcCharMultipleAxisJoystick
    implements SpecificResrcCharMultipleAxisJoystick {
  const factory _SpecificResrcCharMultipleAxisJoystick(
          {required InstanceAndOpsCtrl dInState,
          required InstanceAndOpsCtrl counter,
          required InstanceAndOpsCtrl xValue,
          required InstanceAndOpsCtrl yValue,
          required InstanceAndOpsCtrl zValue,
          required InstanceAndOpsCtrl appType}) =
      _$_SpecificResrcCharMultipleAxisJoystick;

  factory _SpecificResrcCharMultipleAxisJoystick.fromJson(
          Map<String, dynamic> json) =
      _$_SpecificResrcCharMultipleAxisJoystick.fromJson;

  @override
  InstanceAndOpsCtrl get dInState => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get counter => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get xValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get yValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get zValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharMultipleAxisJoystickCopyWith<
          _SpecificResrcCharMultipleAxisJoystick>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharMultistateSelector
    _$SpecificResrcCharMultistateSelectorFromJson(Map<String, dynamic> json) {
  return _SpecificResrcCharMultistateSelector.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharMultistateSelectorTearOff {
  const _$SpecificResrcCharMultistateSelectorTearOff();

  _SpecificResrcCharMultistateSelector call(
      {required InstanceAndOpsCtrl mStateIn,
      required InstanceAndOpsCtrl appType}) {
    return _SpecificResrcCharMultistateSelector(
      mStateIn: mStateIn,
      appType: appType,
    );
  }

  SpecificResrcCharMultistateSelector fromJson(Map<String, Object> json) {
    return SpecificResrcCharMultistateSelector.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharMultistateSelector =
    _$SpecificResrcCharMultistateSelectorTearOff();

/// @nodoc
mixin _$SpecificResrcCharMultistateSelector {
  InstanceAndOpsCtrl get mStateIn => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharMultistateSelectorCopyWith<
          SpecificResrcCharMultistateSelector>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharMultistateSelectorCopyWith<$Res> {
  factory $SpecificResrcCharMultistateSelectorCopyWith(
          SpecificResrcCharMultistateSelector value,
          $Res Function(SpecificResrcCharMultistateSelector) then) =
      _$SpecificResrcCharMultistateSelectorCopyWithImpl<$Res>;
  $Res call({InstanceAndOpsCtrl mStateIn, InstanceAndOpsCtrl appType});

  $InstanceAndOpsCtrlCopyWith<$Res> get mStateIn;
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class _$SpecificResrcCharMultistateSelectorCopyWithImpl<$Res>
    implements $SpecificResrcCharMultistateSelectorCopyWith<$Res> {
  _$SpecificResrcCharMultistateSelectorCopyWithImpl(this._value, this._then);

  final SpecificResrcCharMultistateSelector _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharMultistateSelector) _then;

  @override
  $Res call({
    Object? mStateIn = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      mStateIn: mStateIn == freezed
          ? _value.mStateIn
          : mStateIn // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get mStateIn {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.mStateIn, (value) {
      return _then(_value.copyWith(mStateIn: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharMultistateSelectorCopyWith<$Res>
    implements $SpecificResrcCharMultistateSelectorCopyWith<$Res> {
  factory _$SpecificResrcCharMultistateSelectorCopyWith(
          _SpecificResrcCharMultistateSelector value,
          $Res Function(_SpecificResrcCharMultistateSelector) then) =
      __$SpecificResrcCharMultistateSelectorCopyWithImpl<$Res>;
  @override
  $Res call({InstanceAndOpsCtrl mStateIn, InstanceAndOpsCtrl appType});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get mStateIn;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class __$SpecificResrcCharMultistateSelectorCopyWithImpl<$Res>
    extends _$SpecificResrcCharMultistateSelectorCopyWithImpl<$Res>
    implements _$SpecificResrcCharMultistateSelectorCopyWith<$Res> {
  __$SpecificResrcCharMultistateSelectorCopyWithImpl(
      _SpecificResrcCharMultistateSelector _value,
      $Res Function(_SpecificResrcCharMultistateSelector) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharMultistateSelector));

  @override
  _SpecificResrcCharMultistateSelector get _value =>
      super._value as _SpecificResrcCharMultistateSelector;

  @override
  $Res call({
    Object? mStateIn = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificResrcCharMultistateSelector(
      mStateIn: mStateIn == freezed
          ? _value.mStateIn
          : mStateIn // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharMultistateSelector
    implements _SpecificResrcCharMultistateSelector {
  const _$_SpecificResrcCharMultistateSelector(
      {required this.mStateIn, required this.appType});

  factory _$_SpecificResrcCharMultistateSelector.fromJson(
          Map<String, dynamic> json) =>
      _$$_SpecificResrcCharMultistateSelectorFromJson(json);

  @override
  final InstanceAndOpsCtrl mStateIn;
  @override
  final InstanceAndOpsCtrl appType;

  @override
  String toString() {
    return 'SpecificResrcCharMultistateSelector(mStateIn: $mStateIn, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharMultistateSelector &&
            (identical(other.mStateIn, mStateIn) ||
                const DeepCollectionEquality()
                    .equals(other.mStateIn, mStateIn)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(mStateIn) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharMultistateSelectorCopyWith<
          _SpecificResrcCharMultistateSelector>
      get copyWith => __$SpecificResrcCharMultistateSelectorCopyWithImpl<
          _SpecificResrcCharMultistateSelector>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharMultistateSelectorToJson(this);
  }
}

abstract class _SpecificResrcCharMultistateSelector
    implements SpecificResrcCharMultistateSelector {
  const factory _SpecificResrcCharMultistateSelector(
          {required InstanceAndOpsCtrl mStateIn,
          required InstanceAndOpsCtrl appType}) =
      _$_SpecificResrcCharMultistateSelector;

  factory _SpecificResrcCharMultistateSelector.fromJson(
          Map<String, dynamic> json) =
      _$_SpecificResrcCharMultistateSelector.fromJson;

  @override
  InstanceAndOpsCtrl get mStateIn => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharMultistateSelectorCopyWith<
          _SpecificResrcCharMultistateSelector>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharOnOffSwitch _$SpecificResrcCharOnOffSwitchFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharOnOffSwitch.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharOnOffSwitchTearOff {
  const _$SpecificResrcCharOnOffSwitchTearOff();

  _SpecificResrcCharOnOffSwitch call(
      {required InstanceAndOpsCtrl dInState,
      required InstanceAndOpsCtrl counter,
      required InstanceAndOpsCtrl onTime,
      required InstanceAndOpsCtrl offTime,
      required InstanceAndOpsCtrl appType}) {
    return _SpecificResrcCharOnOffSwitch(
      dInState: dInState,
      counter: counter,
      onTime: onTime,
      offTime: offTime,
      appType: appType,
    );
  }

  SpecificResrcCharOnOffSwitch fromJson(Map<String, Object> json) {
    return SpecificResrcCharOnOffSwitch.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharOnOffSwitch = _$SpecificResrcCharOnOffSwitchTearOff();

/// @nodoc
mixin _$SpecificResrcCharOnOffSwitch {
  InstanceAndOpsCtrl get dInState => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get counter => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get onTime => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get offTime => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharOnOffSwitchCopyWith<SpecificResrcCharOnOffSwitch>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharOnOffSwitchCopyWith<$Res> {
  factory $SpecificResrcCharOnOffSwitchCopyWith(
          SpecificResrcCharOnOffSwitch value,
          $Res Function(SpecificResrcCharOnOffSwitch) then) =
      _$SpecificResrcCharOnOffSwitchCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl dInState,
      InstanceAndOpsCtrl counter,
      InstanceAndOpsCtrl onTime,
      InstanceAndOpsCtrl offTime,
      InstanceAndOpsCtrl appType});

  $InstanceAndOpsCtrlCopyWith<$Res> get dInState;
  $InstanceAndOpsCtrlCopyWith<$Res> get counter;
  $InstanceAndOpsCtrlCopyWith<$Res> get onTime;
  $InstanceAndOpsCtrlCopyWith<$Res> get offTime;
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class _$SpecificResrcCharOnOffSwitchCopyWithImpl<$Res>
    implements $SpecificResrcCharOnOffSwitchCopyWith<$Res> {
  _$SpecificResrcCharOnOffSwitchCopyWithImpl(this._value, this._then);

  final SpecificResrcCharOnOffSwitch _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharOnOffSwitch) _then;

  @override
  $Res call({
    Object? dInState = freezed,
    Object? counter = freezed,
    Object? onTime = freezed,
    Object? offTime = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      dInState: dInState == freezed
          ? _value.dInState
          : dInState // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      onTime: onTime == freezed
          ? _value.onTime
          : onTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      offTime: offTime == freezed
          ? _value.offTime
          : offTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dInState {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.dInState, (value) {
      return _then(_value.copyWith(dInState: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get counter {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.counter, (value) {
      return _then(_value.copyWith(counter: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get onTime {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.onTime, (value) {
      return _then(_value.copyWith(onTime: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get offTime {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.offTime, (value) {
      return _then(_value.copyWith(offTime: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharOnOffSwitchCopyWith<$Res>
    implements $SpecificResrcCharOnOffSwitchCopyWith<$Res> {
  factory _$SpecificResrcCharOnOffSwitchCopyWith(
          _SpecificResrcCharOnOffSwitch value,
          $Res Function(_SpecificResrcCharOnOffSwitch) then) =
      __$SpecificResrcCharOnOffSwitchCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl dInState,
      InstanceAndOpsCtrl counter,
      InstanceAndOpsCtrl onTime,
      InstanceAndOpsCtrl offTime,
      InstanceAndOpsCtrl appType});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dInState;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get counter;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get onTime;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get offTime;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class __$SpecificResrcCharOnOffSwitchCopyWithImpl<$Res>
    extends _$SpecificResrcCharOnOffSwitchCopyWithImpl<$Res>
    implements _$SpecificResrcCharOnOffSwitchCopyWith<$Res> {
  __$SpecificResrcCharOnOffSwitchCopyWithImpl(
      _SpecificResrcCharOnOffSwitch _value,
      $Res Function(_SpecificResrcCharOnOffSwitch) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharOnOffSwitch));

  @override
  _SpecificResrcCharOnOffSwitch get _value =>
      super._value as _SpecificResrcCharOnOffSwitch;

  @override
  $Res call({
    Object? dInState = freezed,
    Object? counter = freezed,
    Object? onTime = freezed,
    Object? offTime = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificResrcCharOnOffSwitch(
      dInState: dInState == freezed
          ? _value.dInState
          : dInState // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      onTime: onTime == freezed
          ? _value.onTime
          : onTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      offTime: offTime == freezed
          ? _value.offTime
          : offTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharOnOffSwitch implements _SpecificResrcCharOnOffSwitch {
  const _$_SpecificResrcCharOnOffSwitch(
      {required this.dInState,
      required this.counter,
      required this.onTime,
      required this.offTime,
      required this.appType});

  factory _$_SpecificResrcCharOnOffSwitch.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharOnOffSwitchFromJson(json);

  @override
  final InstanceAndOpsCtrl dInState;
  @override
  final InstanceAndOpsCtrl counter;
  @override
  final InstanceAndOpsCtrl onTime;
  @override
  final InstanceAndOpsCtrl offTime;
  @override
  final InstanceAndOpsCtrl appType;

  @override
  String toString() {
    return 'SpecificResrcCharOnOffSwitch(dInState: $dInState, counter: $counter, onTime: $onTime, offTime: $offTime, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharOnOffSwitch &&
            (identical(other.dInState, dInState) ||
                const DeepCollectionEquality()
                    .equals(other.dInState, dInState)) &&
            (identical(other.counter, counter) ||
                const DeepCollectionEquality()
                    .equals(other.counter, counter)) &&
            (identical(other.onTime, onTime) ||
                const DeepCollectionEquality().equals(other.onTime, onTime)) &&
            (identical(other.offTime, offTime) ||
                const DeepCollectionEquality()
                    .equals(other.offTime, offTime)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(dInState) ^
      const DeepCollectionEquality().hash(counter) ^
      const DeepCollectionEquality().hash(onTime) ^
      const DeepCollectionEquality().hash(offTime) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharOnOffSwitchCopyWith<_SpecificResrcCharOnOffSwitch>
      get copyWith => __$SpecificResrcCharOnOffSwitchCopyWithImpl<
          _SpecificResrcCharOnOffSwitch>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharOnOffSwitchToJson(this);
  }
}

abstract class _SpecificResrcCharOnOffSwitch
    implements SpecificResrcCharOnOffSwitch {
  const factory _SpecificResrcCharOnOffSwitch(
      {required InstanceAndOpsCtrl dInState,
      required InstanceAndOpsCtrl counter,
      required InstanceAndOpsCtrl onTime,
      required InstanceAndOpsCtrl offTime,
      required InstanceAndOpsCtrl appType}) = _$_SpecificResrcCharOnOffSwitch;

  factory _SpecificResrcCharOnOffSwitch.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharOnOffSwitch.fromJson;

  @override
  InstanceAndOpsCtrl get dInState => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get counter => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get onTime => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get offTime => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharOnOffSwitchCopyWith<_SpecificResrcCharOnOffSwitch>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharPositioner _$SpecificResrcCharPositionerFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharPositioner.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharPositionerTearOff {
  const _$SpecificResrcCharPositionerTearOff();

  _SpecificResrcCharPositioner call(
      {required InstanceAndOpsCtrl currentPos,
      required InstanceAndOpsCtrl transTime,
      required InstanceAndOpsCtrl remainTime,
      required InstanceAndOpsCtrl minMeaValue,
      required InstanceAndOpsCtrl maxMeaValue,
      required InstanceAndOpsCtrl resetMinMaxMeaValues,
      required InstanceAndOpsCtrl minLimit,
      required InstanceAndOpsCtrl maxLimit,
      required InstanceAndOpsCtrl appType}) {
    return _SpecificResrcCharPositioner(
      currentPos: currentPos,
      transTime: transTime,
      remainTime: remainTime,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      minLimit: minLimit,
      maxLimit: maxLimit,
      appType: appType,
    );
  }

  SpecificResrcCharPositioner fromJson(Map<String, Object> json) {
    return SpecificResrcCharPositioner.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharPositioner = _$SpecificResrcCharPositionerTearOff();

/// @nodoc
mixin _$SpecificResrcCharPositioner {
  InstanceAndOpsCtrl get currentPos => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get transTime => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get remainTime => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get minMeaValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get maxMeaValue => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get resetMinMaxMeaValues =>
      throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get minLimit => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get maxLimit => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharPositionerCopyWith<SpecificResrcCharPositioner>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharPositionerCopyWith<$Res> {
  factory $SpecificResrcCharPositionerCopyWith(
          SpecificResrcCharPositioner value,
          $Res Function(SpecificResrcCharPositioner) then) =
      _$SpecificResrcCharPositionerCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl currentPos,
      InstanceAndOpsCtrl transTime,
      InstanceAndOpsCtrl remainTime,
      InstanceAndOpsCtrl minMeaValue,
      InstanceAndOpsCtrl maxMeaValue,
      InstanceAndOpsCtrl resetMinMaxMeaValues,
      InstanceAndOpsCtrl minLimit,
      InstanceAndOpsCtrl maxLimit,
      InstanceAndOpsCtrl appType});

  $InstanceAndOpsCtrlCopyWith<$Res> get currentPos;
  $InstanceAndOpsCtrlCopyWith<$Res> get transTime;
  $InstanceAndOpsCtrlCopyWith<$Res> get remainTime;
  $InstanceAndOpsCtrlCopyWith<$Res> get minMeaValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get maxMeaValue;
  $InstanceAndOpsCtrlCopyWith<$Res> get resetMinMaxMeaValues;
  $InstanceAndOpsCtrlCopyWith<$Res> get minLimit;
  $InstanceAndOpsCtrlCopyWith<$Res> get maxLimit;
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class _$SpecificResrcCharPositionerCopyWithImpl<$Res>
    implements $SpecificResrcCharPositionerCopyWith<$Res> {
  _$SpecificResrcCharPositionerCopyWithImpl(this._value, this._then);

  final SpecificResrcCharPositioner _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharPositioner) _then;

  @override
  $Res call({
    Object? currentPos = freezed,
    Object? transTime = freezed,
    Object? remainTime = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? minLimit = freezed,
    Object? maxLimit = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      currentPos: currentPos == freezed
          ? _value.currentPos
          : currentPos // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      transTime: transTime == freezed
          ? _value.transTime
          : transTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      remainTime: remainTime == freezed
          ? _value.remainTime
          : remainTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      minLimit: minLimit == freezed
          ? _value.minLimit
          : minLimit // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      maxLimit: maxLimit == freezed
          ? _value.maxLimit
          : maxLimit // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get currentPos {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.currentPos, (value) {
      return _then(_value.copyWith(currentPos: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get transTime {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.transTime, (value) {
      return _then(_value.copyWith(transTime: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get remainTime {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.remainTime, (value) {
      return _then(_value.copyWith(remainTime: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get minMeaValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.minMeaValue, (value) {
      return _then(_value.copyWith(minMeaValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get maxMeaValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.maxMeaValue, (value) {
      return _then(_value.copyWith(maxMeaValue: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get resetMinMaxMeaValues {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.resetMinMaxMeaValues,
        (value) {
      return _then(_value.copyWith(resetMinMaxMeaValues: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get minLimit {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.minLimit, (value) {
      return _then(_value.copyWith(minLimit: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get maxLimit {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.maxLimit, (value) {
      return _then(_value.copyWith(maxLimit: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharPositionerCopyWith<$Res>
    implements $SpecificResrcCharPositionerCopyWith<$Res> {
  factory _$SpecificResrcCharPositionerCopyWith(
          _SpecificResrcCharPositioner value,
          $Res Function(_SpecificResrcCharPositioner) then) =
      __$SpecificResrcCharPositionerCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl currentPos,
      InstanceAndOpsCtrl transTime,
      InstanceAndOpsCtrl remainTime,
      InstanceAndOpsCtrl minMeaValue,
      InstanceAndOpsCtrl maxMeaValue,
      InstanceAndOpsCtrl resetMinMaxMeaValues,
      InstanceAndOpsCtrl minLimit,
      InstanceAndOpsCtrl maxLimit,
      InstanceAndOpsCtrl appType});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get currentPos;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get transTime;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get remainTime;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get minMeaValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get maxMeaValue;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get resetMinMaxMeaValues;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get minLimit;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get maxLimit;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class __$SpecificResrcCharPositionerCopyWithImpl<$Res>
    extends _$SpecificResrcCharPositionerCopyWithImpl<$Res>
    implements _$SpecificResrcCharPositionerCopyWith<$Res> {
  __$SpecificResrcCharPositionerCopyWithImpl(
      _SpecificResrcCharPositioner _value,
      $Res Function(_SpecificResrcCharPositioner) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharPositioner));

  @override
  _SpecificResrcCharPositioner get _value =>
      super._value as _SpecificResrcCharPositioner;

  @override
  $Res call({
    Object? currentPos = freezed,
    Object? transTime = freezed,
    Object? remainTime = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? minLimit = freezed,
    Object? maxLimit = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificResrcCharPositioner(
      currentPos: currentPos == freezed
          ? _value.currentPos
          : currentPos // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      transTime: transTime == freezed
          ? _value.transTime
          : transTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      remainTime: remainTime == freezed
          ? _value.remainTime
          : remainTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      minLimit: minLimit == freezed
          ? _value.minLimit
          : minLimit // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      maxLimit: maxLimit == freezed
          ? _value.maxLimit
          : maxLimit // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharPositioner implements _SpecificResrcCharPositioner {
  const _$_SpecificResrcCharPositioner(
      {required this.currentPos,
      required this.transTime,
      required this.remainTime,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.resetMinMaxMeaValues,
      required this.minLimit,
      required this.maxLimit,
      required this.appType});

  factory _$_SpecificResrcCharPositioner.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharPositionerFromJson(json);

  @override
  final InstanceAndOpsCtrl currentPos;
  @override
  final InstanceAndOpsCtrl transTime;
  @override
  final InstanceAndOpsCtrl remainTime;
  @override
  final InstanceAndOpsCtrl minMeaValue;
  @override
  final InstanceAndOpsCtrl maxMeaValue;
  @override
  final InstanceAndOpsCtrl resetMinMaxMeaValues;
  @override
  final InstanceAndOpsCtrl minLimit;
  @override
  final InstanceAndOpsCtrl maxLimit;
  @override
  final InstanceAndOpsCtrl appType;

  @override
  String toString() {
    return 'SpecificResrcCharPositioner(currentPos: $currentPos, transTime: $transTime, remainTime: $remainTime, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, minLimit: $minLimit, maxLimit: $maxLimit, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharPositioner &&
            (identical(other.currentPos, currentPos) ||
                const DeepCollectionEquality()
                    .equals(other.currentPos, currentPos)) &&
            (identical(other.transTime, transTime) ||
                const DeepCollectionEquality()
                    .equals(other.transTime, transTime)) &&
            (identical(other.remainTime, remainTime) ||
                const DeepCollectionEquality()
                    .equals(other.remainTime, remainTime)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.minLimit, minLimit) ||
                const DeepCollectionEquality()
                    .equals(other.minLimit, minLimit)) &&
            (identical(other.maxLimit, maxLimit) ||
                const DeepCollectionEquality()
                    .equals(other.maxLimit, maxLimit)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(currentPos) ^
      const DeepCollectionEquality().hash(transTime) ^
      const DeepCollectionEquality().hash(remainTime) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(minLimit) ^
      const DeepCollectionEquality().hash(maxLimit) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharPositionerCopyWith<_SpecificResrcCharPositioner>
      get copyWith => __$SpecificResrcCharPositionerCopyWithImpl<
          _SpecificResrcCharPositioner>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharPositionerToJson(this);
  }
}

abstract class _SpecificResrcCharPositioner
    implements SpecificResrcCharPositioner {
  const factory _SpecificResrcCharPositioner(
      {required InstanceAndOpsCtrl currentPos,
      required InstanceAndOpsCtrl transTime,
      required InstanceAndOpsCtrl remainTime,
      required InstanceAndOpsCtrl minMeaValue,
      required InstanceAndOpsCtrl maxMeaValue,
      required InstanceAndOpsCtrl resetMinMaxMeaValues,
      required InstanceAndOpsCtrl minLimit,
      required InstanceAndOpsCtrl maxLimit,
      required InstanceAndOpsCtrl appType}) = _$_SpecificResrcCharPositioner;

  factory _SpecificResrcCharPositioner.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharPositioner.fromJson;

  @override
  InstanceAndOpsCtrl get currentPos => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get transTime => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get remainTime => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get minMeaValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get maxMeaValue => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get resetMinMaxMeaValues =>
      throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get minLimit => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get maxLimit => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharPositionerCopyWith<_SpecificResrcCharPositioner>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharPresence _$SpecificResrcCharPresenceFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharPresence.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharPresenceTearOff {
  const _$SpecificResrcCharPresenceTearOff();

  _SpecificResrcCharPresence call(
      {required InstanceAndOpsCtrl dInState,
      required InstanceAndOpsCtrl counter,
      required InstanceAndOpsCtrl counterReset,
      required InstanceAndOpsCtrl sensorType,
      required InstanceAndOpsCtrl busyToClearDelay,
      required InstanceAndOpsCtrl clearToBusyDelay}) {
    return _SpecificResrcCharPresence(
      dInState: dInState,
      counter: counter,
      counterReset: counterReset,
      sensorType: sensorType,
      busyToClearDelay: busyToClearDelay,
      clearToBusyDelay: clearToBusyDelay,
    );
  }

  SpecificResrcCharPresence fromJson(Map<String, Object> json) {
    return SpecificResrcCharPresence.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharPresence = _$SpecificResrcCharPresenceTearOff();

/// @nodoc
mixin _$SpecificResrcCharPresence {
  InstanceAndOpsCtrl get dInState => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get counter => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get counterReset => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get sensorType => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get busyToClearDelay => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get clearToBusyDelay => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharPresenceCopyWith<SpecificResrcCharPresence> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharPresenceCopyWith<$Res> {
  factory $SpecificResrcCharPresenceCopyWith(SpecificResrcCharPresence value,
          $Res Function(SpecificResrcCharPresence) then) =
      _$SpecificResrcCharPresenceCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl dInState,
      InstanceAndOpsCtrl counter,
      InstanceAndOpsCtrl counterReset,
      InstanceAndOpsCtrl sensorType,
      InstanceAndOpsCtrl busyToClearDelay,
      InstanceAndOpsCtrl clearToBusyDelay});

  $InstanceAndOpsCtrlCopyWith<$Res> get dInState;
  $InstanceAndOpsCtrlCopyWith<$Res> get counter;
  $InstanceAndOpsCtrlCopyWith<$Res> get counterReset;
  $InstanceAndOpsCtrlCopyWith<$Res> get sensorType;
  $InstanceAndOpsCtrlCopyWith<$Res> get busyToClearDelay;
  $InstanceAndOpsCtrlCopyWith<$Res> get clearToBusyDelay;
}

/// @nodoc
class _$SpecificResrcCharPresenceCopyWithImpl<$Res>
    implements $SpecificResrcCharPresenceCopyWith<$Res> {
  _$SpecificResrcCharPresenceCopyWithImpl(this._value, this._then);

  final SpecificResrcCharPresence _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharPresence) _then;

  @override
  $Res call({
    Object? dInState = freezed,
    Object? counter = freezed,
    Object? counterReset = freezed,
    Object? sensorType = freezed,
    Object? busyToClearDelay = freezed,
    Object? clearToBusyDelay = freezed,
  }) {
    return _then(_value.copyWith(
      dInState: dInState == freezed
          ? _value.dInState
          : dInState // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      counterReset: counterReset == freezed
          ? _value.counterReset
          : counterReset // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      sensorType: sensorType == freezed
          ? _value.sensorType
          : sensorType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      busyToClearDelay: busyToClearDelay == freezed
          ? _value.busyToClearDelay
          : busyToClearDelay // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      clearToBusyDelay: clearToBusyDelay == freezed
          ? _value.clearToBusyDelay
          : clearToBusyDelay // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dInState {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.dInState, (value) {
      return _then(_value.copyWith(dInState: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get counter {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.counter, (value) {
      return _then(_value.copyWith(counter: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get counterReset {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.counterReset, (value) {
      return _then(_value.copyWith(counterReset: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get sensorType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.sensorType, (value) {
      return _then(_value.copyWith(sensorType: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get busyToClearDelay {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.busyToClearDelay, (value) {
      return _then(_value.copyWith(busyToClearDelay: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get clearToBusyDelay {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.clearToBusyDelay, (value) {
      return _then(_value.copyWith(clearToBusyDelay: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharPresenceCopyWith<$Res>
    implements $SpecificResrcCharPresenceCopyWith<$Res> {
  factory _$SpecificResrcCharPresenceCopyWith(_SpecificResrcCharPresence value,
          $Res Function(_SpecificResrcCharPresence) then) =
      __$SpecificResrcCharPresenceCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl dInState,
      InstanceAndOpsCtrl counter,
      InstanceAndOpsCtrl counterReset,
      InstanceAndOpsCtrl sensorType,
      InstanceAndOpsCtrl busyToClearDelay,
      InstanceAndOpsCtrl clearToBusyDelay});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dInState;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get counter;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get counterReset;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get sensorType;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get busyToClearDelay;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get clearToBusyDelay;
}

/// @nodoc
class __$SpecificResrcCharPresenceCopyWithImpl<$Res>
    extends _$SpecificResrcCharPresenceCopyWithImpl<$Res>
    implements _$SpecificResrcCharPresenceCopyWith<$Res> {
  __$SpecificResrcCharPresenceCopyWithImpl(_SpecificResrcCharPresence _value,
      $Res Function(_SpecificResrcCharPresence) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharPresence));

  @override
  _SpecificResrcCharPresence get _value =>
      super._value as _SpecificResrcCharPresence;

  @override
  $Res call({
    Object? dInState = freezed,
    Object? counter = freezed,
    Object? counterReset = freezed,
    Object? sensorType = freezed,
    Object? busyToClearDelay = freezed,
    Object? clearToBusyDelay = freezed,
  }) {
    return _then(_SpecificResrcCharPresence(
      dInState: dInState == freezed
          ? _value.dInState
          : dInState // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      counterReset: counterReset == freezed
          ? _value.counterReset
          : counterReset // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      sensorType: sensorType == freezed
          ? _value.sensorType
          : sensorType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      busyToClearDelay: busyToClearDelay == freezed
          ? _value.busyToClearDelay
          : busyToClearDelay // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      clearToBusyDelay: clearToBusyDelay == freezed
          ? _value.clearToBusyDelay
          : clearToBusyDelay // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharPresence implements _SpecificResrcCharPresence {
  const _$_SpecificResrcCharPresence(
      {required this.dInState,
      required this.counter,
      required this.counterReset,
      required this.sensorType,
      required this.busyToClearDelay,
      required this.clearToBusyDelay});

  factory _$_SpecificResrcCharPresence.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharPresenceFromJson(json);

  @override
  final InstanceAndOpsCtrl dInState;
  @override
  final InstanceAndOpsCtrl counter;
  @override
  final InstanceAndOpsCtrl counterReset;
  @override
  final InstanceAndOpsCtrl sensorType;
  @override
  final InstanceAndOpsCtrl busyToClearDelay;
  @override
  final InstanceAndOpsCtrl clearToBusyDelay;

  @override
  String toString() {
    return 'SpecificResrcCharPresence(dInState: $dInState, counter: $counter, counterReset: $counterReset, sensorType: $sensorType, busyToClearDelay: $busyToClearDelay, clearToBusyDelay: $clearToBusyDelay)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharPresence &&
            (identical(other.dInState, dInState) ||
                const DeepCollectionEquality()
                    .equals(other.dInState, dInState)) &&
            (identical(other.counter, counter) ||
                const DeepCollectionEquality()
                    .equals(other.counter, counter)) &&
            (identical(other.counterReset, counterReset) ||
                const DeepCollectionEquality()
                    .equals(other.counterReset, counterReset)) &&
            (identical(other.sensorType, sensorType) ||
                const DeepCollectionEquality()
                    .equals(other.sensorType, sensorType)) &&
            (identical(other.busyToClearDelay, busyToClearDelay) ||
                const DeepCollectionEquality()
                    .equals(other.busyToClearDelay, busyToClearDelay)) &&
            (identical(other.clearToBusyDelay, clearToBusyDelay) ||
                const DeepCollectionEquality()
                    .equals(other.clearToBusyDelay, clearToBusyDelay)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(dInState) ^
      const DeepCollectionEquality().hash(counter) ^
      const DeepCollectionEquality().hash(counterReset) ^
      const DeepCollectionEquality().hash(sensorType) ^
      const DeepCollectionEquality().hash(busyToClearDelay) ^
      const DeepCollectionEquality().hash(clearToBusyDelay);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharPresenceCopyWith<_SpecificResrcCharPresence>
      get copyWith =>
          __$SpecificResrcCharPresenceCopyWithImpl<_SpecificResrcCharPresence>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharPresenceToJson(this);
  }
}

abstract class _SpecificResrcCharPresence implements SpecificResrcCharPresence {
  const factory _SpecificResrcCharPresence(
          {required InstanceAndOpsCtrl dInState,
          required InstanceAndOpsCtrl counter,
          required InstanceAndOpsCtrl counterReset,
          required InstanceAndOpsCtrl sensorType,
          required InstanceAndOpsCtrl busyToClearDelay,
          required InstanceAndOpsCtrl clearToBusyDelay}) =
      _$_SpecificResrcCharPresence;

  factory _SpecificResrcCharPresence.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharPresence.fromJson;

  @override
  InstanceAndOpsCtrl get dInState => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get counter => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get counterReset => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get sensorType => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get busyToClearDelay => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get clearToBusyDelay => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharPresenceCopyWith<_SpecificResrcCharPresence>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharPushButton _$SpecificResrcCharPushButtonFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharPushButton.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharPushButtonTearOff {
  const _$SpecificResrcCharPushButtonTearOff();

  _SpecificResrcCharPushButton call(
      {required InstanceAndOpsCtrl dInState,
      required InstanceAndOpsCtrl counter,
      required InstanceAndOpsCtrl appType}) {
    return _SpecificResrcCharPushButton(
      dInState: dInState,
      counter: counter,
      appType: appType,
    );
  }

  SpecificResrcCharPushButton fromJson(Map<String, Object> json) {
    return SpecificResrcCharPushButton.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharPushButton = _$SpecificResrcCharPushButtonTearOff();

/// @nodoc
mixin _$SpecificResrcCharPushButton {
  InstanceAndOpsCtrl get dInState => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get counter => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharPushButtonCopyWith<SpecificResrcCharPushButton>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharPushButtonCopyWith<$Res> {
  factory $SpecificResrcCharPushButtonCopyWith(
          SpecificResrcCharPushButton value,
          $Res Function(SpecificResrcCharPushButton) then) =
      _$SpecificResrcCharPushButtonCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl dInState,
      InstanceAndOpsCtrl counter,
      InstanceAndOpsCtrl appType});

  $InstanceAndOpsCtrlCopyWith<$Res> get dInState;
  $InstanceAndOpsCtrlCopyWith<$Res> get counter;
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class _$SpecificResrcCharPushButtonCopyWithImpl<$Res>
    implements $SpecificResrcCharPushButtonCopyWith<$Res> {
  _$SpecificResrcCharPushButtonCopyWithImpl(this._value, this._then);

  final SpecificResrcCharPushButton _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharPushButton) _then;

  @override
  $Res call({
    Object? dInState = freezed,
    Object? counter = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      dInState: dInState == freezed
          ? _value.dInState
          : dInState // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dInState {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.dInState, (value) {
      return _then(_value.copyWith(dInState: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get counter {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.counter, (value) {
      return _then(_value.copyWith(counter: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharPushButtonCopyWith<$Res>
    implements $SpecificResrcCharPushButtonCopyWith<$Res> {
  factory _$SpecificResrcCharPushButtonCopyWith(
          _SpecificResrcCharPushButton value,
          $Res Function(_SpecificResrcCharPushButton) then) =
      __$SpecificResrcCharPushButtonCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl dInState,
      InstanceAndOpsCtrl counter,
      InstanceAndOpsCtrl appType});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dInState;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get counter;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class __$SpecificResrcCharPushButtonCopyWithImpl<$Res>
    extends _$SpecificResrcCharPushButtonCopyWithImpl<$Res>
    implements _$SpecificResrcCharPushButtonCopyWith<$Res> {
  __$SpecificResrcCharPushButtonCopyWithImpl(
      _SpecificResrcCharPushButton _value,
      $Res Function(_SpecificResrcCharPushButton) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharPushButton));

  @override
  _SpecificResrcCharPushButton get _value =>
      super._value as _SpecificResrcCharPushButton;

  @override
  $Res call({
    Object? dInState = freezed,
    Object? counter = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificResrcCharPushButton(
      dInState: dInState == freezed
          ? _value.dInState
          : dInState // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharPushButton implements _SpecificResrcCharPushButton {
  const _$_SpecificResrcCharPushButton(
      {required this.dInState, required this.counter, required this.appType});

  factory _$_SpecificResrcCharPushButton.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharPushButtonFromJson(json);

  @override
  final InstanceAndOpsCtrl dInState;
  @override
  final InstanceAndOpsCtrl counter;
  @override
  final InstanceAndOpsCtrl appType;

  @override
  String toString() {
    return 'SpecificResrcCharPushButton(dInState: $dInState, counter: $counter, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharPushButton &&
            (identical(other.dInState, dInState) ||
                const DeepCollectionEquality()
                    .equals(other.dInState, dInState)) &&
            (identical(other.counter, counter) ||
                const DeepCollectionEquality()
                    .equals(other.counter, counter)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(dInState) ^
      const DeepCollectionEquality().hash(counter) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharPushButtonCopyWith<_SpecificResrcCharPushButton>
      get copyWith => __$SpecificResrcCharPushButtonCopyWithImpl<
          _SpecificResrcCharPushButton>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharPushButtonToJson(this);
  }
}

abstract class _SpecificResrcCharPushButton
    implements SpecificResrcCharPushButton {
  const factory _SpecificResrcCharPushButton(
      {required InstanceAndOpsCtrl dInState,
      required InstanceAndOpsCtrl counter,
      required InstanceAndOpsCtrl appType}) = _$_SpecificResrcCharPushButton;

  factory _SpecificResrcCharPushButton.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharPushButton.fromJson;

  @override
  InstanceAndOpsCtrl get dInState => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get counter => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharPushButtonCopyWith<_SpecificResrcCharPushButton>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharPwrCtrl _$SpecificResrcCharPwrCtrlFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharPwrCtrl.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharPwrCtrlTearOff {
  const _$SpecificResrcCharPwrCtrlTearOff();

  _SpecificResrcCharPwrCtrl call(
      {required InstanceAndOpsCtrl onOff,
      required InstanceAndOpsCtrl dimmer,
      required InstanceAndOpsCtrl onTime,
      required InstanceAndOpsCtrl cumulActivePwr,
      required InstanceAndOpsCtrl pwrFactor}) {
    return _SpecificResrcCharPwrCtrl(
      onOff: onOff,
      dimmer: dimmer,
      onTime: onTime,
      cumulActivePwr: cumulActivePwr,
      pwrFactor: pwrFactor,
    );
  }

  SpecificResrcCharPwrCtrl fromJson(Map<String, Object> json) {
    return SpecificResrcCharPwrCtrl.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharPwrCtrl = _$SpecificResrcCharPwrCtrlTearOff();

/// @nodoc
mixin _$SpecificResrcCharPwrCtrl {
  InstanceAndOpsCtrl get onOff => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get dimmer => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get onTime => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get cumulActivePwr => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get pwrFactor => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharPwrCtrlCopyWith<SpecificResrcCharPwrCtrl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharPwrCtrlCopyWith<$Res> {
  factory $SpecificResrcCharPwrCtrlCopyWith(SpecificResrcCharPwrCtrl value,
          $Res Function(SpecificResrcCharPwrCtrl) then) =
      _$SpecificResrcCharPwrCtrlCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl onOff,
      InstanceAndOpsCtrl dimmer,
      InstanceAndOpsCtrl onTime,
      InstanceAndOpsCtrl cumulActivePwr,
      InstanceAndOpsCtrl pwrFactor});

  $InstanceAndOpsCtrlCopyWith<$Res> get onOff;
  $InstanceAndOpsCtrlCopyWith<$Res> get dimmer;
  $InstanceAndOpsCtrlCopyWith<$Res> get onTime;
  $InstanceAndOpsCtrlCopyWith<$Res> get cumulActivePwr;
  $InstanceAndOpsCtrlCopyWith<$Res> get pwrFactor;
}

/// @nodoc
class _$SpecificResrcCharPwrCtrlCopyWithImpl<$Res>
    implements $SpecificResrcCharPwrCtrlCopyWith<$Res> {
  _$SpecificResrcCharPwrCtrlCopyWithImpl(this._value, this._then);

  final SpecificResrcCharPwrCtrl _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharPwrCtrl) _then;

  @override
  $Res call({
    Object? onOff = freezed,
    Object? dimmer = freezed,
    Object? onTime = freezed,
    Object? cumulActivePwr = freezed,
    Object? pwrFactor = freezed,
  }) {
    return _then(_value.copyWith(
      onOff: onOff == freezed
          ? _value.onOff
          : onOff // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      dimmer: dimmer == freezed
          ? _value.dimmer
          : dimmer // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      onTime: onTime == freezed
          ? _value.onTime
          : onTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      cumulActivePwr: cumulActivePwr == freezed
          ? _value.cumulActivePwr
          : cumulActivePwr // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      pwrFactor: pwrFactor == freezed
          ? _value.pwrFactor
          : pwrFactor // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get onOff {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.onOff, (value) {
      return _then(_value.copyWith(onOff: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dimmer {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.dimmer, (value) {
      return _then(_value.copyWith(dimmer: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get onTime {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.onTime, (value) {
      return _then(_value.copyWith(onTime: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get cumulActivePwr {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.cumulActivePwr, (value) {
      return _then(_value.copyWith(cumulActivePwr: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get pwrFactor {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.pwrFactor, (value) {
      return _then(_value.copyWith(pwrFactor: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharPwrCtrlCopyWith<$Res>
    implements $SpecificResrcCharPwrCtrlCopyWith<$Res> {
  factory _$SpecificResrcCharPwrCtrlCopyWith(_SpecificResrcCharPwrCtrl value,
          $Res Function(_SpecificResrcCharPwrCtrl) then) =
      __$SpecificResrcCharPwrCtrlCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl onOff,
      InstanceAndOpsCtrl dimmer,
      InstanceAndOpsCtrl onTime,
      InstanceAndOpsCtrl cumulActivePwr,
      InstanceAndOpsCtrl pwrFactor});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get onOff;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get dimmer;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get onTime;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get cumulActivePwr;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get pwrFactor;
}

/// @nodoc
class __$SpecificResrcCharPwrCtrlCopyWithImpl<$Res>
    extends _$SpecificResrcCharPwrCtrlCopyWithImpl<$Res>
    implements _$SpecificResrcCharPwrCtrlCopyWith<$Res> {
  __$SpecificResrcCharPwrCtrlCopyWithImpl(_SpecificResrcCharPwrCtrl _value,
      $Res Function(_SpecificResrcCharPwrCtrl) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharPwrCtrl));

  @override
  _SpecificResrcCharPwrCtrl get _value =>
      super._value as _SpecificResrcCharPwrCtrl;

  @override
  $Res call({
    Object? onOff = freezed,
    Object? dimmer = freezed,
    Object? onTime = freezed,
    Object? cumulActivePwr = freezed,
    Object? pwrFactor = freezed,
  }) {
    return _then(_SpecificResrcCharPwrCtrl(
      onOff: onOff == freezed
          ? _value.onOff
          : onOff // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      dimmer: dimmer == freezed
          ? _value.dimmer
          : dimmer // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      onTime: onTime == freezed
          ? _value.onTime
          : onTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      cumulActivePwr: cumulActivePwr == freezed
          ? _value.cumulActivePwr
          : cumulActivePwr // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      pwrFactor: pwrFactor == freezed
          ? _value.pwrFactor
          : pwrFactor // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharPwrCtrl implements _SpecificResrcCharPwrCtrl {
  const _$_SpecificResrcCharPwrCtrl(
      {required this.onOff,
      required this.dimmer,
      required this.onTime,
      required this.cumulActivePwr,
      required this.pwrFactor});

  factory _$_SpecificResrcCharPwrCtrl.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharPwrCtrlFromJson(json);

  @override
  final InstanceAndOpsCtrl onOff;
  @override
  final InstanceAndOpsCtrl dimmer;
  @override
  final InstanceAndOpsCtrl onTime;
  @override
  final InstanceAndOpsCtrl cumulActivePwr;
  @override
  final InstanceAndOpsCtrl pwrFactor;

  @override
  String toString() {
    return 'SpecificResrcCharPwrCtrl(onOff: $onOff, dimmer: $dimmer, onTime: $onTime, cumulActivePwr: $cumulActivePwr, pwrFactor: $pwrFactor)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharPwrCtrl &&
            (identical(other.onOff, onOff) ||
                const DeepCollectionEquality().equals(other.onOff, onOff)) &&
            (identical(other.dimmer, dimmer) ||
                const DeepCollectionEquality().equals(other.dimmer, dimmer)) &&
            (identical(other.onTime, onTime) ||
                const DeepCollectionEquality().equals(other.onTime, onTime)) &&
            (identical(other.cumulActivePwr, cumulActivePwr) ||
                const DeepCollectionEquality()
                    .equals(other.cumulActivePwr, cumulActivePwr)) &&
            (identical(other.pwrFactor, pwrFactor) ||
                const DeepCollectionEquality()
                    .equals(other.pwrFactor, pwrFactor)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(onOff) ^
      const DeepCollectionEquality().hash(dimmer) ^
      const DeepCollectionEquality().hash(onTime) ^
      const DeepCollectionEquality().hash(cumulActivePwr) ^
      const DeepCollectionEquality().hash(pwrFactor);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharPwrCtrlCopyWith<_SpecificResrcCharPwrCtrl> get copyWith =>
      __$SpecificResrcCharPwrCtrlCopyWithImpl<_SpecificResrcCharPwrCtrl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharPwrCtrlToJson(this);
  }
}

abstract class _SpecificResrcCharPwrCtrl implements SpecificResrcCharPwrCtrl {
  const factory _SpecificResrcCharPwrCtrl(
      {required InstanceAndOpsCtrl onOff,
      required InstanceAndOpsCtrl dimmer,
      required InstanceAndOpsCtrl onTime,
      required InstanceAndOpsCtrl cumulActivePwr,
      required InstanceAndOpsCtrl pwrFactor}) = _$_SpecificResrcCharPwrCtrl;

  factory _SpecificResrcCharPwrCtrl.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharPwrCtrl.fromJson;

  @override
  InstanceAndOpsCtrl get onOff => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get dimmer => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get onTime => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get cumulActivePwr => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get pwrFactor => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharPwrCtrlCopyWith<_SpecificResrcCharPwrCtrl> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificResrcCharSetPoint _$SpecificResrcCharSetPointFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharSetPoint.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharSetPointTearOff {
  const _$SpecificResrcCharSetPointTearOff();

  _SpecificResrcCharSetPoint call(
      {required InstanceAndOpsCtrl colour,
      required InstanceAndOpsCtrl units,
      required InstanceAndOpsCtrl appType,
      required InstanceAndOpsCtrl setPointValue}) {
    return _SpecificResrcCharSetPoint(
      colour: colour,
      units: units,
      appType: appType,
      setPointValue: setPointValue,
    );
  }

  SpecificResrcCharSetPoint fromJson(Map<String, Object> json) {
    return SpecificResrcCharSetPoint.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharSetPoint = _$SpecificResrcCharSetPointTearOff();

/// @nodoc
mixin _$SpecificResrcCharSetPoint {
  InstanceAndOpsCtrl get colour => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get units => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get setPointValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharSetPointCopyWith<SpecificResrcCharSetPoint> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharSetPointCopyWith<$Res> {
  factory $SpecificResrcCharSetPointCopyWith(SpecificResrcCharSetPoint value,
          $Res Function(SpecificResrcCharSetPoint) then) =
      _$SpecificResrcCharSetPointCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl colour,
      InstanceAndOpsCtrl units,
      InstanceAndOpsCtrl appType,
      InstanceAndOpsCtrl setPointValue});

  $InstanceAndOpsCtrlCopyWith<$Res> get colour;
  $InstanceAndOpsCtrlCopyWith<$Res> get units;
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
  $InstanceAndOpsCtrlCopyWith<$Res> get setPointValue;
}

/// @nodoc
class _$SpecificResrcCharSetPointCopyWithImpl<$Res>
    implements $SpecificResrcCharSetPointCopyWith<$Res> {
  _$SpecificResrcCharSetPointCopyWithImpl(this._value, this._then);

  final SpecificResrcCharSetPoint _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharSetPoint) _then;

  @override
  $Res call({
    Object? colour = freezed,
    Object? units = freezed,
    Object? appType = freezed,
    Object? setPointValue = freezed,
  }) {
    return _then(_value.copyWith(
      colour: colour == freezed
          ? _value.colour
          : colour // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      setPointValue: setPointValue == freezed
          ? _value.setPointValue
          : setPointValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get colour {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.colour, (value) {
      return _then(_value.copyWith(colour: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get units {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.units, (value) {
      return _then(_value.copyWith(units: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get setPointValue {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.setPointValue, (value) {
      return _then(_value.copyWith(setPointValue: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharSetPointCopyWith<$Res>
    implements $SpecificResrcCharSetPointCopyWith<$Res> {
  factory _$SpecificResrcCharSetPointCopyWith(_SpecificResrcCharSetPoint value,
          $Res Function(_SpecificResrcCharSetPoint) then) =
      __$SpecificResrcCharSetPointCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl colour,
      InstanceAndOpsCtrl units,
      InstanceAndOpsCtrl appType,
      InstanceAndOpsCtrl setPointValue});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get colour;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get units;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get setPointValue;
}

/// @nodoc
class __$SpecificResrcCharSetPointCopyWithImpl<$Res>
    extends _$SpecificResrcCharSetPointCopyWithImpl<$Res>
    implements _$SpecificResrcCharSetPointCopyWith<$Res> {
  __$SpecificResrcCharSetPointCopyWithImpl(_SpecificResrcCharSetPoint _value,
      $Res Function(_SpecificResrcCharSetPoint) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharSetPoint));

  @override
  _SpecificResrcCharSetPoint get _value =>
      super._value as _SpecificResrcCharSetPoint;

  @override
  $Res call({
    Object? colour = freezed,
    Object? units = freezed,
    Object? appType = freezed,
    Object? setPointValue = freezed,
  }) {
    return _then(_SpecificResrcCharSetPoint(
      colour: colour == freezed
          ? _value.colour
          : colour // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      setPointValue: setPointValue == freezed
          ? _value.setPointValue
          : setPointValue // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharSetPoint implements _SpecificResrcCharSetPoint {
  const _$_SpecificResrcCharSetPoint(
      {required this.colour,
      required this.units,
      required this.appType,
      required this.setPointValue});

  factory _$_SpecificResrcCharSetPoint.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharSetPointFromJson(json);

  @override
  final InstanceAndOpsCtrl colour;
  @override
  final InstanceAndOpsCtrl units;
  @override
  final InstanceAndOpsCtrl appType;
  @override
  final InstanceAndOpsCtrl setPointValue;

  @override
  String toString() {
    return 'SpecificResrcCharSetPoint(colour: $colour, units: $units, appType: $appType, setPointValue: $setPointValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharSetPoint &&
            (identical(other.colour, colour) ||
                const DeepCollectionEquality().equals(other.colour, colour)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality()
                    .equals(other.appType, appType)) &&
            (identical(other.setPointValue, setPointValue) ||
                const DeepCollectionEquality()
                    .equals(other.setPointValue, setPointValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(colour) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(appType) ^
      const DeepCollectionEquality().hash(setPointValue);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharSetPointCopyWith<_SpecificResrcCharSetPoint>
      get copyWith =>
          __$SpecificResrcCharSetPointCopyWithImpl<_SpecificResrcCharSetPoint>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharSetPointToJson(this);
  }
}

abstract class _SpecificResrcCharSetPoint implements SpecificResrcCharSetPoint {
  const factory _SpecificResrcCharSetPoint(
          {required InstanceAndOpsCtrl colour,
          required InstanceAndOpsCtrl units,
          required InstanceAndOpsCtrl appType,
          required InstanceAndOpsCtrl setPointValue}) =
      _$_SpecificResrcCharSetPoint;

  factory _SpecificResrcCharSetPoint.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharSetPoint.fromJson;

  @override
  InstanceAndOpsCtrl get colour => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get units => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get setPointValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharSetPointCopyWith<_SpecificResrcCharSetPoint>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificResrcCharTime _$SpecificResrcCharTimeFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharTime.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharTimeTearOff {
  const _$SpecificResrcCharTimeTearOff();

  _SpecificResrcCharTime call(
      {required InstanceAndOpsCtrl currentTime,
      required InstanceAndOpsCtrl fracTime,
      required InstanceAndOpsCtrl appType}) {
    return _SpecificResrcCharTime(
      currentTime: currentTime,
      fracTime: fracTime,
      appType: appType,
    );
  }

  SpecificResrcCharTime fromJson(Map<String, Object> json) {
    return SpecificResrcCharTime.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharTime = _$SpecificResrcCharTimeTearOff();

/// @nodoc
mixin _$SpecificResrcCharTime {
  InstanceAndOpsCtrl get currentTime => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get fracTime => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharTimeCopyWith<SpecificResrcCharTime> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharTimeCopyWith<$Res> {
  factory $SpecificResrcCharTimeCopyWith(SpecificResrcCharTime value,
          $Res Function(SpecificResrcCharTime) then) =
      _$SpecificResrcCharTimeCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl currentTime,
      InstanceAndOpsCtrl fracTime,
      InstanceAndOpsCtrl appType});

  $InstanceAndOpsCtrlCopyWith<$Res> get currentTime;
  $InstanceAndOpsCtrlCopyWith<$Res> get fracTime;
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class _$SpecificResrcCharTimeCopyWithImpl<$Res>
    implements $SpecificResrcCharTimeCopyWith<$Res> {
  _$SpecificResrcCharTimeCopyWithImpl(this._value, this._then);

  final SpecificResrcCharTime _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharTime) _then;

  @override
  $Res call({
    Object? currentTime = freezed,
    Object? fracTime = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      currentTime: currentTime == freezed
          ? _value.currentTime
          : currentTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      fracTime: fracTime == freezed
          ? _value.fracTime
          : fracTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get currentTime {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.currentTime, (value) {
      return _then(_value.copyWith(currentTime: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get fracTime {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.fracTime, (value) {
      return _then(_value.copyWith(fracTime: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharTimeCopyWith<$Res>
    implements $SpecificResrcCharTimeCopyWith<$Res> {
  factory _$SpecificResrcCharTimeCopyWith(_SpecificResrcCharTime value,
          $Res Function(_SpecificResrcCharTime) then) =
      __$SpecificResrcCharTimeCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl currentTime,
      InstanceAndOpsCtrl fracTime,
      InstanceAndOpsCtrl appType});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get currentTime;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get fracTime;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class __$SpecificResrcCharTimeCopyWithImpl<$Res>
    extends _$SpecificResrcCharTimeCopyWithImpl<$Res>
    implements _$SpecificResrcCharTimeCopyWith<$Res> {
  __$SpecificResrcCharTimeCopyWithImpl(_SpecificResrcCharTime _value,
      $Res Function(_SpecificResrcCharTime) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharTime));

  @override
  _SpecificResrcCharTime get _value => super._value as _SpecificResrcCharTime;

  @override
  $Res call({
    Object? currentTime = freezed,
    Object? fracTime = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificResrcCharTime(
      currentTime: currentTime == freezed
          ? _value.currentTime
          : currentTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      fracTime: fracTime == freezed
          ? _value.fracTime
          : fracTime // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharTime implements _SpecificResrcCharTime {
  const _$_SpecificResrcCharTime(
      {required this.currentTime,
      required this.fracTime,
      required this.appType});

  factory _$_SpecificResrcCharTime.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificResrcCharTimeFromJson(json);

  @override
  final InstanceAndOpsCtrl currentTime;
  @override
  final InstanceAndOpsCtrl fracTime;
  @override
  final InstanceAndOpsCtrl appType;

  @override
  String toString() {
    return 'SpecificResrcCharTime(currentTime: $currentTime, fracTime: $fracTime, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharTime &&
            (identical(other.currentTime, currentTime) ||
                const DeepCollectionEquality()
                    .equals(other.currentTime, currentTime)) &&
            (identical(other.fracTime, fracTime) ||
                const DeepCollectionEquality()
                    .equals(other.fracTime, fracTime)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(currentTime) ^
      const DeepCollectionEquality().hash(fracTime) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharTimeCopyWith<_SpecificResrcCharTime> get copyWith =>
      __$SpecificResrcCharTimeCopyWithImpl<_SpecificResrcCharTime>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharTimeToJson(this);
  }
}

abstract class _SpecificResrcCharTime implements SpecificResrcCharTime {
  const factory _SpecificResrcCharTime(
      {required InstanceAndOpsCtrl currentTime,
      required InstanceAndOpsCtrl fracTime,
      required InstanceAndOpsCtrl appType}) = _$_SpecificResrcCharTime;

  factory _SpecificResrcCharTime.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharTime.fromJson;

  @override
  InstanceAndOpsCtrl get currentTime => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get fracTime => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharTimeCopyWith<_SpecificResrcCharTime> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificResrcCharUpDownControl _$SpecificResrcCharUpDownControlFromJson(
    Map<String, dynamic> json) {
  return _SpecificResrcCharUpDownControl.fromJson(json);
}

/// @nodoc
class _$SpecificResrcCharUpDownControlTearOff {
  const _$SpecificResrcCharUpDownControlTearOff();

  _SpecificResrcCharUpDownControl call(
      {required InstanceAndOpsCtrl incInputState,
      required InstanceAndOpsCtrl decInputState,
      required InstanceAndOpsCtrl upCounter,
      required InstanceAndOpsCtrl downCounter,
      required InstanceAndOpsCtrl appType}) {
    return _SpecificResrcCharUpDownControl(
      incInputState: incInputState,
      decInputState: decInputState,
      upCounter: upCounter,
      downCounter: downCounter,
      appType: appType,
    );
  }

  SpecificResrcCharUpDownControl fromJson(Map<String, Object> json) {
    return SpecificResrcCharUpDownControl.fromJson(json);
  }
}

/// @nodoc
const $SpecificResrcCharUpDownControl =
    _$SpecificResrcCharUpDownControlTearOff();

/// @nodoc
mixin _$SpecificResrcCharUpDownControl {
  InstanceAndOpsCtrl get incInputState => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get decInputState => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get upCounter => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get downCounter => throw _privateConstructorUsedError;
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificResrcCharUpDownControlCopyWith<SpecificResrcCharUpDownControl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificResrcCharUpDownControlCopyWith<$Res> {
  factory $SpecificResrcCharUpDownControlCopyWith(
          SpecificResrcCharUpDownControl value,
          $Res Function(SpecificResrcCharUpDownControl) then) =
      _$SpecificResrcCharUpDownControlCopyWithImpl<$Res>;
  $Res call(
      {InstanceAndOpsCtrl incInputState,
      InstanceAndOpsCtrl decInputState,
      InstanceAndOpsCtrl upCounter,
      InstanceAndOpsCtrl downCounter,
      InstanceAndOpsCtrl appType});

  $InstanceAndOpsCtrlCopyWith<$Res> get incInputState;
  $InstanceAndOpsCtrlCopyWith<$Res> get decInputState;
  $InstanceAndOpsCtrlCopyWith<$Res> get upCounter;
  $InstanceAndOpsCtrlCopyWith<$Res> get downCounter;
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class _$SpecificResrcCharUpDownControlCopyWithImpl<$Res>
    implements $SpecificResrcCharUpDownControlCopyWith<$Res> {
  _$SpecificResrcCharUpDownControlCopyWithImpl(this._value, this._then);

  final SpecificResrcCharUpDownControl _value;
  // ignore: unused_field
  final $Res Function(SpecificResrcCharUpDownControl) _then;

  @override
  $Res call({
    Object? incInputState = freezed,
    Object? decInputState = freezed,
    Object? upCounter = freezed,
    Object? downCounter = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      incInputState: incInputState == freezed
          ? _value.incInputState
          : incInputState // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      decInputState: decInputState == freezed
          ? _value.decInputState
          : decInputState // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      upCounter: upCounter == freezed
          ? _value.upCounter
          : upCounter // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      downCounter: downCounter == freezed
          ? _value.downCounter
          : downCounter // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get incInputState {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.incInputState, (value) {
      return _then(_value.copyWith(incInputState: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get decInputState {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.decInputState, (value) {
      return _then(_value.copyWith(decInputState: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get upCounter {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.upCounter, (value) {
      return _then(_value.copyWith(upCounter: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get downCounter {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.downCounter, (value) {
      return _then(_value.copyWith(downCounter: value));
    });
  }

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType {
    return $InstanceAndOpsCtrlCopyWith<$Res>(_value.appType, (value) {
      return _then(_value.copyWith(appType: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificResrcCharUpDownControlCopyWith<$Res>
    implements $SpecificResrcCharUpDownControlCopyWith<$Res> {
  factory _$SpecificResrcCharUpDownControlCopyWith(
          _SpecificResrcCharUpDownControl value,
          $Res Function(_SpecificResrcCharUpDownControl) then) =
      __$SpecificResrcCharUpDownControlCopyWithImpl<$Res>;
  @override
  $Res call(
      {InstanceAndOpsCtrl incInputState,
      InstanceAndOpsCtrl decInputState,
      InstanceAndOpsCtrl upCounter,
      InstanceAndOpsCtrl downCounter,
      InstanceAndOpsCtrl appType});

  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get incInputState;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get decInputState;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get upCounter;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get downCounter;
  @override
  $InstanceAndOpsCtrlCopyWith<$Res> get appType;
}

/// @nodoc
class __$SpecificResrcCharUpDownControlCopyWithImpl<$Res>
    extends _$SpecificResrcCharUpDownControlCopyWithImpl<$Res>
    implements _$SpecificResrcCharUpDownControlCopyWith<$Res> {
  __$SpecificResrcCharUpDownControlCopyWithImpl(
      _SpecificResrcCharUpDownControl _value,
      $Res Function(_SpecificResrcCharUpDownControl) _then)
      : super(_value, (v) => _then(v as _SpecificResrcCharUpDownControl));

  @override
  _SpecificResrcCharUpDownControl get _value =>
      super._value as _SpecificResrcCharUpDownControl;

  @override
  $Res call({
    Object? incInputState = freezed,
    Object? decInputState = freezed,
    Object? upCounter = freezed,
    Object? downCounter = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificResrcCharUpDownControl(
      incInputState: incInputState == freezed
          ? _value.incInputState
          : incInputState // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      decInputState: decInputState == freezed
          ? _value.decInputState
          : decInputState // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      upCounter: upCounter == freezed
          ? _value.upCounter
          : upCounter // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      downCounter: downCounter == freezed
          ? _value.downCounter
          : downCounter // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as InstanceAndOpsCtrl,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificResrcCharUpDownControl
    implements _SpecificResrcCharUpDownControl {
  const _$_SpecificResrcCharUpDownControl(
      {required this.incInputState,
      required this.decInputState,
      required this.upCounter,
      required this.downCounter,
      required this.appType});

  factory _$_SpecificResrcCharUpDownControl.fromJson(
          Map<String, dynamic> json) =>
      _$$_SpecificResrcCharUpDownControlFromJson(json);

  @override
  final InstanceAndOpsCtrl incInputState;
  @override
  final InstanceAndOpsCtrl decInputState;
  @override
  final InstanceAndOpsCtrl upCounter;
  @override
  final InstanceAndOpsCtrl downCounter;
  @override
  final InstanceAndOpsCtrl appType;

  @override
  String toString() {
    return 'SpecificResrcCharUpDownControl(incInputState: $incInputState, decInputState: $decInputState, upCounter: $upCounter, downCounter: $downCounter, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificResrcCharUpDownControl &&
            (identical(other.incInputState, incInputState) ||
                const DeepCollectionEquality()
                    .equals(other.incInputState, incInputState)) &&
            (identical(other.decInputState, decInputState) ||
                const DeepCollectionEquality()
                    .equals(other.decInputState, decInputState)) &&
            (identical(other.upCounter, upCounter) ||
                const DeepCollectionEquality()
                    .equals(other.upCounter, upCounter)) &&
            (identical(other.downCounter, downCounter) ||
                const DeepCollectionEquality()
                    .equals(other.downCounter, downCounter)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(incInputState) ^
      const DeepCollectionEquality().hash(decInputState) ^
      const DeepCollectionEquality().hash(upCounter) ^
      const DeepCollectionEquality().hash(downCounter) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificResrcCharUpDownControlCopyWith<_SpecificResrcCharUpDownControl>
      get copyWith => __$SpecificResrcCharUpDownControlCopyWithImpl<
          _SpecificResrcCharUpDownControl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificResrcCharUpDownControlToJson(this);
  }
}

abstract class _SpecificResrcCharUpDownControl
    implements SpecificResrcCharUpDownControl {
  const factory _SpecificResrcCharUpDownControl(
      {required InstanceAndOpsCtrl incInputState,
      required InstanceAndOpsCtrl decInputState,
      required InstanceAndOpsCtrl upCounter,
      required InstanceAndOpsCtrl downCounter,
      required InstanceAndOpsCtrl appType}) = _$_SpecificResrcCharUpDownControl;

  factory _SpecificResrcCharUpDownControl.fromJson(Map<String, dynamic> json) =
      _$_SpecificResrcCharUpDownControl.fromJson;

  @override
  InstanceAndOpsCtrl get incInputState => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get decInputState => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get upCounter => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get downCounter => throw _privateConstructorUsedError;
  @override
  InstanceAndOpsCtrl get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificResrcCharUpDownControlCopyWith<_SpecificResrcCharUpDownControl>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificRid _$SpecificRidFromJson(Map<String, dynamic> json) {
  return _SpecificRid.fromJson(json);
}

/// @nodoc
class _$SpecificRidTearOff {
  const _$SpecificRidTearOff();

  _SpecificRid call(
      {required SpecificRidLwm2mSecurity lwm2mSecurity,
      required SpecificRidLwm2mServer lwm2mServer,
      required SpecificRidAccessCtrl accessCtrl,
      required SpecificRidDevice device,
      required SpecificRidConnMonitor connMonitor,
      required SpecificRidFirmware firmware,
      required SpecificRidLocation location,
      required SpecificRidConnStatistics connStatistics,
      required SpecificRidDIn dIn,
      required SpecificRidDOut dOut,
      required SpecificRidAIn aIn,
      required SpecificRidAOut aOut,
      required SpecificRidGeneric generic,
      required SpecificRidIlluminance illuminance,
      required SpecificRidPresence presence,
      required SpecificRidTemperature temperature,
      required SpecificRidHumidity humidity,
      required SpecificRidPwrMea pwrMea,
      required SpecificRidActuation actuation,
      required SpecificRidSetPoint setPoint,
      required SpecificRidLoadCtrl loadCtrl,
      required SpecificRidLightCtrl lightCtrl,
      required SpecificRidPwrCtrl pwrCtrl,
      required SpecificRidAccelerometer accelerometer,
      required SpecificRidMagnetometer magnetometer,
      required SpecificRidBarometer barometer,
      required SpecificRidVoltage voltage,
      required SpecificRidCurrent current,
      required SpecificRidFrequency frequency,
      required SpecificRidDepth depth,
      required SpecificRidPercentage percentage,
      required SpecificRidAltitude altitude,
      required SpecificRidLoad load,
      required SpecificRidPressure pressure,
      required SpecificRidLoudness loudness,
      required SpecificRidConcentration concentration,
      required SpecificRidAcidity acidity,
      required SpecificRidConductivity conductivity,
      required SpecificRidPower power,
      required SpecificRidPowerFactor powerFactor,
      required SpecificRidDistance distance,
      required SpecificRidEnergy energy,
      required SpecificRidDirection direction,
      required SpecificRidTime time,
      required SpecificRidGyrometer gyrometer,
      required SpecificRidColour colour,
      required SpecificRidGpsLocation gpsLocation,
      required SpecificRidPositioner positioner,
      required SpecificRidBuzzer buzzer,
      required SpecificRidAudioClip audioClip,
      required SpecificRidTimer timer,
      required SpecificRidAddressableTextDisplay addressableTextDisplay,
      required SpecificRidOnOffSwitch onOffSwitch,
      required SpecificRidLevelControl levelControl,
      required SpecificRidUpDownControl upDownControl,
      required SpecificRidMultipleAxisJoystick multipleAxisJoystick,
      required SpecificRidRate rate,
      required SpecificRidPushButton pushButton,
      required SpecificRidMultistateSelector multistateSelector}) {
    return _SpecificRid(
      lwm2mSecurity: lwm2mSecurity,
      lwm2mServer: lwm2mServer,
      accessCtrl: accessCtrl,
      device: device,
      connMonitor: connMonitor,
      firmware: firmware,
      location: location,
      connStatistics: connStatistics,
      dIn: dIn,
      dOut: dOut,
      aIn: aIn,
      aOut: aOut,
      generic: generic,
      illuminance: illuminance,
      presence: presence,
      temperature: temperature,
      humidity: humidity,
      pwrMea: pwrMea,
      actuation: actuation,
      setPoint: setPoint,
      loadCtrl: loadCtrl,
      lightCtrl: lightCtrl,
      pwrCtrl: pwrCtrl,
      accelerometer: accelerometer,
      magnetometer: magnetometer,
      barometer: barometer,
      voltage: voltage,
      current: current,
      frequency: frequency,
      depth: depth,
      percentage: percentage,
      altitude: altitude,
      load: load,
      pressure: pressure,
      loudness: loudness,
      concentration: concentration,
      acidity: acidity,
      conductivity: conductivity,
      power: power,
      powerFactor: powerFactor,
      distance: distance,
      energy: energy,
      direction: direction,
      time: time,
      gyrometer: gyrometer,
      colour: colour,
      gpsLocation: gpsLocation,
      positioner: positioner,
      buzzer: buzzer,
      audioClip: audioClip,
      timer: timer,
      addressableTextDisplay: addressableTextDisplay,
      onOffSwitch: onOffSwitch,
      levelControl: levelControl,
      upDownControl: upDownControl,
      multipleAxisJoystick: multipleAxisJoystick,
      rate: rate,
      pushButton: pushButton,
      multistateSelector: multistateSelector,
    );
  }

  SpecificRid fromJson(Map<String, Object> json) {
    return SpecificRid.fromJson(json);
  }
}

/// @nodoc
const $SpecificRid = _$SpecificRidTearOff();

/// @nodoc
mixin _$SpecificRid {
  SpecificRidLwm2mSecurity get lwm2mSecurity =>
      throw _privateConstructorUsedError;
  SpecificRidLwm2mServer get lwm2mServer => throw _privateConstructorUsedError;
  SpecificRidAccessCtrl get accessCtrl => throw _privateConstructorUsedError;
  SpecificRidDevice get device => throw _privateConstructorUsedError;
  SpecificRidConnMonitor get connMonitor => throw _privateConstructorUsedError;
  SpecificRidFirmware get firmware => throw _privateConstructorUsedError;
  SpecificRidLocation get location => throw _privateConstructorUsedError;
  SpecificRidConnStatistics get connStatistics =>
      throw _privateConstructorUsedError;
  SpecificRidDIn get dIn => throw _privateConstructorUsedError;
  SpecificRidDOut get dOut => throw _privateConstructorUsedError;
  SpecificRidAIn get aIn => throw _privateConstructorUsedError;
  SpecificRidAOut get aOut => throw _privateConstructorUsedError;
  SpecificRidGeneric get generic => throw _privateConstructorUsedError;
  SpecificRidIlluminance get illuminance => throw _privateConstructorUsedError;
  SpecificRidPresence get presence => throw _privateConstructorUsedError;
  SpecificRidTemperature get temperature => throw _privateConstructorUsedError;
  SpecificRidHumidity get humidity => throw _privateConstructorUsedError;
  SpecificRidPwrMea get pwrMea => throw _privateConstructorUsedError;
  SpecificRidActuation get actuation => throw _privateConstructorUsedError;
  SpecificRidSetPoint get setPoint => throw _privateConstructorUsedError;
  SpecificRidLoadCtrl get loadCtrl => throw _privateConstructorUsedError;
  SpecificRidLightCtrl get lightCtrl => throw _privateConstructorUsedError;
  SpecificRidPwrCtrl get pwrCtrl => throw _privateConstructorUsedError;
  SpecificRidAccelerometer get accelerometer =>
      throw _privateConstructorUsedError;
  SpecificRidMagnetometer get magnetometer =>
      throw _privateConstructorUsedError;
  SpecificRidBarometer get barometer => throw _privateConstructorUsedError;
  SpecificRidVoltage get voltage => throw _privateConstructorUsedError;
  SpecificRidCurrent get current => throw _privateConstructorUsedError;
  SpecificRidFrequency get frequency => throw _privateConstructorUsedError;
  SpecificRidDepth get depth => throw _privateConstructorUsedError;
  SpecificRidPercentage get percentage => throw _privateConstructorUsedError;
  SpecificRidAltitude get altitude => throw _privateConstructorUsedError;
  SpecificRidLoad get load => throw _privateConstructorUsedError;
  SpecificRidPressure get pressure => throw _privateConstructorUsedError;
  SpecificRidLoudness get loudness => throw _privateConstructorUsedError;
  SpecificRidConcentration get concentration =>
      throw _privateConstructorUsedError;
  SpecificRidAcidity get acidity => throw _privateConstructorUsedError;
  SpecificRidConductivity get conductivity =>
      throw _privateConstructorUsedError;
  SpecificRidPower get power => throw _privateConstructorUsedError;
  SpecificRidPowerFactor get powerFactor => throw _privateConstructorUsedError;
  SpecificRidDistance get distance => throw _privateConstructorUsedError;
  SpecificRidEnergy get energy => throw _privateConstructorUsedError;
  SpecificRidDirection get direction => throw _privateConstructorUsedError;
  SpecificRidTime get time => throw _privateConstructorUsedError;
  SpecificRidGyrometer get gyrometer => throw _privateConstructorUsedError;
  SpecificRidColour get colour => throw _privateConstructorUsedError;
  SpecificRidGpsLocation get gpsLocation => throw _privateConstructorUsedError;
  SpecificRidPositioner get positioner => throw _privateConstructorUsedError;
  SpecificRidBuzzer get buzzer => throw _privateConstructorUsedError;
  SpecificRidAudioClip get audioClip => throw _privateConstructorUsedError;
  SpecificRidTimer get timer => throw _privateConstructorUsedError;
  SpecificRidAddressableTextDisplay get addressableTextDisplay =>
      throw _privateConstructorUsedError;
  SpecificRidOnOffSwitch get onOffSwitch => throw _privateConstructorUsedError;
  SpecificRidLevelControl get levelControl =>
      throw _privateConstructorUsedError;
  SpecificRidUpDownControl get upDownControl =>
      throw _privateConstructorUsedError;
  SpecificRidMultipleAxisJoystick get multipleAxisJoystick =>
      throw _privateConstructorUsedError;
  SpecificRidRate get rate => throw _privateConstructorUsedError;
  SpecificRidPushButton get pushButton => throw _privateConstructorUsedError;
  SpecificRidMultistateSelector get multistateSelector =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidCopyWith<SpecificRid> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidCopyWith<$Res> {
  factory $SpecificRidCopyWith(
          SpecificRid value, $Res Function(SpecificRid) then) =
      _$SpecificRidCopyWithImpl<$Res>;
  $Res call(
      {SpecificRidLwm2mSecurity lwm2mSecurity,
      SpecificRidLwm2mServer lwm2mServer,
      SpecificRidAccessCtrl accessCtrl,
      SpecificRidDevice device,
      SpecificRidConnMonitor connMonitor,
      SpecificRidFirmware firmware,
      SpecificRidLocation location,
      SpecificRidConnStatistics connStatistics,
      SpecificRidDIn dIn,
      SpecificRidDOut dOut,
      SpecificRidAIn aIn,
      SpecificRidAOut aOut,
      SpecificRidGeneric generic,
      SpecificRidIlluminance illuminance,
      SpecificRidPresence presence,
      SpecificRidTemperature temperature,
      SpecificRidHumidity humidity,
      SpecificRidPwrMea pwrMea,
      SpecificRidActuation actuation,
      SpecificRidSetPoint setPoint,
      SpecificRidLoadCtrl loadCtrl,
      SpecificRidLightCtrl lightCtrl,
      SpecificRidPwrCtrl pwrCtrl,
      SpecificRidAccelerometer accelerometer,
      SpecificRidMagnetometer magnetometer,
      SpecificRidBarometer barometer,
      SpecificRidVoltage voltage,
      SpecificRidCurrent current,
      SpecificRidFrequency frequency,
      SpecificRidDepth depth,
      SpecificRidPercentage percentage,
      SpecificRidAltitude altitude,
      SpecificRidLoad load,
      SpecificRidPressure pressure,
      SpecificRidLoudness loudness,
      SpecificRidConcentration concentration,
      SpecificRidAcidity acidity,
      SpecificRidConductivity conductivity,
      SpecificRidPower power,
      SpecificRidPowerFactor powerFactor,
      SpecificRidDistance distance,
      SpecificRidEnergy energy,
      SpecificRidDirection direction,
      SpecificRidTime time,
      SpecificRidGyrometer gyrometer,
      SpecificRidColour colour,
      SpecificRidGpsLocation gpsLocation,
      SpecificRidPositioner positioner,
      SpecificRidBuzzer buzzer,
      SpecificRidAudioClip audioClip,
      SpecificRidTimer timer,
      SpecificRidAddressableTextDisplay addressableTextDisplay,
      SpecificRidOnOffSwitch onOffSwitch,
      SpecificRidLevelControl levelControl,
      SpecificRidUpDownControl upDownControl,
      SpecificRidMultipleAxisJoystick multipleAxisJoystick,
      SpecificRidRate rate,
      SpecificRidPushButton pushButton,
      SpecificRidMultistateSelector multistateSelector});

  $SpecificRidLwm2mSecurityCopyWith<$Res> get lwm2mSecurity;
  $SpecificRidLwm2mServerCopyWith<$Res> get lwm2mServer;
  $SpecificRidAccessCtrlCopyWith<$Res> get accessCtrl;
  $SpecificRidDeviceCopyWith<$Res> get device;
  $SpecificRidConnMonitorCopyWith<$Res> get connMonitor;
  $SpecificRidFirmwareCopyWith<$Res> get firmware;
  $SpecificRidLocationCopyWith<$Res> get location;
  $SpecificRidConnStatisticsCopyWith<$Res> get connStatistics;
  $SpecificRidDInCopyWith<$Res> get dIn;
  $SpecificRidDOutCopyWith<$Res> get dOut;
  $SpecificRidAInCopyWith<$Res> get aIn;
  $SpecificRidAOutCopyWith<$Res> get aOut;
  $SpecificRidGenericCopyWith<$Res> get generic;
  $SpecificRidIlluminanceCopyWith<$Res> get illuminance;
  $SpecificRidPresenceCopyWith<$Res> get presence;
  $SpecificRidTemperatureCopyWith<$Res> get temperature;
  $SpecificRidHumidityCopyWith<$Res> get humidity;
  $SpecificRidPwrMeaCopyWith<$Res> get pwrMea;
  $SpecificRidActuationCopyWith<$Res> get actuation;
  $SpecificRidSetPointCopyWith<$Res> get setPoint;
  $SpecificRidLoadCtrlCopyWith<$Res> get loadCtrl;
  $SpecificRidLightCtrlCopyWith<$Res> get lightCtrl;
  $SpecificRidPwrCtrlCopyWith<$Res> get pwrCtrl;
  $SpecificRidAccelerometerCopyWith<$Res> get accelerometer;
  $SpecificRidMagnetometerCopyWith<$Res> get magnetometer;
  $SpecificRidBarometerCopyWith<$Res> get barometer;
  $SpecificRidVoltageCopyWith<$Res> get voltage;
  $SpecificRidCurrentCopyWith<$Res> get current;
  $SpecificRidFrequencyCopyWith<$Res> get frequency;
  $SpecificRidDepthCopyWith<$Res> get depth;
  $SpecificRidPercentageCopyWith<$Res> get percentage;
  $SpecificRidAltitudeCopyWith<$Res> get altitude;
  $SpecificRidLoadCopyWith<$Res> get load;
  $SpecificRidPressureCopyWith<$Res> get pressure;
  $SpecificRidLoudnessCopyWith<$Res> get loudness;
  $SpecificRidConcentrationCopyWith<$Res> get concentration;
  $SpecificRidAcidityCopyWith<$Res> get acidity;
  $SpecificRidConductivityCopyWith<$Res> get conductivity;
  $SpecificRidPowerCopyWith<$Res> get power;
  $SpecificRidPowerFactorCopyWith<$Res> get powerFactor;
  $SpecificRidDistanceCopyWith<$Res> get distance;
  $SpecificRidEnergyCopyWith<$Res> get energy;
  $SpecificRidDirectionCopyWith<$Res> get direction;
  $SpecificRidTimeCopyWith<$Res> get time;
  $SpecificRidGyrometerCopyWith<$Res> get gyrometer;
  $SpecificRidColourCopyWith<$Res> get colour;
  $SpecificRidGpsLocationCopyWith<$Res> get gpsLocation;
  $SpecificRidPositionerCopyWith<$Res> get positioner;
  $SpecificRidBuzzerCopyWith<$Res> get buzzer;
  $SpecificRidAudioClipCopyWith<$Res> get audioClip;
  $SpecificRidTimerCopyWith<$Res> get timer;
  $SpecificRidAddressableTextDisplayCopyWith<$Res> get addressableTextDisplay;
  $SpecificRidOnOffSwitchCopyWith<$Res> get onOffSwitch;
  $SpecificRidLevelControlCopyWith<$Res> get levelControl;
  $SpecificRidUpDownControlCopyWith<$Res> get upDownControl;
  $SpecificRidMultipleAxisJoystickCopyWith<$Res> get multipleAxisJoystick;
  $SpecificRidRateCopyWith<$Res> get rate;
  $SpecificRidPushButtonCopyWith<$Res> get pushButton;
  $SpecificRidMultistateSelectorCopyWith<$Res> get multistateSelector;
}

/// @nodoc
class _$SpecificRidCopyWithImpl<$Res> implements $SpecificRidCopyWith<$Res> {
  _$SpecificRidCopyWithImpl(this._value, this._then);

  final SpecificRid _value;
  // ignore: unused_field
  final $Res Function(SpecificRid) _then;

  @override
  $Res call({
    Object? lwm2mSecurity = freezed,
    Object? lwm2mServer = freezed,
    Object? accessCtrl = freezed,
    Object? device = freezed,
    Object? connMonitor = freezed,
    Object? firmware = freezed,
    Object? location = freezed,
    Object? connStatistics = freezed,
    Object? dIn = freezed,
    Object? dOut = freezed,
    Object? aIn = freezed,
    Object? aOut = freezed,
    Object? generic = freezed,
    Object? illuminance = freezed,
    Object? presence = freezed,
    Object? temperature = freezed,
    Object? humidity = freezed,
    Object? pwrMea = freezed,
    Object? actuation = freezed,
    Object? setPoint = freezed,
    Object? loadCtrl = freezed,
    Object? lightCtrl = freezed,
    Object? pwrCtrl = freezed,
    Object? accelerometer = freezed,
    Object? magnetometer = freezed,
    Object? barometer = freezed,
    Object? voltage = freezed,
    Object? current = freezed,
    Object? frequency = freezed,
    Object? depth = freezed,
    Object? percentage = freezed,
    Object? altitude = freezed,
    Object? load = freezed,
    Object? pressure = freezed,
    Object? loudness = freezed,
    Object? concentration = freezed,
    Object? acidity = freezed,
    Object? conductivity = freezed,
    Object? power = freezed,
    Object? powerFactor = freezed,
    Object? distance = freezed,
    Object? energy = freezed,
    Object? direction = freezed,
    Object? time = freezed,
    Object? gyrometer = freezed,
    Object? colour = freezed,
    Object? gpsLocation = freezed,
    Object? positioner = freezed,
    Object? buzzer = freezed,
    Object? audioClip = freezed,
    Object? timer = freezed,
    Object? addressableTextDisplay = freezed,
    Object? onOffSwitch = freezed,
    Object? levelControl = freezed,
    Object? upDownControl = freezed,
    Object? multipleAxisJoystick = freezed,
    Object? rate = freezed,
    Object? pushButton = freezed,
    Object? multistateSelector = freezed,
  }) {
    return _then(_value.copyWith(
      lwm2mSecurity: lwm2mSecurity == freezed
          ? _value.lwm2mSecurity
          : lwm2mSecurity // ignore: cast_nullable_to_non_nullable
              as SpecificRidLwm2mSecurity,
      lwm2mServer: lwm2mServer == freezed
          ? _value.lwm2mServer
          : lwm2mServer // ignore: cast_nullable_to_non_nullable
              as SpecificRidLwm2mServer,
      accessCtrl: accessCtrl == freezed
          ? _value.accessCtrl
          : accessCtrl // ignore: cast_nullable_to_non_nullable
              as SpecificRidAccessCtrl,
      device: device == freezed
          ? _value.device
          : device // ignore: cast_nullable_to_non_nullable
              as SpecificRidDevice,
      connMonitor: connMonitor == freezed
          ? _value.connMonitor
          : connMonitor // ignore: cast_nullable_to_non_nullable
              as SpecificRidConnMonitor,
      firmware: firmware == freezed
          ? _value.firmware
          : firmware // ignore: cast_nullable_to_non_nullable
              as SpecificRidFirmware,
      location: location == freezed
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as SpecificRidLocation,
      connStatistics: connStatistics == freezed
          ? _value.connStatistics
          : connStatistics // ignore: cast_nullable_to_non_nullable
              as SpecificRidConnStatistics,
      dIn: dIn == freezed
          ? _value.dIn
          : dIn // ignore: cast_nullable_to_non_nullable
              as SpecificRidDIn,
      dOut: dOut == freezed
          ? _value.dOut
          : dOut // ignore: cast_nullable_to_non_nullable
              as SpecificRidDOut,
      aIn: aIn == freezed
          ? _value.aIn
          : aIn // ignore: cast_nullable_to_non_nullable
              as SpecificRidAIn,
      aOut: aOut == freezed
          ? _value.aOut
          : aOut // ignore: cast_nullable_to_non_nullable
              as SpecificRidAOut,
      generic: generic == freezed
          ? _value.generic
          : generic // ignore: cast_nullable_to_non_nullable
              as SpecificRidGeneric,
      illuminance: illuminance == freezed
          ? _value.illuminance
          : illuminance // ignore: cast_nullable_to_non_nullable
              as SpecificRidIlluminance,
      presence: presence == freezed
          ? _value.presence
          : presence // ignore: cast_nullable_to_non_nullable
              as SpecificRidPresence,
      temperature: temperature == freezed
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as SpecificRidTemperature,
      humidity: humidity == freezed
          ? _value.humidity
          : humidity // ignore: cast_nullable_to_non_nullable
              as SpecificRidHumidity,
      pwrMea: pwrMea == freezed
          ? _value.pwrMea
          : pwrMea // ignore: cast_nullable_to_non_nullable
              as SpecificRidPwrMea,
      actuation: actuation == freezed
          ? _value.actuation
          : actuation // ignore: cast_nullable_to_non_nullable
              as SpecificRidActuation,
      setPoint: setPoint == freezed
          ? _value.setPoint
          : setPoint // ignore: cast_nullable_to_non_nullable
              as SpecificRidSetPoint,
      loadCtrl: loadCtrl == freezed
          ? _value.loadCtrl
          : loadCtrl // ignore: cast_nullable_to_non_nullable
              as SpecificRidLoadCtrl,
      lightCtrl: lightCtrl == freezed
          ? _value.lightCtrl
          : lightCtrl // ignore: cast_nullable_to_non_nullable
              as SpecificRidLightCtrl,
      pwrCtrl: pwrCtrl == freezed
          ? _value.pwrCtrl
          : pwrCtrl // ignore: cast_nullable_to_non_nullable
              as SpecificRidPwrCtrl,
      accelerometer: accelerometer == freezed
          ? _value.accelerometer
          : accelerometer // ignore: cast_nullable_to_non_nullable
              as SpecificRidAccelerometer,
      magnetometer: magnetometer == freezed
          ? _value.magnetometer
          : magnetometer // ignore: cast_nullable_to_non_nullable
              as SpecificRidMagnetometer,
      barometer: barometer == freezed
          ? _value.barometer
          : barometer // ignore: cast_nullable_to_non_nullable
              as SpecificRidBarometer,
      voltage: voltage == freezed
          ? _value.voltage
          : voltage // ignore: cast_nullable_to_non_nullable
              as SpecificRidVoltage,
      current: current == freezed
          ? _value.current
          : current // ignore: cast_nullable_to_non_nullable
              as SpecificRidCurrent,
      frequency: frequency == freezed
          ? _value.frequency
          : frequency // ignore: cast_nullable_to_non_nullable
              as SpecificRidFrequency,
      depth: depth == freezed
          ? _value.depth
          : depth // ignore: cast_nullable_to_non_nullable
              as SpecificRidDepth,
      percentage: percentage == freezed
          ? _value.percentage
          : percentage // ignore: cast_nullable_to_non_nullable
              as SpecificRidPercentage,
      altitude: altitude == freezed
          ? _value.altitude
          : altitude // ignore: cast_nullable_to_non_nullable
              as SpecificRidAltitude,
      load: load == freezed
          ? _value.load
          : load // ignore: cast_nullable_to_non_nullable
              as SpecificRidLoad,
      pressure: pressure == freezed
          ? _value.pressure
          : pressure // ignore: cast_nullable_to_non_nullable
              as SpecificRidPressure,
      loudness: loudness == freezed
          ? _value.loudness
          : loudness // ignore: cast_nullable_to_non_nullable
              as SpecificRidLoudness,
      concentration: concentration == freezed
          ? _value.concentration
          : concentration // ignore: cast_nullable_to_non_nullable
              as SpecificRidConcentration,
      acidity: acidity == freezed
          ? _value.acidity
          : acidity // ignore: cast_nullable_to_non_nullable
              as SpecificRidAcidity,
      conductivity: conductivity == freezed
          ? _value.conductivity
          : conductivity // ignore: cast_nullable_to_non_nullable
              as SpecificRidConductivity,
      power: power == freezed
          ? _value.power
          : power // ignore: cast_nullable_to_non_nullable
              as SpecificRidPower,
      powerFactor: powerFactor == freezed
          ? _value.powerFactor
          : powerFactor // ignore: cast_nullable_to_non_nullable
              as SpecificRidPowerFactor,
      distance: distance == freezed
          ? _value.distance
          : distance // ignore: cast_nullable_to_non_nullable
              as SpecificRidDistance,
      energy: energy == freezed
          ? _value.energy
          : energy // ignore: cast_nullable_to_non_nullable
              as SpecificRidEnergy,
      direction: direction == freezed
          ? _value.direction
          : direction // ignore: cast_nullable_to_non_nullable
              as SpecificRidDirection,
      time: time == freezed
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as SpecificRidTime,
      gyrometer: gyrometer == freezed
          ? _value.gyrometer
          : gyrometer // ignore: cast_nullable_to_non_nullable
              as SpecificRidGyrometer,
      colour: colour == freezed
          ? _value.colour
          : colour // ignore: cast_nullable_to_non_nullable
              as SpecificRidColour,
      gpsLocation: gpsLocation == freezed
          ? _value.gpsLocation
          : gpsLocation // ignore: cast_nullable_to_non_nullable
              as SpecificRidGpsLocation,
      positioner: positioner == freezed
          ? _value.positioner
          : positioner // ignore: cast_nullable_to_non_nullable
              as SpecificRidPositioner,
      buzzer: buzzer == freezed
          ? _value.buzzer
          : buzzer // ignore: cast_nullable_to_non_nullable
              as SpecificRidBuzzer,
      audioClip: audioClip == freezed
          ? _value.audioClip
          : audioClip // ignore: cast_nullable_to_non_nullable
              as SpecificRidAudioClip,
      timer: timer == freezed
          ? _value.timer
          : timer // ignore: cast_nullable_to_non_nullable
              as SpecificRidTimer,
      addressableTextDisplay: addressableTextDisplay == freezed
          ? _value.addressableTextDisplay
          : addressableTextDisplay // ignore: cast_nullable_to_non_nullable
              as SpecificRidAddressableTextDisplay,
      onOffSwitch: onOffSwitch == freezed
          ? _value.onOffSwitch
          : onOffSwitch // ignore: cast_nullable_to_non_nullable
              as SpecificRidOnOffSwitch,
      levelControl: levelControl == freezed
          ? _value.levelControl
          : levelControl // ignore: cast_nullable_to_non_nullable
              as SpecificRidLevelControl,
      upDownControl: upDownControl == freezed
          ? _value.upDownControl
          : upDownControl // ignore: cast_nullable_to_non_nullable
              as SpecificRidUpDownControl,
      multipleAxisJoystick: multipleAxisJoystick == freezed
          ? _value.multipleAxisJoystick
          : multipleAxisJoystick // ignore: cast_nullable_to_non_nullable
              as SpecificRidMultipleAxisJoystick,
      rate: rate == freezed
          ? _value.rate
          : rate // ignore: cast_nullable_to_non_nullable
              as SpecificRidRate,
      pushButton: pushButton == freezed
          ? _value.pushButton
          : pushButton // ignore: cast_nullable_to_non_nullable
              as SpecificRidPushButton,
      multistateSelector: multistateSelector == freezed
          ? _value.multistateSelector
          : multistateSelector // ignore: cast_nullable_to_non_nullable
              as SpecificRidMultistateSelector,
    ));
  }

  @override
  $SpecificRidLwm2mSecurityCopyWith<$Res> get lwm2mSecurity {
    return $SpecificRidLwm2mSecurityCopyWith<$Res>(_value.lwm2mSecurity,
        (value) {
      return _then(_value.copyWith(lwm2mSecurity: value));
    });
  }

  @override
  $SpecificRidLwm2mServerCopyWith<$Res> get lwm2mServer {
    return $SpecificRidLwm2mServerCopyWith<$Res>(_value.lwm2mServer, (value) {
      return _then(_value.copyWith(lwm2mServer: value));
    });
  }

  @override
  $SpecificRidAccessCtrlCopyWith<$Res> get accessCtrl {
    return $SpecificRidAccessCtrlCopyWith<$Res>(_value.accessCtrl, (value) {
      return _then(_value.copyWith(accessCtrl: value));
    });
  }

  @override
  $SpecificRidDeviceCopyWith<$Res> get device {
    return $SpecificRidDeviceCopyWith<$Res>(_value.device, (value) {
      return _then(_value.copyWith(device: value));
    });
  }

  @override
  $SpecificRidConnMonitorCopyWith<$Res> get connMonitor {
    return $SpecificRidConnMonitorCopyWith<$Res>(_value.connMonitor, (value) {
      return _then(_value.copyWith(connMonitor: value));
    });
  }

  @override
  $SpecificRidFirmwareCopyWith<$Res> get firmware {
    return $SpecificRidFirmwareCopyWith<$Res>(_value.firmware, (value) {
      return _then(_value.copyWith(firmware: value));
    });
  }

  @override
  $SpecificRidLocationCopyWith<$Res> get location {
    return $SpecificRidLocationCopyWith<$Res>(_value.location, (value) {
      return _then(_value.copyWith(location: value));
    });
  }

  @override
  $SpecificRidConnStatisticsCopyWith<$Res> get connStatistics {
    return $SpecificRidConnStatisticsCopyWith<$Res>(_value.connStatistics,
        (value) {
      return _then(_value.copyWith(connStatistics: value));
    });
  }

  @override
  $SpecificRidDInCopyWith<$Res> get dIn {
    return $SpecificRidDInCopyWith<$Res>(_value.dIn, (value) {
      return _then(_value.copyWith(dIn: value));
    });
  }

  @override
  $SpecificRidDOutCopyWith<$Res> get dOut {
    return $SpecificRidDOutCopyWith<$Res>(_value.dOut, (value) {
      return _then(_value.copyWith(dOut: value));
    });
  }

  @override
  $SpecificRidAInCopyWith<$Res> get aIn {
    return $SpecificRidAInCopyWith<$Res>(_value.aIn, (value) {
      return _then(_value.copyWith(aIn: value));
    });
  }

  @override
  $SpecificRidAOutCopyWith<$Res> get aOut {
    return $SpecificRidAOutCopyWith<$Res>(_value.aOut, (value) {
      return _then(_value.copyWith(aOut: value));
    });
  }

  @override
  $SpecificRidGenericCopyWith<$Res> get generic {
    return $SpecificRidGenericCopyWith<$Res>(_value.generic, (value) {
      return _then(_value.copyWith(generic: value));
    });
  }

  @override
  $SpecificRidIlluminanceCopyWith<$Res> get illuminance {
    return $SpecificRidIlluminanceCopyWith<$Res>(_value.illuminance, (value) {
      return _then(_value.copyWith(illuminance: value));
    });
  }

  @override
  $SpecificRidPresenceCopyWith<$Res> get presence {
    return $SpecificRidPresenceCopyWith<$Res>(_value.presence, (value) {
      return _then(_value.copyWith(presence: value));
    });
  }

  @override
  $SpecificRidTemperatureCopyWith<$Res> get temperature {
    return $SpecificRidTemperatureCopyWith<$Res>(_value.temperature, (value) {
      return _then(_value.copyWith(temperature: value));
    });
  }

  @override
  $SpecificRidHumidityCopyWith<$Res> get humidity {
    return $SpecificRidHumidityCopyWith<$Res>(_value.humidity, (value) {
      return _then(_value.copyWith(humidity: value));
    });
  }

  @override
  $SpecificRidPwrMeaCopyWith<$Res> get pwrMea {
    return $SpecificRidPwrMeaCopyWith<$Res>(_value.pwrMea, (value) {
      return _then(_value.copyWith(pwrMea: value));
    });
  }

  @override
  $SpecificRidActuationCopyWith<$Res> get actuation {
    return $SpecificRidActuationCopyWith<$Res>(_value.actuation, (value) {
      return _then(_value.copyWith(actuation: value));
    });
  }

  @override
  $SpecificRidSetPointCopyWith<$Res> get setPoint {
    return $SpecificRidSetPointCopyWith<$Res>(_value.setPoint, (value) {
      return _then(_value.copyWith(setPoint: value));
    });
  }

  @override
  $SpecificRidLoadCtrlCopyWith<$Res> get loadCtrl {
    return $SpecificRidLoadCtrlCopyWith<$Res>(_value.loadCtrl, (value) {
      return _then(_value.copyWith(loadCtrl: value));
    });
  }

  @override
  $SpecificRidLightCtrlCopyWith<$Res> get lightCtrl {
    return $SpecificRidLightCtrlCopyWith<$Res>(_value.lightCtrl, (value) {
      return _then(_value.copyWith(lightCtrl: value));
    });
  }

  @override
  $SpecificRidPwrCtrlCopyWith<$Res> get pwrCtrl {
    return $SpecificRidPwrCtrlCopyWith<$Res>(_value.pwrCtrl, (value) {
      return _then(_value.copyWith(pwrCtrl: value));
    });
  }

  @override
  $SpecificRidAccelerometerCopyWith<$Res> get accelerometer {
    return $SpecificRidAccelerometerCopyWith<$Res>(_value.accelerometer,
        (value) {
      return _then(_value.copyWith(accelerometer: value));
    });
  }

  @override
  $SpecificRidMagnetometerCopyWith<$Res> get magnetometer {
    return $SpecificRidMagnetometerCopyWith<$Res>(_value.magnetometer, (value) {
      return _then(_value.copyWith(magnetometer: value));
    });
  }

  @override
  $SpecificRidBarometerCopyWith<$Res> get barometer {
    return $SpecificRidBarometerCopyWith<$Res>(_value.barometer, (value) {
      return _then(_value.copyWith(barometer: value));
    });
  }

  @override
  $SpecificRidVoltageCopyWith<$Res> get voltage {
    return $SpecificRidVoltageCopyWith<$Res>(_value.voltage, (value) {
      return _then(_value.copyWith(voltage: value));
    });
  }

  @override
  $SpecificRidCurrentCopyWith<$Res> get current {
    return $SpecificRidCurrentCopyWith<$Res>(_value.current, (value) {
      return _then(_value.copyWith(current: value));
    });
  }

  @override
  $SpecificRidFrequencyCopyWith<$Res> get frequency {
    return $SpecificRidFrequencyCopyWith<$Res>(_value.frequency, (value) {
      return _then(_value.copyWith(frequency: value));
    });
  }

  @override
  $SpecificRidDepthCopyWith<$Res> get depth {
    return $SpecificRidDepthCopyWith<$Res>(_value.depth, (value) {
      return _then(_value.copyWith(depth: value));
    });
  }

  @override
  $SpecificRidPercentageCopyWith<$Res> get percentage {
    return $SpecificRidPercentageCopyWith<$Res>(_value.percentage, (value) {
      return _then(_value.copyWith(percentage: value));
    });
  }

  @override
  $SpecificRidAltitudeCopyWith<$Res> get altitude {
    return $SpecificRidAltitudeCopyWith<$Res>(_value.altitude, (value) {
      return _then(_value.copyWith(altitude: value));
    });
  }

  @override
  $SpecificRidLoadCopyWith<$Res> get load {
    return $SpecificRidLoadCopyWith<$Res>(_value.load, (value) {
      return _then(_value.copyWith(load: value));
    });
  }

  @override
  $SpecificRidPressureCopyWith<$Res> get pressure {
    return $SpecificRidPressureCopyWith<$Res>(_value.pressure, (value) {
      return _then(_value.copyWith(pressure: value));
    });
  }

  @override
  $SpecificRidLoudnessCopyWith<$Res> get loudness {
    return $SpecificRidLoudnessCopyWith<$Res>(_value.loudness, (value) {
      return _then(_value.copyWith(loudness: value));
    });
  }

  @override
  $SpecificRidConcentrationCopyWith<$Res> get concentration {
    return $SpecificRidConcentrationCopyWith<$Res>(_value.concentration,
        (value) {
      return _then(_value.copyWith(concentration: value));
    });
  }

  @override
  $SpecificRidAcidityCopyWith<$Res> get acidity {
    return $SpecificRidAcidityCopyWith<$Res>(_value.acidity, (value) {
      return _then(_value.copyWith(acidity: value));
    });
  }

  @override
  $SpecificRidConductivityCopyWith<$Res> get conductivity {
    return $SpecificRidConductivityCopyWith<$Res>(_value.conductivity, (value) {
      return _then(_value.copyWith(conductivity: value));
    });
  }

  @override
  $SpecificRidPowerCopyWith<$Res> get power {
    return $SpecificRidPowerCopyWith<$Res>(_value.power, (value) {
      return _then(_value.copyWith(power: value));
    });
  }

  @override
  $SpecificRidPowerFactorCopyWith<$Res> get powerFactor {
    return $SpecificRidPowerFactorCopyWith<$Res>(_value.powerFactor, (value) {
      return _then(_value.copyWith(powerFactor: value));
    });
  }

  @override
  $SpecificRidDistanceCopyWith<$Res> get distance {
    return $SpecificRidDistanceCopyWith<$Res>(_value.distance, (value) {
      return _then(_value.copyWith(distance: value));
    });
  }

  @override
  $SpecificRidEnergyCopyWith<$Res> get energy {
    return $SpecificRidEnergyCopyWith<$Res>(_value.energy, (value) {
      return _then(_value.copyWith(energy: value));
    });
  }

  @override
  $SpecificRidDirectionCopyWith<$Res> get direction {
    return $SpecificRidDirectionCopyWith<$Res>(_value.direction, (value) {
      return _then(_value.copyWith(direction: value));
    });
  }

  @override
  $SpecificRidTimeCopyWith<$Res> get time {
    return $SpecificRidTimeCopyWith<$Res>(_value.time, (value) {
      return _then(_value.copyWith(time: value));
    });
  }

  @override
  $SpecificRidGyrometerCopyWith<$Res> get gyrometer {
    return $SpecificRidGyrometerCopyWith<$Res>(_value.gyrometer, (value) {
      return _then(_value.copyWith(gyrometer: value));
    });
  }

  @override
  $SpecificRidColourCopyWith<$Res> get colour {
    return $SpecificRidColourCopyWith<$Res>(_value.colour, (value) {
      return _then(_value.copyWith(colour: value));
    });
  }

  @override
  $SpecificRidGpsLocationCopyWith<$Res> get gpsLocation {
    return $SpecificRidGpsLocationCopyWith<$Res>(_value.gpsLocation, (value) {
      return _then(_value.copyWith(gpsLocation: value));
    });
  }

  @override
  $SpecificRidPositionerCopyWith<$Res> get positioner {
    return $SpecificRidPositionerCopyWith<$Res>(_value.positioner, (value) {
      return _then(_value.copyWith(positioner: value));
    });
  }

  @override
  $SpecificRidBuzzerCopyWith<$Res> get buzzer {
    return $SpecificRidBuzzerCopyWith<$Res>(_value.buzzer, (value) {
      return _then(_value.copyWith(buzzer: value));
    });
  }

  @override
  $SpecificRidAudioClipCopyWith<$Res> get audioClip {
    return $SpecificRidAudioClipCopyWith<$Res>(_value.audioClip, (value) {
      return _then(_value.copyWith(audioClip: value));
    });
  }

  @override
  $SpecificRidTimerCopyWith<$Res> get timer {
    return $SpecificRidTimerCopyWith<$Res>(_value.timer, (value) {
      return _then(_value.copyWith(timer: value));
    });
  }

  @override
  $SpecificRidAddressableTextDisplayCopyWith<$Res> get addressableTextDisplay {
    return $SpecificRidAddressableTextDisplayCopyWith<$Res>(
        _value.addressableTextDisplay, (value) {
      return _then(_value.copyWith(addressableTextDisplay: value));
    });
  }

  @override
  $SpecificRidOnOffSwitchCopyWith<$Res> get onOffSwitch {
    return $SpecificRidOnOffSwitchCopyWith<$Res>(_value.onOffSwitch, (value) {
      return _then(_value.copyWith(onOffSwitch: value));
    });
  }

  @override
  $SpecificRidLevelControlCopyWith<$Res> get levelControl {
    return $SpecificRidLevelControlCopyWith<$Res>(_value.levelControl, (value) {
      return _then(_value.copyWith(levelControl: value));
    });
  }

  @override
  $SpecificRidUpDownControlCopyWith<$Res> get upDownControl {
    return $SpecificRidUpDownControlCopyWith<$Res>(_value.upDownControl,
        (value) {
      return _then(_value.copyWith(upDownControl: value));
    });
  }

  @override
  $SpecificRidMultipleAxisJoystickCopyWith<$Res> get multipleAxisJoystick {
    return $SpecificRidMultipleAxisJoystickCopyWith<$Res>(
        _value.multipleAxisJoystick, (value) {
      return _then(_value.copyWith(multipleAxisJoystick: value));
    });
  }

  @override
  $SpecificRidRateCopyWith<$Res> get rate {
    return $SpecificRidRateCopyWith<$Res>(_value.rate, (value) {
      return _then(_value.copyWith(rate: value));
    });
  }

  @override
  $SpecificRidPushButtonCopyWith<$Res> get pushButton {
    return $SpecificRidPushButtonCopyWith<$Res>(_value.pushButton, (value) {
      return _then(_value.copyWith(pushButton: value));
    });
  }

  @override
  $SpecificRidMultistateSelectorCopyWith<$Res> get multistateSelector {
    return $SpecificRidMultistateSelectorCopyWith<$Res>(
        _value.multistateSelector, (value) {
      return _then(_value.copyWith(multistateSelector: value));
    });
  }
}

/// @nodoc
abstract class _$SpecificRidCopyWith<$Res>
    implements $SpecificRidCopyWith<$Res> {
  factory _$SpecificRidCopyWith(
          _SpecificRid value, $Res Function(_SpecificRid) then) =
      __$SpecificRidCopyWithImpl<$Res>;
  @override
  $Res call(
      {SpecificRidLwm2mSecurity lwm2mSecurity,
      SpecificRidLwm2mServer lwm2mServer,
      SpecificRidAccessCtrl accessCtrl,
      SpecificRidDevice device,
      SpecificRidConnMonitor connMonitor,
      SpecificRidFirmware firmware,
      SpecificRidLocation location,
      SpecificRidConnStatistics connStatistics,
      SpecificRidDIn dIn,
      SpecificRidDOut dOut,
      SpecificRidAIn aIn,
      SpecificRidAOut aOut,
      SpecificRidGeneric generic,
      SpecificRidIlluminance illuminance,
      SpecificRidPresence presence,
      SpecificRidTemperature temperature,
      SpecificRidHumidity humidity,
      SpecificRidPwrMea pwrMea,
      SpecificRidActuation actuation,
      SpecificRidSetPoint setPoint,
      SpecificRidLoadCtrl loadCtrl,
      SpecificRidLightCtrl lightCtrl,
      SpecificRidPwrCtrl pwrCtrl,
      SpecificRidAccelerometer accelerometer,
      SpecificRidMagnetometer magnetometer,
      SpecificRidBarometer barometer,
      SpecificRidVoltage voltage,
      SpecificRidCurrent current,
      SpecificRidFrequency frequency,
      SpecificRidDepth depth,
      SpecificRidPercentage percentage,
      SpecificRidAltitude altitude,
      SpecificRidLoad load,
      SpecificRidPressure pressure,
      SpecificRidLoudness loudness,
      SpecificRidConcentration concentration,
      SpecificRidAcidity acidity,
      SpecificRidConductivity conductivity,
      SpecificRidPower power,
      SpecificRidPowerFactor powerFactor,
      SpecificRidDistance distance,
      SpecificRidEnergy energy,
      SpecificRidDirection direction,
      SpecificRidTime time,
      SpecificRidGyrometer gyrometer,
      SpecificRidColour colour,
      SpecificRidGpsLocation gpsLocation,
      SpecificRidPositioner positioner,
      SpecificRidBuzzer buzzer,
      SpecificRidAudioClip audioClip,
      SpecificRidTimer timer,
      SpecificRidAddressableTextDisplay addressableTextDisplay,
      SpecificRidOnOffSwitch onOffSwitch,
      SpecificRidLevelControl levelControl,
      SpecificRidUpDownControl upDownControl,
      SpecificRidMultipleAxisJoystick multipleAxisJoystick,
      SpecificRidRate rate,
      SpecificRidPushButton pushButton,
      SpecificRidMultistateSelector multistateSelector});

  @override
  $SpecificRidLwm2mSecurityCopyWith<$Res> get lwm2mSecurity;
  @override
  $SpecificRidLwm2mServerCopyWith<$Res> get lwm2mServer;
  @override
  $SpecificRidAccessCtrlCopyWith<$Res> get accessCtrl;
  @override
  $SpecificRidDeviceCopyWith<$Res> get device;
  @override
  $SpecificRidConnMonitorCopyWith<$Res> get connMonitor;
  @override
  $SpecificRidFirmwareCopyWith<$Res> get firmware;
  @override
  $SpecificRidLocationCopyWith<$Res> get location;
  @override
  $SpecificRidConnStatisticsCopyWith<$Res> get connStatistics;
  @override
  $SpecificRidDInCopyWith<$Res> get dIn;
  @override
  $SpecificRidDOutCopyWith<$Res> get dOut;
  @override
  $SpecificRidAInCopyWith<$Res> get aIn;
  @override
  $SpecificRidAOutCopyWith<$Res> get aOut;
  @override
  $SpecificRidGenericCopyWith<$Res> get generic;
  @override
  $SpecificRidIlluminanceCopyWith<$Res> get illuminance;
  @override
  $SpecificRidPresenceCopyWith<$Res> get presence;
  @override
  $SpecificRidTemperatureCopyWith<$Res> get temperature;
  @override
  $SpecificRidHumidityCopyWith<$Res> get humidity;
  @override
  $SpecificRidPwrMeaCopyWith<$Res> get pwrMea;
  @override
  $SpecificRidActuationCopyWith<$Res> get actuation;
  @override
  $SpecificRidSetPointCopyWith<$Res> get setPoint;
  @override
  $SpecificRidLoadCtrlCopyWith<$Res> get loadCtrl;
  @override
  $SpecificRidLightCtrlCopyWith<$Res> get lightCtrl;
  @override
  $SpecificRidPwrCtrlCopyWith<$Res> get pwrCtrl;
  @override
  $SpecificRidAccelerometerCopyWith<$Res> get accelerometer;
  @override
  $SpecificRidMagnetometerCopyWith<$Res> get magnetometer;
  @override
  $SpecificRidBarometerCopyWith<$Res> get barometer;
  @override
  $SpecificRidVoltageCopyWith<$Res> get voltage;
  @override
  $SpecificRidCurrentCopyWith<$Res> get current;
  @override
  $SpecificRidFrequencyCopyWith<$Res> get frequency;
  @override
  $SpecificRidDepthCopyWith<$Res> get depth;
  @override
  $SpecificRidPercentageCopyWith<$Res> get percentage;
  @override
  $SpecificRidAltitudeCopyWith<$Res> get altitude;
  @override
  $SpecificRidLoadCopyWith<$Res> get load;
  @override
  $SpecificRidPressureCopyWith<$Res> get pressure;
  @override
  $SpecificRidLoudnessCopyWith<$Res> get loudness;
  @override
  $SpecificRidConcentrationCopyWith<$Res> get concentration;
  @override
  $SpecificRidAcidityCopyWith<$Res> get acidity;
  @override
  $SpecificRidConductivityCopyWith<$Res> get conductivity;
  @override
  $SpecificRidPowerCopyWith<$Res> get power;
  @override
  $SpecificRidPowerFactorCopyWith<$Res> get powerFactor;
  @override
  $SpecificRidDistanceCopyWith<$Res> get distance;
  @override
  $SpecificRidEnergyCopyWith<$Res> get energy;
  @override
  $SpecificRidDirectionCopyWith<$Res> get direction;
  @override
  $SpecificRidTimeCopyWith<$Res> get time;
  @override
  $SpecificRidGyrometerCopyWith<$Res> get gyrometer;
  @override
  $SpecificRidColourCopyWith<$Res> get colour;
  @override
  $SpecificRidGpsLocationCopyWith<$Res> get gpsLocation;
  @override
  $SpecificRidPositionerCopyWith<$Res> get positioner;
  @override
  $SpecificRidBuzzerCopyWith<$Res> get buzzer;
  @override
  $SpecificRidAudioClipCopyWith<$Res> get audioClip;
  @override
  $SpecificRidTimerCopyWith<$Res> get timer;
  @override
  $SpecificRidAddressableTextDisplayCopyWith<$Res> get addressableTextDisplay;
  @override
  $SpecificRidOnOffSwitchCopyWith<$Res> get onOffSwitch;
  @override
  $SpecificRidLevelControlCopyWith<$Res> get levelControl;
  @override
  $SpecificRidUpDownControlCopyWith<$Res> get upDownControl;
  @override
  $SpecificRidMultipleAxisJoystickCopyWith<$Res> get multipleAxisJoystick;
  @override
  $SpecificRidRateCopyWith<$Res> get rate;
  @override
  $SpecificRidPushButtonCopyWith<$Res> get pushButton;
  @override
  $SpecificRidMultistateSelectorCopyWith<$Res> get multistateSelector;
}

/// @nodoc
class __$SpecificRidCopyWithImpl<$Res> extends _$SpecificRidCopyWithImpl<$Res>
    implements _$SpecificRidCopyWith<$Res> {
  __$SpecificRidCopyWithImpl(
      _SpecificRid _value, $Res Function(_SpecificRid) _then)
      : super(_value, (v) => _then(v as _SpecificRid));

  @override
  _SpecificRid get _value => super._value as _SpecificRid;

  @override
  $Res call({
    Object? lwm2mSecurity = freezed,
    Object? lwm2mServer = freezed,
    Object? accessCtrl = freezed,
    Object? device = freezed,
    Object? connMonitor = freezed,
    Object? firmware = freezed,
    Object? location = freezed,
    Object? connStatistics = freezed,
    Object? dIn = freezed,
    Object? dOut = freezed,
    Object? aIn = freezed,
    Object? aOut = freezed,
    Object? generic = freezed,
    Object? illuminance = freezed,
    Object? presence = freezed,
    Object? temperature = freezed,
    Object? humidity = freezed,
    Object? pwrMea = freezed,
    Object? actuation = freezed,
    Object? setPoint = freezed,
    Object? loadCtrl = freezed,
    Object? lightCtrl = freezed,
    Object? pwrCtrl = freezed,
    Object? accelerometer = freezed,
    Object? magnetometer = freezed,
    Object? barometer = freezed,
    Object? voltage = freezed,
    Object? current = freezed,
    Object? frequency = freezed,
    Object? depth = freezed,
    Object? percentage = freezed,
    Object? altitude = freezed,
    Object? load = freezed,
    Object? pressure = freezed,
    Object? loudness = freezed,
    Object? concentration = freezed,
    Object? acidity = freezed,
    Object? conductivity = freezed,
    Object? power = freezed,
    Object? powerFactor = freezed,
    Object? distance = freezed,
    Object? energy = freezed,
    Object? direction = freezed,
    Object? time = freezed,
    Object? gyrometer = freezed,
    Object? colour = freezed,
    Object? gpsLocation = freezed,
    Object? positioner = freezed,
    Object? buzzer = freezed,
    Object? audioClip = freezed,
    Object? timer = freezed,
    Object? addressableTextDisplay = freezed,
    Object? onOffSwitch = freezed,
    Object? levelControl = freezed,
    Object? upDownControl = freezed,
    Object? multipleAxisJoystick = freezed,
    Object? rate = freezed,
    Object? pushButton = freezed,
    Object? multistateSelector = freezed,
  }) {
    return _then(_SpecificRid(
      lwm2mSecurity: lwm2mSecurity == freezed
          ? _value.lwm2mSecurity
          : lwm2mSecurity // ignore: cast_nullable_to_non_nullable
              as SpecificRidLwm2mSecurity,
      lwm2mServer: lwm2mServer == freezed
          ? _value.lwm2mServer
          : lwm2mServer // ignore: cast_nullable_to_non_nullable
              as SpecificRidLwm2mServer,
      accessCtrl: accessCtrl == freezed
          ? _value.accessCtrl
          : accessCtrl // ignore: cast_nullable_to_non_nullable
              as SpecificRidAccessCtrl,
      device: device == freezed
          ? _value.device
          : device // ignore: cast_nullable_to_non_nullable
              as SpecificRidDevice,
      connMonitor: connMonitor == freezed
          ? _value.connMonitor
          : connMonitor // ignore: cast_nullable_to_non_nullable
              as SpecificRidConnMonitor,
      firmware: firmware == freezed
          ? _value.firmware
          : firmware // ignore: cast_nullable_to_non_nullable
              as SpecificRidFirmware,
      location: location == freezed
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as SpecificRidLocation,
      connStatistics: connStatistics == freezed
          ? _value.connStatistics
          : connStatistics // ignore: cast_nullable_to_non_nullable
              as SpecificRidConnStatistics,
      dIn: dIn == freezed
          ? _value.dIn
          : dIn // ignore: cast_nullable_to_non_nullable
              as SpecificRidDIn,
      dOut: dOut == freezed
          ? _value.dOut
          : dOut // ignore: cast_nullable_to_non_nullable
              as SpecificRidDOut,
      aIn: aIn == freezed
          ? _value.aIn
          : aIn // ignore: cast_nullable_to_non_nullable
              as SpecificRidAIn,
      aOut: aOut == freezed
          ? _value.aOut
          : aOut // ignore: cast_nullable_to_non_nullable
              as SpecificRidAOut,
      generic: generic == freezed
          ? _value.generic
          : generic // ignore: cast_nullable_to_non_nullable
              as SpecificRidGeneric,
      illuminance: illuminance == freezed
          ? _value.illuminance
          : illuminance // ignore: cast_nullable_to_non_nullable
              as SpecificRidIlluminance,
      presence: presence == freezed
          ? _value.presence
          : presence // ignore: cast_nullable_to_non_nullable
              as SpecificRidPresence,
      temperature: temperature == freezed
          ? _value.temperature
          : temperature // ignore: cast_nullable_to_non_nullable
              as SpecificRidTemperature,
      humidity: humidity == freezed
          ? _value.humidity
          : humidity // ignore: cast_nullable_to_non_nullable
              as SpecificRidHumidity,
      pwrMea: pwrMea == freezed
          ? _value.pwrMea
          : pwrMea // ignore: cast_nullable_to_non_nullable
              as SpecificRidPwrMea,
      actuation: actuation == freezed
          ? _value.actuation
          : actuation // ignore: cast_nullable_to_non_nullable
              as SpecificRidActuation,
      setPoint: setPoint == freezed
          ? _value.setPoint
          : setPoint // ignore: cast_nullable_to_non_nullable
              as SpecificRidSetPoint,
      loadCtrl: loadCtrl == freezed
          ? _value.loadCtrl
          : loadCtrl // ignore: cast_nullable_to_non_nullable
              as SpecificRidLoadCtrl,
      lightCtrl: lightCtrl == freezed
          ? _value.lightCtrl
          : lightCtrl // ignore: cast_nullable_to_non_nullable
              as SpecificRidLightCtrl,
      pwrCtrl: pwrCtrl == freezed
          ? _value.pwrCtrl
          : pwrCtrl // ignore: cast_nullable_to_non_nullable
              as SpecificRidPwrCtrl,
      accelerometer: accelerometer == freezed
          ? _value.accelerometer
          : accelerometer // ignore: cast_nullable_to_non_nullable
              as SpecificRidAccelerometer,
      magnetometer: magnetometer == freezed
          ? _value.magnetometer
          : magnetometer // ignore: cast_nullable_to_non_nullable
              as SpecificRidMagnetometer,
      barometer: barometer == freezed
          ? _value.barometer
          : barometer // ignore: cast_nullable_to_non_nullable
              as SpecificRidBarometer,
      voltage: voltage == freezed
          ? _value.voltage
          : voltage // ignore: cast_nullable_to_non_nullable
              as SpecificRidVoltage,
      current: current == freezed
          ? _value.current
          : current // ignore: cast_nullable_to_non_nullable
              as SpecificRidCurrent,
      frequency: frequency == freezed
          ? _value.frequency
          : frequency // ignore: cast_nullable_to_non_nullable
              as SpecificRidFrequency,
      depth: depth == freezed
          ? _value.depth
          : depth // ignore: cast_nullable_to_non_nullable
              as SpecificRidDepth,
      percentage: percentage == freezed
          ? _value.percentage
          : percentage // ignore: cast_nullable_to_non_nullable
              as SpecificRidPercentage,
      altitude: altitude == freezed
          ? _value.altitude
          : altitude // ignore: cast_nullable_to_non_nullable
              as SpecificRidAltitude,
      load: load == freezed
          ? _value.load
          : load // ignore: cast_nullable_to_non_nullable
              as SpecificRidLoad,
      pressure: pressure == freezed
          ? _value.pressure
          : pressure // ignore: cast_nullable_to_non_nullable
              as SpecificRidPressure,
      loudness: loudness == freezed
          ? _value.loudness
          : loudness // ignore: cast_nullable_to_non_nullable
              as SpecificRidLoudness,
      concentration: concentration == freezed
          ? _value.concentration
          : concentration // ignore: cast_nullable_to_non_nullable
              as SpecificRidConcentration,
      acidity: acidity == freezed
          ? _value.acidity
          : acidity // ignore: cast_nullable_to_non_nullable
              as SpecificRidAcidity,
      conductivity: conductivity == freezed
          ? _value.conductivity
          : conductivity // ignore: cast_nullable_to_non_nullable
              as SpecificRidConductivity,
      power: power == freezed
          ? _value.power
          : power // ignore: cast_nullable_to_non_nullable
              as SpecificRidPower,
      powerFactor: powerFactor == freezed
          ? _value.powerFactor
          : powerFactor // ignore: cast_nullable_to_non_nullable
              as SpecificRidPowerFactor,
      distance: distance == freezed
          ? _value.distance
          : distance // ignore: cast_nullable_to_non_nullable
              as SpecificRidDistance,
      energy: energy == freezed
          ? _value.energy
          : energy // ignore: cast_nullable_to_non_nullable
              as SpecificRidEnergy,
      direction: direction == freezed
          ? _value.direction
          : direction // ignore: cast_nullable_to_non_nullable
              as SpecificRidDirection,
      time: time == freezed
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as SpecificRidTime,
      gyrometer: gyrometer == freezed
          ? _value.gyrometer
          : gyrometer // ignore: cast_nullable_to_non_nullable
              as SpecificRidGyrometer,
      colour: colour == freezed
          ? _value.colour
          : colour // ignore: cast_nullable_to_non_nullable
              as SpecificRidColour,
      gpsLocation: gpsLocation == freezed
          ? _value.gpsLocation
          : gpsLocation // ignore: cast_nullable_to_non_nullable
              as SpecificRidGpsLocation,
      positioner: positioner == freezed
          ? _value.positioner
          : positioner // ignore: cast_nullable_to_non_nullable
              as SpecificRidPositioner,
      buzzer: buzzer == freezed
          ? _value.buzzer
          : buzzer // ignore: cast_nullable_to_non_nullable
              as SpecificRidBuzzer,
      audioClip: audioClip == freezed
          ? _value.audioClip
          : audioClip // ignore: cast_nullable_to_non_nullable
              as SpecificRidAudioClip,
      timer: timer == freezed
          ? _value.timer
          : timer // ignore: cast_nullable_to_non_nullable
              as SpecificRidTimer,
      addressableTextDisplay: addressableTextDisplay == freezed
          ? _value.addressableTextDisplay
          : addressableTextDisplay // ignore: cast_nullable_to_non_nullable
              as SpecificRidAddressableTextDisplay,
      onOffSwitch: onOffSwitch == freezed
          ? _value.onOffSwitch
          : onOffSwitch // ignore: cast_nullable_to_non_nullable
              as SpecificRidOnOffSwitch,
      levelControl: levelControl == freezed
          ? _value.levelControl
          : levelControl // ignore: cast_nullable_to_non_nullable
              as SpecificRidLevelControl,
      upDownControl: upDownControl == freezed
          ? _value.upDownControl
          : upDownControl // ignore: cast_nullable_to_non_nullable
              as SpecificRidUpDownControl,
      multipleAxisJoystick: multipleAxisJoystick == freezed
          ? _value.multipleAxisJoystick
          : multipleAxisJoystick // ignore: cast_nullable_to_non_nullable
              as SpecificRidMultipleAxisJoystick,
      rate: rate == freezed
          ? _value.rate
          : rate // ignore: cast_nullable_to_non_nullable
              as SpecificRidRate,
      pushButton: pushButton == freezed
          ? _value.pushButton
          : pushButton // ignore: cast_nullable_to_non_nullable
              as SpecificRidPushButton,
      multistateSelector: multistateSelector == freezed
          ? _value.multistateSelector
          : multistateSelector // ignore: cast_nullable_to_non_nullable
              as SpecificRidMultistateSelector,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRid implements _SpecificRid {
  const _$_SpecificRid(
      {required this.lwm2mSecurity,
      required this.lwm2mServer,
      required this.accessCtrl,
      required this.device,
      required this.connMonitor,
      required this.firmware,
      required this.location,
      required this.connStatistics,
      required this.dIn,
      required this.dOut,
      required this.aIn,
      required this.aOut,
      required this.generic,
      required this.illuminance,
      required this.presence,
      required this.temperature,
      required this.humidity,
      required this.pwrMea,
      required this.actuation,
      required this.setPoint,
      required this.loadCtrl,
      required this.lightCtrl,
      required this.pwrCtrl,
      required this.accelerometer,
      required this.magnetometer,
      required this.barometer,
      required this.voltage,
      required this.current,
      required this.frequency,
      required this.depth,
      required this.percentage,
      required this.altitude,
      required this.load,
      required this.pressure,
      required this.loudness,
      required this.concentration,
      required this.acidity,
      required this.conductivity,
      required this.power,
      required this.powerFactor,
      required this.distance,
      required this.energy,
      required this.direction,
      required this.time,
      required this.gyrometer,
      required this.colour,
      required this.gpsLocation,
      required this.positioner,
      required this.buzzer,
      required this.audioClip,
      required this.timer,
      required this.addressableTextDisplay,
      required this.onOffSwitch,
      required this.levelControl,
      required this.upDownControl,
      required this.multipleAxisJoystick,
      required this.rate,
      required this.pushButton,
      required this.multistateSelector});

  factory _$_SpecificRid.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidFromJson(json);

  @override
  final SpecificRidLwm2mSecurity lwm2mSecurity;
  @override
  final SpecificRidLwm2mServer lwm2mServer;
  @override
  final SpecificRidAccessCtrl accessCtrl;
  @override
  final SpecificRidDevice device;
  @override
  final SpecificRidConnMonitor connMonitor;
  @override
  final SpecificRidFirmware firmware;
  @override
  final SpecificRidLocation location;
  @override
  final SpecificRidConnStatistics connStatistics;
  @override
  final SpecificRidDIn dIn;
  @override
  final SpecificRidDOut dOut;
  @override
  final SpecificRidAIn aIn;
  @override
  final SpecificRidAOut aOut;
  @override
  final SpecificRidGeneric generic;
  @override
  final SpecificRidIlluminance illuminance;
  @override
  final SpecificRidPresence presence;
  @override
  final SpecificRidTemperature temperature;
  @override
  final SpecificRidHumidity humidity;
  @override
  final SpecificRidPwrMea pwrMea;
  @override
  final SpecificRidActuation actuation;
  @override
  final SpecificRidSetPoint setPoint;
  @override
  final SpecificRidLoadCtrl loadCtrl;
  @override
  final SpecificRidLightCtrl lightCtrl;
  @override
  final SpecificRidPwrCtrl pwrCtrl;
  @override
  final SpecificRidAccelerometer accelerometer;
  @override
  final SpecificRidMagnetometer magnetometer;
  @override
  final SpecificRidBarometer barometer;
  @override
  final SpecificRidVoltage voltage;
  @override
  final SpecificRidCurrent current;
  @override
  final SpecificRidFrequency frequency;
  @override
  final SpecificRidDepth depth;
  @override
  final SpecificRidPercentage percentage;
  @override
  final SpecificRidAltitude altitude;
  @override
  final SpecificRidLoad load;
  @override
  final SpecificRidPressure pressure;
  @override
  final SpecificRidLoudness loudness;
  @override
  final SpecificRidConcentration concentration;
  @override
  final SpecificRidAcidity acidity;
  @override
  final SpecificRidConductivity conductivity;
  @override
  final SpecificRidPower power;
  @override
  final SpecificRidPowerFactor powerFactor;
  @override
  final SpecificRidDistance distance;
  @override
  final SpecificRidEnergy energy;
  @override
  final SpecificRidDirection direction;
  @override
  final SpecificRidTime time;
  @override
  final SpecificRidGyrometer gyrometer;
  @override
  final SpecificRidColour colour;
  @override
  final SpecificRidGpsLocation gpsLocation;
  @override
  final SpecificRidPositioner positioner;
  @override
  final SpecificRidBuzzer buzzer;
  @override
  final SpecificRidAudioClip audioClip;
  @override
  final SpecificRidTimer timer;
  @override
  final SpecificRidAddressableTextDisplay addressableTextDisplay;
  @override
  final SpecificRidOnOffSwitch onOffSwitch;
  @override
  final SpecificRidLevelControl levelControl;
  @override
  final SpecificRidUpDownControl upDownControl;
  @override
  final SpecificRidMultipleAxisJoystick multipleAxisJoystick;
  @override
  final SpecificRidRate rate;
  @override
  final SpecificRidPushButton pushButton;
  @override
  final SpecificRidMultistateSelector multistateSelector;

  @override
  String toString() {
    return 'SpecificRid(lwm2mSecurity: $lwm2mSecurity, lwm2mServer: $lwm2mServer, accessCtrl: $accessCtrl, device: $device, connMonitor: $connMonitor, firmware: $firmware, location: $location, connStatistics: $connStatistics, dIn: $dIn, dOut: $dOut, aIn: $aIn, aOut: $aOut, generic: $generic, illuminance: $illuminance, presence: $presence, temperature: $temperature, humidity: $humidity, pwrMea: $pwrMea, actuation: $actuation, setPoint: $setPoint, loadCtrl: $loadCtrl, lightCtrl: $lightCtrl, pwrCtrl: $pwrCtrl, accelerometer: $accelerometer, magnetometer: $magnetometer, barometer: $barometer, voltage: $voltage, current: $current, frequency: $frequency, depth: $depth, percentage: $percentage, altitude: $altitude, load: $load, pressure: $pressure, loudness: $loudness, concentration: $concentration, acidity: $acidity, conductivity: $conductivity, power: $power, powerFactor: $powerFactor, distance: $distance, energy: $energy, direction: $direction, time: $time, gyrometer: $gyrometer, colour: $colour, gpsLocation: $gpsLocation, positioner: $positioner, buzzer: $buzzer, audioClip: $audioClip, timer: $timer, addressableTextDisplay: $addressableTextDisplay, onOffSwitch: $onOffSwitch, levelControl: $levelControl, upDownControl: $upDownControl, multipleAxisJoystick: $multipleAxisJoystick, rate: $rate, pushButton: $pushButton, multistateSelector: $multistateSelector)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRid &&
            (identical(other.lwm2mSecurity, lwm2mSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.lwm2mSecurity, lwm2mSecurity)) &&
            (identical(other.lwm2mServer, lwm2mServer) ||
                const DeepCollectionEquality()
                    .equals(other.lwm2mServer, lwm2mServer)) &&
            (identical(other.accessCtrl, accessCtrl) ||
                const DeepCollectionEquality()
                    .equals(other.accessCtrl, accessCtrl)) &&
            (identical(other.device, device) ||
                const DeepCollectionEquality().equals(other.device, device)) &&
            (identical(other.connMonitor, connMonitor) ||
                const DeepCollectionEquality()
                    .equals(other.connMonitor, connMonitor)) &&
            (identical(other.firmware, firmware) ||
                const DeepCollectionEquality()
                    .equals(other.firmware, firmware)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.connStatistics, connStatistics) ||
                const DeepCollectionEquality()
                    .equals(other.connStatistics, connStatistics)) &&
            (identical(other.dIn, dIn) ||
                const DeepCollectionEquality().equals(other.dIn, dIn)) &&
            (identical(other.dOut, dOut) ||
                const DeepCollectionEquality().equals(other.dOut, dOut)) &&
            (identical(other.aIn, aIn) ||
                const DeepCollectionEquality().equals(other.aIn, aIn)) &&
            (identical(other.aOut, aOut) ||
                const DeepCollectionEquality().equals(other.aOut, aOut)) &&
            (identical(other.generic, generic) ||
                const DeepCollectionEquality()
                    .equals(other.generic, generic)) &&
            (identical(other.illuminance, illuminance) ||
                const DeepCollectionEquality()
                    .equals(other.illuminance, illuminance)) &&
            (identical(other.presence, presence) ||
                const DeepCollectionEquality()
                    .equals(other.presence, presence)) &&
            (identical(other.temperature, temperature) ||
                const DeepCollectionEquality()
                    .equals(other.temperature, temperature)) &&
            (identical(other.humidity, humidity) ||
                const DeepCollectionEquality()
                    .equals(other.humidity, humidity)) &&
            (identical(other.pwrMea, pwrMea) ||
                const DeepCollectionEquality().equals(other.pwrMea, pwrMea)) &&
            (identical(other.actuation, actuation) ||
                const DeepCollectionEquality()
                    .equals(other.actuation, actuation)) &&
            (identical(other.setPoint, setPoint) ||
                const DeepCollectionEquality()
                    .equals(other.setPoint, setPoint)) &&
            (identical(other.loadCtrl, loadCtrl) ||
                const DeepCollectionEquality()
                    .equals(other.loadCtrl, loadCtrl)) &&
            (identical(other.lightCtrl, lightCtrl) ||
                const DeepCollectionEquality()
                    .equals(other.lightCtrl, lightCtrl)) &&
            (identical(other.pwrCtrl, pwrCtrl) ||
                const DeepCollectionEquality()
                    .equals(other.pwrCtrl, pwrCtrl)) &&
            (identical(other.accelerometer, accelerometer) ||
                const DeepCollectionEquality()
                    .equals(other.accelerometer, accelerometer)) &&
            (identical(other.magnetometer, magnetometer) ||
                const DeepCollectionEquality().equals(other.magnetometer, magnetometer)) &&
            (identical(other.barometer, barometer) || const DeepCollectionEquality().equals(other.barometer, barometer)) &&
            (identical(other.voltage, voltage) || const DeepCollectionEquality().equals(other.voltage, voltage)) &&
            (identical(other.current, current) || const DeepCollectionEquality().equals(other.current, current)) &&
            (identical(other.frequency, frequency) || const DeepCollectionEquality().equals(other.frequency, frequency)) &&
            (identical(other.depth, depth) || const DeepCollectionEquality().equals(other.depth, depth)) &&
            (identical(other.percentage, percentage) || const DeepCollectionEquality().equals(other.percentage, percentage)) &&
            (identical(other.altitude, altitude) || const DeepCollectionEquality().equals(other.altitude, altitude)) &&
            (identical(other.load, load) || const DeepCollectionEquality().equals(other.load, load)) &&
            (identical(other.pressure, pressure) || const DeepCollectionEquality().equals(other.pressure, pressure)) &&
            (identical(other.loudness, loudness) || const DeepCollectionEquality().equals(other.loudness, loudness)) &&
            (identical(other.concentration, concentration) || const DeepCollectionEquality().equals(other.concentration, concentration)) &&
            (identical(other.acidity, acidity) || const DeepCollectionEquality().equals(other.acidity, acidity)) &&
            (identical(other.conductivity, conductivity) || const DeepCollectionEquality().equals(other.conductivity, conductivity)) &&
            (identical(other.power, power) || const DeepCollectionEquality().equals(other.power, power)) &&
            (identical(other.powerFactor, powerFactor) || const DeepCollectionEquality().equals(other.powerFactor, powerFactor)) &&
            (identical(other.distance, distance) || const DeepCollectionEquality().equals(other.distance, distance)) &&
            (identical(other.energy, energy) || const DeepCollectionEquality().equals(other.energy, energy)) &&
            (identical(other.direction, direction) || const DeepCollectionEquality().equals(other.direction, direction)) &&
            (identical(other.time, time) || const DeepCollectionEquality().equals(other.time, time)) &&
            (identical(other.gyrometer, gyrometer) || const DeepCollectionEquality().equals(other.gyrometer, gyrometer)) &&
            (identical(other.colour, colour) || const DeepCollectionEquality().equals(other.colour, colour)) &&
            (identical(other.gpsLocation, gpsLocation) || const DeepCollectionEquality().equals(other.gpsLocation, gpsLocation)) &&
            (identical(other.positioner, positioner) || const DeepCollectionEquality().equals(other.positioner, positioner)) &&
            (identical(other.buzzer, buzzer) || const DeepCollectionEquality().equals(other.buzzer, buzzer)) &&
            (identical(other.audioClip, audioClip) || const DeepCollectionEquality().equals(other.audioClip, audioClip)) &&
            (identical(other.timer, timer) || const DeepCollectionEquality().equals(other.timer, timer)) &&
            (identical(other.addressableTextDisplay, addressableTextDisplay) || const DeepCollectionEquality().equals(other.addressableTextDisplay, addressableTextDisplay)) &&
            (identical(other.onOffSwitch, onOffSwitch) || const DeepCollectionEquality().equals(other.onOffSwitch, onOffSwitch)) &&
            (identical(other.levelControl, levelControl) || const DeepCollectionEquality().equals(other.levelControl, levelControl)) &&
            (identical(other.upDownControl, upDownControl) || const DeepCollectionEquality().equals(other.upDownControl, upDownControl)) &&
            (identical(other.multipleAxisJoystick, multipleAxisJoystick) || const DeepCollectionEquality().equals(other.multipleAxisJoystick, multipleAxisJoystick)) &&
            (identical(other.rate, rate) || const DeepCollectionEquality().equals(other.rate, rate)) &&
            (identical(other.pushButton, pushButton) || const DeepCollectionEquality().equals(other.pushButton, pushButton)) &&
            (identical(other.multistateSelector, multistateSelector) || const DeepCollectionEquality().equals(other.multistateSelector, multistateSelector)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(lwm2mSecurity) ^
      const DeepCollectionEquality().hash(lwm2mServer) ^
      const DeepCollectionEquality().hash(accessCtrl) ^
      const DeepCollectionEquality().hash(device) ^
      const DeepCollectionEquality().hash(connMonitor) ^
      const DeepCollectionEquality().hash(firmware) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(connStatistics) ^
      const DeepCollectionEquality().hash(dIn) ^
      const DeepCollectionEquality().hash(dOut) ^
      const DeepCollectionEquality().hash(aIn) ^
      const DeepCollectionEquality().hash(aOut) ^
      const DeepCollectionEquality().hash(generic) ^
      const DeepCollectionEquality().hash(illuminance) ^
      const DeepCollectionEquality().hash(presence) ^
      const DeepCollectionEquality().hash(temperature) ^
      const DeepCollectionEquality().hash(humidity) ^
      const DeepCollectionEquality().hash(pwrMea) ^
      const DeepCollectionEquality().hash(actuation) ^
      const DeepCollectionEquality().hash(setPoint) ^
      const DeepCollectionEquality().hash(loadCtrl) ^
      const DeepCollectionEquality().hash(lightCtrl) ^
      const DeepCollectionEquality().hash(pwrCtrl) ^
      const DeepCollectionEquality().hash(accelerometer) ^
      const DeepCollectionEquality().hash(magnetometer) ^
      const DeepCollectionEquality().hash(barometer) ^
      const DeepCollectionEquality().hash(voltage) ^
      const DeepCollectionEquality().hash(current) ^
      const DeepCollectionEquality().hash(frequency) ^
      const DeepCollectionEquality().hash(depth) ^
      const DeepCollectionEquality().hash(percentage) ^
      const DeepCollectionEquality().hash(altitude) ^
      const DeepCollectionEquality().hash(load) ^
      const DeepCollectionEquality().hash(pressure) ^
      const DeepCollectionEquality().hash(loudness) ^
      const DeepCollectionEquality().hash(concentration) ^
      const DeepCollectionEquality().hash(acidity) ^
      const DeepCollectionEquality().hash(conductivity) ^
      const DeepCollectionEquality().hash(power) ^
      const DeepCollectionEquality().hash(powerFactor) ^
      const DeepCollectionEquality().hash(distance) ^
      const DeepCollectionEquality().hash(energy) ^
      const DeepCollectionEquality().hash(direction) ^
      const DeepCollectionEquality().hash(time) ^
      const DeepCollectionEquality().hash(gyrometer) ^
      const DeepCollectionEquality().hash(colour) ^
      const DeepCollectionEquality().hash(gpsLocation) ^
      const DeepCollectionEquality().hash(positioner) ^
      const DeepCollectionEquality().hash(buzzer) ^
      const DeepCollectionEquality().hash(audioClip) ^
      const DeepCollectionEquality().hash(timer) ^
      const DeepCollectionEquality().hash(addressableTextDisplay) ^
      const DeepCollectionEquality().hash(onOffSwitch) ^
      const DeepCollectionEquality().hash(levelControl) ^
      const DeepCollectionEquality().hash(upDownControl) ^
      const DeepCollectionEquality().hash(multipleAxisJoystick) ^
      const DeepCollectionEquality().hash(rate) ^
      const DeepCollectionEquality().hash(pushButton) ^
      const DeepCollectionEquality().hash(multistateSelector);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidCopyWith<_SpecificRid> get copyWith =>
      __$SpecificRidCopyWithImpl<_SpecificRid>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidToJson(this);
  }
}

abstract class _SpecificRid implements SpecificRid {
  const factory _SpecificRid(
          {required SpecificRidLwm2mSecurity lwm2mSecurity,
          required SpecificRidLwm2mServer lwm2mServer,
          required SpecificRidAccessCtrl accessCtrl,
          required SpecificRidDevice device,
          required SpecificRidConnMonitor connMonitor,
          required SpecificRidFirmware firmware,
          required SpecificRidLocation location,
          required SpecificRidConnStatistics connStatistics,
          required SpecificRidDIn dIn,
          required SpecificRidDOut dOut,
          required SpecificRidAIn aIn,
          required SpecificRidAOut aOut,
          required SpecificRidGeneric generic,
          required SpecificRidIlluminance illuminance,
          required SpecificRidPresence presence,
          required SpecificRidTemperature temperature,
          required SpecificRidHumidity humidity,
          required SpecificRidPwrMea pwrMea,
          required SpecificRidActuation actuation,
          required SpecificRidSetPoint setPoint,
          required SpecificRidLoadCtrl loadCtrl,
          required SpecificRidLightCtrl lightCtrl,
          required SpecificRidPwrCtrl pwrCtrl,
          required SpecificRidAccelerometer accelerometer,
          required SpecificRidMagnetometer magnetometer,
          required SpecificRidBarometer barometer,
          required SpecificRidVoltage voltage,
          required SpecificRidCurrent current,
          required SpecificRidFrequency frequency,
          required SpecificRidDepth depth,
          required SpecificRidPercentage percentage,
          required SpecificRidAltitude altitude,
          required SpecificRidLoad load,
          required SpecificRidPressure pressure,
          required SpecificRidLoudness loudness,
          required SpecificRidConcentration concentration,
          required SpecificRidAcidity acidity,
          required SpecificRidConductivity conductivity,
          required SpecificRidPower power,
          required SpecificRidPowerFactor powerFactor,
          required SpecificRidDistance distance,
          required SpecificRidEnergy energy,
          required SpecificRidDirection direction,
          required SpecificRidTime time,
          required SpecificRidGyrometer gyrometer,
          required SpecificRidColour colour,
          required SpecificRidGpsLocation gpsLocation,
          required SpecificRidPositioner positioner,
          required SpecificRidBuzzer buzzer,
          required SpecificRidAudioClip audioClip,
          required SpecificRidTimer timer,
          required SpecificRidAddressableTextDisplay addressableTextDisplay,
          required SpecificRidOnOffSwitch onOffSwitch,
          required SpecificRidLevelControl levelControl,
          required SpecificRidUpDownControl upDownControl,
          required SpecificRidMultipleAxisJoystick multipleAxisJoystick,
          required SpecificRidRate rate,
          required SpecificRidPushButton pushButton,
          required SpecificRidMultistateSelector multistateSelector}) =
      _$_SpecificRid;

  factory _SpecificRid.fromJson(Map<String, dynamic> json) =
      _$_SpecificRid.fromJson;

  @override
  SpecificRidLwm2mSecurity get lwm2mSecurity =>
      throw _privateConstructorUsedError;
  @override
  SpecificRidLwm2mServer get lwm2mServer => throw _privateConstructorUsedError;
  @override
  SpecificRidAccessCtrl get accessCtrl => throw _privateConstructorUsedError;
  @override
  SpecificRidDevice get device => throw _privateConstructorUsedError;
  @override
  SpecificRidConnMonitor get connMonitor => throw _privateConstructorUsedError;
  @override
  SpecificRidFirmware get firmware => throw _privateConstructorUsedError;
  @override
  SpecificRidLocation get location => throw _privateConstructorUsedError;
  @override
  SpecificRidConnStatistics get connStatistics =>
      throw _privateConstructorUsedError;
  @override
  SpecificRidDIn get dIn => throw _privateConstructorUsedError;
  @override
  SpecificRidDOut get dOut => throw _privateConstructorUsedError;
  @override
  SpecificRidAIn get aIn => throw _privateConstructorUsedError;
  @override
  SpecificRidAOut get aOut => throw _privateConstructorUsedError;
  @override
  SpecificRidGeneric get generic => throw _privateConstructorUsedError;
  @override
  SpecificRidIlluminance get illuminance => throw _privateConstructorUsedError;
  @override
  SpecificRidPresence get presence => throw _privateConstructorUsedError;
  @override
  SpecificRidTemperature get temperature => throw _privateConstructorUsedError;
  @override
  SpecificRidHumidity get humidity => throw _privateConstructorUsedError;
  @override
  SpecificRidPwrMea get pwrMea => throw _privateConstructorUsedError;
  @override
  SpecificRidActuation get actuation => throw _privateConstructorUsedError;
  @override
  SpecificRidSetPoint get setPoint => throw _privateConstructorUsedError;
  @override
  SpecificRidLoadCtrl get loadCtrl => throw _privateConstructorUsedError;
  @override
  SpecificRidLightCtrl get lightCtrl => throw _privateConstructorUsedError;
  @override
  SpecificRidPwrCtrl get pwrCtrl => throw _privateConstructorUsedError;
  @override
  SpecificRidAccelerometer get accelerometer =>
      throw _privateConstructorUsedError;
  @override
  SpecificRidMagnetometer get magnetometer =>
      throw _privateConstructorUsedError;
  @override
  SpecificRidBarometer get barometer => throw _privateConstructorUsedError;
  @override
  SpecificRidVoltage get voltage => throw _privateConstructorUsedError;
  @override
  SpecificRidCurrent get current => throw _privateConstructorUsedError;
  @override
  SpecificRidFrequency get frequency => throw _privateConstructorUsedError;
  @override
  SpecificRidDepth get depth => throw _privateConstructorUsedError;
  @override
  SpecificRidPercentage get percentage => throw _privateConstructorUsedError;
  @override
  SpecificRidAltitude get altitude => throw _privateConstructorUsedError;
  @override
  SpecificRidLoad get load => throw _privateConstructorUsedError;
  @override
  SpecificRidPressure get pressure => throw _privateConstructorUsedError;
  @override
  SpecificRidLoudness get loudness => throw _privateConstructorUsedError;
  @override
  SpecificRidConcentration get concentration =>
      throw _privateConstructorUsedError;
  @override
  SpecificRidAcidity get acidity => throw _privateConstructorUsedError;
  @override
  SpecificRidConductivity get conductivity =>
      throw _privateConstructorUsedError;
  @override
  SpecificRidPower get power => throw _privateConstructorUsedError;
  @override
  SpecificRidPowerFactor get powerFactor => throw _privateConstructorUsedError;
  @override
  SpecificRidDistance get distance => throw _privateConstructorUsedError;
  @override
  SpecificRidEnergy get energy => throw _privateConstructorUsedError;
  @override
  SpecificRidDirection get direction => throw _privateConstructorUsedError;
  @override
  SpecificRidTime get time => throw _privateConstructorUsedError;
  @override
  SpecificRidGyrometer get gyrometer => throw _privateConstructorUsedError;
  @override
  SpecificRidColour get colour => throw _privateConstructorUsedError;
  @override
  SpecificRidGpsLocation get gpsLocation => throw _privateConstructorUsedError;
  @override
  SpecificRidPositioner get positioner => throw _privateConstructorUsedError;
  @override
  SpecificRidBuzzer get buzzer => throw _privateConstructorUsedError;
  @override
  SpecificRidAudioClip get audioClip => throw _privateConstructorUsedError;
  @override
  SpecificRidTimer get timer => throw _privateConstructorUsedError;
  @override
  SpecificRidAddressableTextDisplay get addressableTextDisplay =>
      throw _privateConstructorUsedError;
  @override
  SpecificRidOnOffSwitch get onOffSwitch => throw _privateConstructorUsedError;
  @override
  SpecificRidLevelControl get levelControl =>
      throw _privateConstructorUsedError;
  @override
  SpecificRidUpDownControl get upDownControl =>
      throw _privateConstructorUsedError;
  @override
  SpecificRidMultipleAxisJoystick get multipleAxisJoystick =>
      throw _privateConstructorUsedError;
  @override
  SpecificRidRate get rate => throw _privateConstructorUsedError;
  @override
  SpecificRidPushButton get pushButton => throw _privateConstructorUsedError;
  @override
  SpecificRidMultistateSelector get multistateSelector =>
      throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidCopyWith<_SpecificRid> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidAcidity _$SpecificRidAcidityFromJson(Map<String, dynamic> json) {
  return _SpecificRidAcidity.fromJson(json);
}

/// @nodoc
class _$SpecificRidAcidityTearOff {
  const _$SpecificRidAcidityTearOff();

  _SpecificRidAcidity call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) {
    return _SpecificRidAcidity(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      calOffset: calOffset,
      appType: appType,
    );
  }

  SpecificRidAcidity fromJson(Map<String, Object> json) {
    return SpecificRidAcidity.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidAcidity = _$SpecificRidAcidityTearOff();

/// @nodoc
mixin _$SpecificRidAcidity {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get calOffset => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidAcidityCopyWith<SpecificRidAcidity> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidAcidityCopyWith<$Res> {
  factory $SpecificRidAcidityCopyWith(
          SpecificRidAcidity value, $Res Function(SpecificRidAcidity) then) =
      _$SpecificRidAcidityCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class _$SpecificRidAcidityCopyWithImpl<$Res>
    implements $SpecificRidAcidityCopyWith<$Res> {
  _$SpecificRidAcidityCopyWithImpl(this._value, this._then);

  final SpecificRidAcidity _value;
  // ignore: unused_field
  final $Res Function(SpecificRidAcidity) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidAcidityCopyWith<$Res>
    implements $SpecificRidAcidityCopyWith<$Res> {
  factory _$SpecificRidAcidityCopyWith(
          _SpecificRidAcidity value, $Res Function(_SpecificRidAcidity) then) =
      __$SpecificRidAcidityCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class __$SpecificRidAcidityCopyWithImpl<$Res>
    extends _$SpecificRidAcidityCopyWithImpl<$Res>
    implements _$SpecificRidAcidityCopyWith<$Res> {
  __$SpecificRidAcidityCopyWithImpl(
      _SpecificRidAcidity _value, $Res Function(_SpecificRidAcidity) _then)
      : super(_value, (v) => _then(v as _SpecificRidAcidity));

  @override
  _SpecificRidAcidity get _value => super._value as _SpecificRidAcidity;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidAcidity(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidAcidity implements _SpecificRidAcidity {
  const _$_SpecificRidAcidity(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues,
      required this.calOffset,
      required this.appType});

  factory _$_SpecificRidAcidity.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidAcidityFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int calOffset;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidAcidity(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, calOffset: $calOffset, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidAcidity &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.calOffset, calOffset) ||
                const DeepCollectionEquality()
                    .equals(other.calOffset, calOffset)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(calOffset) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidAcidityCopyWith<_SpecificRidAcidity> get copyWith =>
      __$SpecificRidAcidityCopyWithImpl<_SpecificRidAcidity>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidAcidityToJson(this);
  }
}

abstract class _SpecificRidAcidity implements SpecificRidAcidity {
  const factory _SpecificRidAcidity(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) = _$_SpecificRidAcidity;

  factory _SpecificRidAcidity.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidAcidity.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get calOffset => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidAcidityCopyWith<_SpecificRidAcidity> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidAddressableTextDisplay _$SpecificRidAddressableTextDisplayFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidAddressableTextDisplay.fromJson(json);
}

/// @nodoc
class _$SpecificRidAddressableTextDisplayTearOff {
  const _$SpecificRidAddressableTextDisplayTearOff();

  _SpecificRidAddressableTextDisplay call(
      {required int text,
      required int xCoord,
      required int yCoord,
      required int maxXCoord,
      required int maxYCoord,
      required int clearDisplay,
      required int contrast,
      required int level,
      required int appType}) {
    return _SpecificRidAddressableTextDisplay(
      text: text,
      xCoord: xCoord,
      yCoord: yCoord,
      maxXCoord: maxXCoord,
      maxYCoord: maxYCoord,
      clearDisplay: clearDisplay,
      contrast: contrast,
      level: level,
      appType: appType,
    );
  }

  SpecificRidAddressableTextDisplay fromJson(Map<String, Object> json) {
    return SpecificRidAddressableTextDisplay.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidAddressableTextDisplay =
    _$SpecificRidAddressableTextDisplayTearOff();

/// @nodoc
mixin _$SpecificRidAddressableTextDisplay {
  int get text => throw _privateConstructorUsedError;
  int get xCoord => throw _privateConstructorUsedError;
  int get yCoord => throw _privateConstructorUsedError;
  int get maxXCoord => throw _privateConstructorUsedError;
  int get maxYCoord => throw _privateConstructorUsedError;
  int get clearDisplay => throw _privateConstructorUsedError;
  int get contrast => throw _privateConstructorUsedError;
  int get level => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidAddressableTextDisplayCopyWith<SpecificRidAddressableTextDisplay>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidAddressableTextDisplayCopyWith<$Res> {
  factory $SpecificRidAddressableTextDisplayCopyWith(
          SpecificRidAddressableTextDisplay value,
          $Res Function(SpecificRidAddressableTextDisplay) then) =
      _$SpecificRidAddressableTextDisplayCopyWithImpl<$Res>;
  $Res call(
      {int text,
      int xCoord,
      int yCoord,
      int maxXCoord,
      int maxYCoord,
      int clearDisplay,
      int contrast,
      int level,
      int appType});
}

/// @nodoc
class _$SpecificRidAddressableTextDisplayCopyWithImpl<$Res>
    implements $SpecificRidAddressableTextDisplayCopyWith<$Res> {
  _$SpecificRidAddressableTextDisplayCopyWithImpl(this._value, this._then);

  final SpecificRidAddressableTextDisplay _value;
  // ignore: unused_field
  final $Res Function(SpecificRidAddressableTextDisplay) _then;

  @override
  $Res call({
    Object? text = freezed,
    Object? xCoord = freezed,
    Object? yCoord = freezed,
    Object? maxXCoord = freezed,
    Object? maxYCoord = freezed,
    Object? clearDisplay = freezed,
    Object? contrast = freezed,
    Object? level = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      text: text == freezed
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as int,
      xCoord: xCoord == freezed
          ? _value.xCoord
          : xCoord // ignore: cast_nullable_to_non_nullable
              as int,
      yCoord: yCoord == freezed
          ? _value.yCoord
          : yCoord // ignore: cast_nullable_to_non_nullable
              as int,
      maxXCoord: maxXCoord == freezed
          ? _value.maxXCoord
          : maxXCoord // ignore: cast_nullable_to_non_nullable
              as int,
      maxYCoord: maxYCoord == freezed
          ? _value.maxYCoord
          : maxYCoord // ignore: cast_nullable_to_non_nullable
              as int,
      clearDisplay: clearDisplay == freezed
          ? _value.clearDisplay
          : clearDisplay // ignore: cast_nullable_to_non_nullable
              as int,
      contrast: contrast == freezed
          ? _value.contrast
          : contrast // ignore: cast_nullable_to_non_nullable
              as int,
      level: level == freezed
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidAddressableTextDisplayCopyWith<$Res>
    implements $SpecificRidAddressableTextDisplayCopyWith<$Res> {
  factory _$SpecificRidAddressableTextDisplayCopyWith(
          _SpecificRidAddressableTextDisplay value,
          $Res Function(_SpecificRidAddressableTextDisplay) then) =
      __$SpecificRidAddressableTextDisplayCopyWithImpl<$Res>;
  @override
  $Res call(
      {int text,
      int xCoord,
      int yCoord,
      int maxXCoord,
      int maxYCoord,
      int clearDisplay,
      int contrast,
      int level,
      int appType});
}

/// @nodoc
class __$SpecificRidAddressableTextDisplayCopyWithImpl<$Res>
    extends _$SpecificRidAddressableTextDisplayCopyWithImpl<$Res>
    implements _$SpecificRidAddressableTextDisplayCopyWith<$Res> {
  __$SpecificRidAddressableTextDisplayCopyWithImpl(
      _SpecificRidAddressableTextDisplay _value,
      $Res Function(_SpecificRidAddressableTextDisplay) _then)
      : super(_value, (v) => _then(v as _SpecificRidAddressableTextDisplay));

  @override
  _SpecificRidAddressableTextDisplay get _value =>
      super._value as _SpecificRidAddressableTextDisplay;

  @override
  $Res call({
    Object? text = freezed,
    Object? xCoord = freezed,
    Object? yCoord = freezed,
    Object? maxXCoord = freezed,
    Object? maxYCoord = freezed,
    Object? clearDisplay = freezed,
    Object? contrast = freezed,
    Object? level = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidAddressableTextDisplay(
      text: text == freezed
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as int,
      xCoord: xCoord == freezed
          ? _value.xCoord
          : xCoord // ignore: cast_nullable_to_non_nullable
              as int,
      yCoord: yCoord == freezed
          ? _value.yCoord
          : yCoord // ignore: cast_nullable_to_non_nullable
              as int,
      maxXCoord: maxXCoord == freezed
          ? _value.maxXCoord
          : maxXCoord // ignore: cast_nullable_to_non_nullable
              as int,
      maxYCoord: maxYCoord == freezed
          ? _value.maxYCoord
          : maxYCoord // ignore: cast_nullable_to_non_nullable
              as int,
      clearDisplay: clearDisplay == freezed
          ? _value.clearDisplay
          : clearDisplay // ignore: cast_nullable_to_non_nullable
              as int,
      contrast: contrast == freezed
          ? _value.contrast
          : contrast // ignore: cast_nullable_to_non_nullable
              as int,
      level: level == freezed
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidAddressableTextDisplay
    implements _SpecificRidAddressableTextDisplay {
  const _$_SpecificRidAddressableTextDisplay(
      {required this.text,
      required this.xCoord,
      required this.yCoord,
      required this.maxXCoord,
      required this.maxYCoord,
      required this.clearDisplay,
      required this.contrast,
      required this.level,
      required this.appType});

  factory _$_SpecificRidAddressableTextDisplay.fromJson(
          Map<String, dynamic> json) =>
      _$$_SpecificRidAddressableTextDisplayFromJson(json);

  @override
  final int text;
  @override
  final int xCoord;
  @override
  final int yCoord;
  @override
  final int maxXCoord;
  @override
  final int maxYCoord;
  @override
  final int clearDisplay;
  @override
  final int contrast;
  @override
  final int level;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidAddressableTextDisplay(text: $text, xCoord: $xCoord, yCoord: $yCoord, maxXCoord: $maxXCoord, maxYCoord: $maxYCoord, clearDisplay: $clearDisplay, contrast: $contrast, level: $level, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidAddressableTextDisplay &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.xCoord, xCoord) ||
                const DeepCollectionEquality().equals(other.xCoord, xCoord)) &&
            (identical(other.yCoord, yCoord) ||
                const DeepCollectionEquality().equals(other.yCoord, yCoord)) &&
            (identical(other.maxXCoord, maxXCoord) ||
                const DeepCollectionEquality()
                    .equals(other.maxXCoord, maxXCoord)) &&
            (identical(other.maxYCoord, maxYCoord) ||
                const DeepCollectionEquality()
                    .equals(other.maxYCoord, maxYCoord)) &&
            (identical(other.clearDisplay, clearDisplay) ||
                const DeepCollectionEquality()
                    .equals(other.clearDisplay, clearDisplay)) &&
            (identical(other.contrast, contrast) ||
                const DeepCollectionEquality()
                    .equals(other.contrast, contrast)) &&
            (identical(other.level, level) ||
                const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(xCoord) ^
      const DeepCollectionEquality().hash(yCoord) ^
      const DeepCollectionEquality().hash(maxXCoord) ^
      const DeepCollectionEquality().hash(maxYCoord) ^
      const DeepCollectionEquality().hash(clearDisplay) ^
      const DeepCollectionEquality().hash(contrast) ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidAddressableTextDisplayCopyWith<
          _SpecificRidAddressableTextDisplay>
      get copyWith => __$SpecificRidAddressableTextDisplayCopyWithImpl<
          _SpecificRidAddressableTextDisplay>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidAddressableTextDisplayToJson(this);
  }
}

abstract class _SpecificRidAddressableTextDisplay
    implements SpecificRidAddressableTextDisplay {
  const factory _SpecificRidAddressableTextDisplay(
      {required int text,
      required int xCoord,
      required int yCoord,
      required int maxXCoord,
      required int maxYCoord,
      required int clearDisplay,
      required int contrast,
      required int level,
      required int appType}) = _$_SpecificRidAddressableTextDisplay;

  factory _SpecificRidAddressableTextDisplay.fromJson(
          Map<String, dynamic> json) =
      _$_SpecificRidAddressableTextDisplay.fromJson;

  @override
  int get text => throw _privateConstructorUsedError;
  @override
  int get xCoord => throw _privateConstructorUsedError;
  @override
  int get yCoord => throw _privateConstructorUsedError;
  @override
  int get maxXCoord => throw _privateConstructorUsedError;
  @override
  int get maxYCoord => throw _privateConstructorUsedError;
  @override
  int get clearDisplay => throw _privateConstructorUsedError;
  @override
  int get contrast => throw _privateConstructorUsedError;
  @override
  int get level => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidAddressableTextDisplayCopyWith<
          _SpecificRidAddressableTextDisplay>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificRidAIn _$SpecificRidAInFromJson(Map<String, dynamic> json) {
  return _SpecificRidAIn.fromJson(json);
}

/// @nodoc
class _$SpecificRidAInTearOff {
  const _$SpecificRidAInTearOff();

  _SpecificRidAIn call(
      {required int aInCurrValue,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int appType,
      required int sensorType}) {
    return _SpecificRidAIn(
      aInCurrValue: aInCurrValue,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      appType: appType,
      sensorType: sensorType,
    );
  }

  SpecificRidAIn fromJson(Map<String, Object> json) {
    return SpecificRidAIn.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidAIn = _$SpecificRidAInTearOff();

/// @nodoc
mixin _$SpecificRidAIn {
  int get aInCurrValue => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;
  int get sensorType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidAInCopyWith<SpecificRidAIn> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidAInCopyWith<$Res> {
  factory $SpecificRidAInCopyWith(
          SpecificRidAIn value, $Res Function(SpecificRidAIn) then) =
      _$SpecificRidAInCopyWithImpl<$Res>;
  $Res call(
      {int aInCurrValue,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int appType,
      int sensorType});
}

/// @nodoc
class _$SpecificRidAInCopyWithImpl<$Res>
    implements $SpecificRidAInCopyWith<$Res> {
  _$SpecificRidAInCopyWithImpl(this._value, this._then);

  final SpecificRidAIn _value;
  // ignore: unused_field
  final $Res Function(SpecificRidAIn) _then;

  @override
  $Res call({
    Object? aInCurrValue = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? appType = freezed,
    Object? sensorType = freezed,
  }) {
    return _then(_value.copyWith(
      aInCurrValue: aInCurrValue == freezed
          ? _value.aInCurrValue
          : aInCurrValue // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
      sensorType: sensorType == freezed
          ? _value.sensorType
          : sensorType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidAInCopyWith<$Res>
    implements $SpecificRidAInCopyWith<$Res> {
  factory _$SpecificRidAInCopyWith(
          _SpecificRidAIn value, $Res Function(_SpecificRidAIn) then) =
      __$SpecificRidAInCopyWithImpl<$Res>;
  @override
  $Res call(
      {int aInCurrValue,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int appType,
      int sensorType});
}

/// @nodoc
class __$SpecificRidAInCopyWithImpl<$Res>
    extends _$SpecificRidAInCopyWithImpl<$Res>
    implements _$SpecificRidAInCopyWith<$Res> {
  __$SpecificRidAInCopyWithImpl(
      _SpecificRidAIn _value, $Res Function(_SpecificRidAIn) _then)
      : super(_value, (v) => _then(v as _SpecificRidAIn));

  @override
  _SpecificRidAIn get _value => super._value as _SpecificRidAIn;

  @override
  $Res call({
    Object? aInCurrValue = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? appType = freezed,
    Object? sensorType = freezed,
  }) {
    return _then(_SpecificRidAIn(
      aInCurrValue: aInCurrValue == freezed
          ? _value.aInCurrValue
          : aInCurrValue // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
      sensorType: sensorType == freezed
          ? _value.sensorType
          : sensorType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidAIn implements _SpecificRidAIn {
  const _$_SpecificRidAIn(
      {required this.aInCurrValue,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues,
      required this.appType,
      required this.sensorType});

  factory _$_SpecificRidAIn.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidAInFromJson(json);

  @override
  final int aInCurrValue;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int appType;
  @override
  final int sensorType;

  @override
  String toString() {
    return 'SpecificRidAIn(aInCurrValue: $aInCurrValue, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, appType: $appType, sensorType: $sensorType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidAIn &&
            (identical(other.aInCurrValue, aInCurrValue) ||
                const DeepCollectionEquality()
                    .equals(other.aInCurrValue, aInCurrValue)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality()
                    .equals(other.appType, appType)) &&
            (identical(other.sensorType, sensorType) ||
                const DeepCollectionEquality()
                    .equals(other.sensorType, sensorType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(aInCurrValue) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(appType) ^
      const DeepCollectionEquality().hash(sensorType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidAInCopyWith<_SpecificRidAIn> get copyWith =>
      __$SpecificRidAInCopyWithImpl<_SpecificRidAIn>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidAInToJson(this);
  }
}

abstract class _SpecificRidAIn implements SpecificRidAIn {
  const factory _SpecificRidAIn(
      {required int aInCurrValue,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int appType,
      required int sensorType}) = _$_SpecificRidAIn;

  factory _SpecificRidAIn.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidAIn.fromJson;

  @override
  int get aInCurrValue => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  int get sensorType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidAInCopyWith<_SpecificRidAIn> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidAltitude _$SpecificRidAltitudeFromJson(Map<String, dynamic> json) {
  return _SpecificRidAltitude.fromJson(json);
}

/// @nodoc
class _$SpecificRidAltitudeTearOff {
  const _$SpecificRidAltitudeTearOff();

  _SpecificRidAltitude call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) {
    return _SpecificRidAltitude(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      calOffset: calOffset,
      appType: appType,
    );
  }

  SpecificRidAltitude fromJson(Map<String, Object> json) {
    return SpecificRidAltitude.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidAltitude = _$SpecificRidAltitudeTearOff();

/// @nodoc
mixin _$SpecificRidAltitude {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get calOffset => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidAltitudeCopyWith<SpecificRidAltitude> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidAltitudeCopyWith<$Res> {
  factory $SpecificRidAltitudeCopyWith(
          SpecificRidAltitude value, $Res Function(SpecificRidAltitude) then) =
      _$SpecificRidAltitudeCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class _$SpecificRidAltitudeCopyWithImpl<$Res>
    implements $SpecificRidAltitudeCopyWith<$Res> {
  _$SpecificRidAltitudeCopyWithImpl(this._value, this._then);

  final SpecificRidAltitude _value;
  // ignore: unused_field
  final $Res Function(SpecificRidAltitude) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidAltitudeCopyWith<$Res>
    implements $SpecificRidAltitudeCopyWith<$Res> {
  factory _$SpecificRidAltitudeCopyWith(_SpecificRidAltitude value,
          $Res Function(_SpecificRidAltitude) then) =
      __$SpecificRidAltitudeCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class __$SpecificRidAltitudeCopyWithImpl<$Res>
    extends _$SpecificRidAltitudeCopyWithImpl<$Res>
    implements _$SpecificRidAltitudeCopyWith<$Res> {
  __$SpecificRidAltitudeCopyWithImpl(
      _SpecificRidAltitude _value, $Res Function(_SpecificRidAltitude) _then)
      : super(_value, (v) => _then(v as _SpecificRidAltitude));

  @override
  _SpecificRidAltitude get _value => super._value as _SpecificRidAltitude;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidAltitude(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidAltitude implements _SpecificRidAltitude {
  const _$_SpecificRidAltitude(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues,
      required this.calOffset,
      required this.appType});

  factory _$_SpecificRidAltitude.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidAltitudeFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int calOffset;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidAltitude(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, calOffset: $calOffset, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidAltitude &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.calOffset, calOffset) ||
                const DeepCollectionEquality()
                    .equals(other.calOffset, calOffset)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(calOffset) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidAltitudeCopyWith<_SpecificRidAltitude> get copyWith =>
      __$SpecificRidAltitudeCopyWithImpl<_SpecificRidAltitude>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidAltitudeToJson(this);
  }
}

abstract class _SpecificRidAltitude implements SpecificRidAltitude {
  const factory _SpecificRidAltitude(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) = _$_SpecificRidAltitude;

  factory _SpecificRidAltitude.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidAltitude.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get calOffset => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidAltitudeCopyWith<_SpecificRidAltitude> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidAOut _$SpecificRidAOutFromJson(Map<String, dynamic> json) {
  return _SpecificRidAOut.fromJson(json);
}

/// @nodoc
class _$SpecificRidAOutTearOff {
  const _$SpecificRidAOutTearOff();

  _SpecificRidAOut call(
      {required int aOutCurrValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int appType}) {
    return _SpecificRidAOut(
      aOutCurrValue: aOutCurrValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      appType: appType,
    );
  }

  SpecificRidAOut fromJson(Map<String, Object> json) {
    return SpecificRidAOut.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidAOut = _$SpecificRidAOutTearOff();

/// @nodoc
mixin _$SpecificRidAOut {
  int get aOutCurrValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidAOutCopyWith<SpecificRidAOut> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidAOutCopyWith<$Res> {
  factory $SpecificRidAOutCopyWith(
          SpecificRidAOut value, $Res Function(SpecificRidAOut) then) =
      _$SpecificRidAOutCopyWithImpl<$Res>;
  $Res call(
      {int aOutCurrValue, int minRangeValue, int maxRangeValue, int appType});
}

/// @nodoc
class _$SpecificRidAOutCopyWithImpl<$Res>
    implements $SpecificRidAOutCopyWith<$Res> {
  _$SpecificRidAOutCopyWithImpl(this._value, this._then);

  final SpecificRidAOut _value;
  // ignore: unused_field
  final $Res Function(SpecificRidAOut) _then;

  @override
  $Res call({
    Object? aOutCurrValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      aOutCurrValue: aOutCurrValue == freezed
          ? _value.aOutCurrValue
          : aOutCurrValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidAOutCopyWith<$Res>
    implements $SpecificRidAOutCopyWith<$Res> {
  factory _$SpecificRidAOutCopyWith(
          _SpecificRidAOut value, $Res Function(_SpecificRidAOut) then) =
      __$SpecificRidAOutCopyWithImpl<$Res>;
  @override
  $Res call(
      {int aOutCurrValue, int minRangeValue, int maxRangeValue, int appType});
}

/// @nodoc
class __$SpecificRidAOutCopyWithImpl<$Res>
    extends _$SpecificRidAOutCopyWithImpl<$Res>
    implements _$SpecificRidAOutCopyWith<$Res> {
  __$SpecificRidAOutCopyWithImpl(
      _SpecificRidAOut _value, $Res Function(_SpecificRidAOut) _then)
      : super(_value, (v) => _then(v as _SpecificRidAOut));

  @override
  _SpecificRidAOut get _value => super._value as _SpecificRidAOut;

  @override
  $Res call({
    Object? aOutCurrValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidAOut(
      aOutCurrValue: aOutCurrValue == freezed
          ? _value.aOutCurrValue
          : aOutCurrValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidAOut implements _SpecificRidAOut {
  const _$_SpecificRidAOut(
      {required this.aOutCurrValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.appType});

  factory _$_SpecificRidAOut.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidAOutFromJson(json);

  @override
  final int aOutCurrValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidAOut(aOutCurrValue: $aOutCurrValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidAOut &&
            (identical(other.aOutCurrValue, aOutCurrValue) ||
                const DeepCollectionEquality()
                    .equals(other.aOutCurrValue, aOutCurrValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(aOutCurrValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidAOutCopyWith<_SpecificRidAOut> get copyWith =>
      __$SpecificRidAOutCopyWithImpl<_SpecificRidAOut>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidAOutToJson(this);
  }
}

abstract class _SpecificRidAOut implements SpecificRidAOut {
  const factory _SpecificRidAOut(
      {required int aOutCurrValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int appType}) = _$_SpecificRidAOut;

  factory _SpecificRidAOut.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidAOut.fromJson;

  @override
  int get aOutCurrValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidAOutCopyWith<_SpecificRidAOut> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidAccelerometer _$SpecificRidAccelerometerFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidAccelerometer.fromJson(json);
}

/// @nodoc
class _$SpecificRidAccelerometerTearOff {
  const _$SpecificRidAccelerometerTearOff();

  _SpecificRidAccelerometer call(
      {required int units,
      required int xValue,
      required int yValue,
      required int zValue,
      required int minRangeValue,
      required int maxRangeValue}) {
    return _SpecificRidAccelerometer(
      units: units,
      xValue: xValue,
      yValue: yValue,
      zValue: zValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
    );
  }

  SpecificRidAccelerometer fromJson(Map<String, Object> json) {
    return SpecificRidAccelerometer.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidAccelerometer = _$SpecificRidAccelerometerTearOff();

/// @nodoc
mixin _$SpecificRidAccelerometer {
  int get units => throw _privateConstructorUsedError;
  int get xValue => throw _privateConstructorUsedError;
  int get yValue => throw _privateConstructorUsedError;
  int get zValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidAccelerometerCopyWith<SpecificRidAccelerometer> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidAccelerometerCopyWith<$Res> {
  factory $SpecificRidAccelerometerCopyWith(SpecificRidAccelerometer value,
          $Res Function(SpecificRidAccelerometer) then) =
      _$SpecificRidAccelerometerCopyWithImpl<$Res>;
  $Res call(
      {int units,
      int xValue,
      int yValue,
      int zValue,
      int minRangeValue,
      int maxRangeValue});
}

/// @nodoc
class _$SpecificRidAccelerometerCopyWithImpl<$Res>
    implements $SpecificRidAccelerometerCopyWith<$Res> {
  _$SpecificRidAccelerometerCopyWithImpl(this._value, this._then);

  final SpecificRidAccelerometer _value;
  // ignore: unused_field
  final $Res Function(SpecificRidAccelerometer) _then;

  @override
  $Res call({
    Object? units = freezed,
    Object? xValue = freezed,
    Object? yValue = freezed,
    Object? zValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
  }) {
    return _then(_value.copyWith(
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      xValue: xValue == freezed
          ? _value.xValue
          : xValue // ignore: cast_nullable_to_non_nullable
              as int,
      yValue: yValue == freezed
          ? _value.yValue
          : yValue // ignore: cast_nullable_to_non_nullable
              as int,
      zValue: zValue == freezed
          ? _value.zValue
          : zValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidAccelerometerCopyWith<$Res>
    implements $SpecificRidAccelerometerCopyWith<$Res> {
  factory _$SpecificRidAccelerometerCopyWith(_SpecificRidAccelerometer value,
          $Res Function(_SpecificRidAccelerometer) then) =
      __$SpecificRidAccelerometerCopyWithImpl<$Res>;
  @override
  $Res call(
      {int units,
      int xValue,
      int yValue,
      int zValue,
      int minRangeValue,
      int maxRangeValue});
}

/// @nodoc
class __$SpecificRidAccelerometerCopyWithImpl<$Res>
    extends _$SpecificRidAccelerometerCopyWithImpl<$Res>
    implements _$SpecificRidAccelerometerCopyWith<$Res> {
  __$SpecificRidAccelerometerCopyWithImpl(_SpecificRidAccelerometer _value,
      $Res Function(_SpecificRidAccelerometer) _then)
      : super(_value, (v) => _then(v as _SpecificRidAccelerometer));

  @override
  _SpecificRidAccelerometer get _value =>
      super._value as _SpecificRidAccelerometer;

  @override
  $Res call({
    Object? units = freezed,
    Object? xValue = freezed,
    Object? yValue = freezed,
    Object? zValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
  }) {
    return _then(_SpecificRidAccelerometer(
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      xValue: xValue == freezed
          ? _value.xValue
          : xValue // ignore: cast_nullable_to_non_nullable
              as int,
      yValue: yValue == freezed
          ? _value.yValue
          : yValue // ignore: cast_nullable_to_non_nullable
              as int,
      zValue: zValue == freezed
          ? _value.zValue
          : zValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidAccelerometer implements _SpecificRidAccelerometer {
  const _$_SpecificRidAccelerometer(
      {required this.units,
      required this.xValue,
      required this.yValue,
      required this.zValue,
      required this.minRangeValue,
      required this.maxRangeValue});

  factory _$_SpecificRidAccelerometer.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidAccelerometerFromJson(json);

  @override
  final int units;
  @override
  final int xValue;
  @override
  final int yValue;
  @override
  final int zValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;

  @override
  String toString() {
    return 'SpecificRidAccelerometer(units: $units, xValue: $xValue, yValue: $yValue, zValue: $zValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidAccelerometer &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.xValue, xValue) ||
                const DeepCollectionEquality().equals(other.xValue, xValue)) &&
            (identical(other.yValue, yValue) ||
                const DeepCollectionEquality().equals(other.yValue, yValue)) &&
            (identical(other.zValue, zValue) ||
                const DeepCollectionEquality().equals(other.zValue, zValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(xValue) ^
      const DeepCollectionEquality().hash(yValue) ^
      const DeepCollectionEquality().hash(zValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidAccelerometerCopyWith<_SpecificRidAccelerometer> get copyWith =>
      __$SpecificRidAccelerometerCopyWithImpl<_SpecificRidAccelerometer>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidAccelerometerToJson(this);
  }
}

abstract class _SpecificRidAccelerometer implements SpecificRidAccelerometer {
  const factory _SpecificRidAccelerometer(
      {required int units,
      required int xValue,
      required int yValue,
      required int zValue,
      required int minRangeValue,
      required int maxRangeValue}) = _$_SpecificRidAccelerometer;

  factory _SpecificRidAccelerometer.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidAccelerometer.fromJson;

  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get xValue => throw _privateConstructorUsedError;
  @override
  int get yValue => throw _privateConstructorUsedError;
  @override
  int get zValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidAccelerometerCopyWith<_SpecificRidAccelerometer> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidAccessCtrl _$SpecificRidAccessCtrlFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidAccessCtrl.fromJson(json);
}

/// @nodoc
class _$SpecificRidAccessCtrlTearOff {
  const _$SpecificRidAccessCtrlTearOff();

  _SpecificRidAccessCtrl call(
      {required int objectId,
      required int objectInstanceId,
      @JsonKey(name: "ACL") required int acl,
      @JsonKey(name: "ACLOwner") required int aclOwner}) {
    return _SpecificRidAccessCtrl(
      objectId: objectId,
      objectInstanceId: objectInstanceId,
      acl: acl,
      aclOwner: aclOwner,
    );
  }

  SpecificRidAccessCtrl fromJson(Map<String, Object> json) {
    return SpecificRidAccessCtrl.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidAccessCtrl = _$SpecificRidAccessCtrlTearOff();

/// @nodoc
mixin _$SpecificRidAccessCtrl {
  int get objectId => throw _privateConstructorUsedError;
  int get objectInstanceId => throw _privateConstructorUsedError;
  @JsonKey(name: "ACL")
  int get acl => throw _privateConstructorUsedError;
  @JsonKey(name: "ACLOwner")
  int get aclOwner => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidAccessCtrlCopyWith<SpecificRidAccessCtrl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidAccessCtrlCopyWith<$Res> {
  factory $SpecificRidAccessCtrlCopyWith(SpecificRidAccessCtrl value,
          $Res Function(SpecificRidAccessCtrl) then) =
      _$SpecificRidAccessCtrlCopyWithImpl<$Res>;
  $Res call(
      {int objectId,
      int objectInstanceId,
      @JsonKey(name: "ACL") int acl,
      @JsonKey(name: "ACLOwner") int aclOwner});
}

/// @nodoc
class _$SpecificRidAccessCtrlCopyWithImpl<$Res>
    implements $SpecificRidAccessCtrlCopyWith<$Res> {
  _$SpecificRidAccessCtrlCopyWithImpl(this._value, this._then);

  final SpecificRidAccessCtrl _value;
  // ignore: unused_field
  final $Res Function(SpecificRidAccessCtrl) _then;

  @override
  $Res call({
    Object? objectId = freezed,
    Object? objectInstanceId = freezed,
    Object? acl = freezed,
    Object? aclOwner = freezed,
  }) {
    return _then(_value.copyWith(
      objectId: objectId == freezed
          ? _value.objectId
          : objectId // ignore: cast_nullable_to_non_nullable
              as int,
      objectInstanceId: objectInstanceId == freezed
          ? _value.objectInstanceId
          : objectInstanceId // ignore: cast_nullable_to_non_nullable
              as int,
      acl: acl == freezed
          ? _value.acl
          : acl // ignore: cast_nullable_to_non_nullable
              as int,
      aclOwner: aclOwner == freezed
          ? _value.aclOwner
          : aclOwner // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidAccessCtrlCopyWith<$Res>
    implements $SpecificRidAccessCtrlCopyWith<$Res> {
  factory _$SpecificRidAccessCtrlCopyWith(_SpecificRidAccessCtrl value,
          $Res Function(_SpecificRidAccessCtrl) then) =
      __$SpecificRidAccessCtrlCopyWithImpl<$Res>;
  @override
  $Res call(
      {int objectId,
      int objectInstanceId,
      @JsonKey(name: "ACL") int acl,
      @JsonKey(name: "ACLOwner") int aclOwner});
}

/// @nodoc
class __$SpecificRidAccessCtrlCopyWithImpl<$Res>
    extends _$SpecificRidAccessCtrlCopyWithImpl<$Res>
    implements _$SpecificRidAccessCtrlCopyWith<$Res> {
  __$SpecificRidAccessCtrlCopyWithImpl(_SpecificRidAccessCtrl _value,
      $Res Function(_SpecificRidAccessCtrl) _then)
      : super(_value, (v) => _then(v as _SpecificRidAccessCtrl));

  @override
  _SpecificRidAccessCtrl get _value => super._value as _SpecificRidAccessCtrl;

  @override
  $Res call({
    Object? objectId = freezed,
    Object? objectInstanceId = freezed,
    Object? acl = freezed,
    Object? aclOwner = freezed,
  }) {
    return _then(_SpecificRidAccessCtrl(
      objectId: objectId == freezed
          ? _value.objectId
          : objectId // ignore: cast_nullable_to_non_nullable
              as int,
      objectInstanceId: objectInstanceId == freezed
          ? _value.objectInstanceId
          : objectInstanceId // ignore: cast_nullable_to_non_nullable
              as int,
      acl: acl == freezed
          ? _value.acl
          : acl // ignore: cast_nullable_to_non_nullable
              as int,
      aclOwner: aclOwner == freezed
          ? _value.aclOwner
          : aclOwner // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidAccessCtrl implements _SpecificRidAccessCtrl {
  const _$_SpecificRidAccessCtrl(
      {required this.objectId,
      required this.objectInstanceId,
      @JsonKey(name: "ACL") required this.acl,
      @JsonKey(name: "ACLOwner") required this.aclOwner});

  factory _$_SpecificRidAccessCtrl.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidAccessCtrlFromJson(json);

  @override
  final int objectId;
  @override
  final int objectInstanceId;
  @override
  @JsonKey(name: "ACL")
  final int acl;
  @override
  @JsonKey(name: "ACLOwner")
  final int aclOwner;

  @override
  String toString() {
    return 'SpecificRidAccessCtrl(objectId: $objectId, objectInstanceId: $objectInstanceId, acl: $acl, aclOwner: $aclOwner)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidAccessCtrl &&
            (identical(other.objectId, objectId) ||
                const DeepCollectionEquality()
                    .equals(other.objectId, objectId)) &&
            (identical(other.objectInstanceId, objectInstanceId) ||
                const DeepCollectionEquality()
                    .equals(other.objectInstanceId, objectInstanceId)) &&
            (identical(other.acl, acl) ||
                const DeepCollectionEquality().equals(other.acl, acl)) &&
            (identical(other.aclOwner, aclOwner) ||
                const DeepCollectionEquality()
                    .equals(other.aclOwner, aclOwner)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(objectId) ^
      const DeepCollectionEquality().hash(objectInstanceId) ^
      const DeepCollectionEquality().hash(acl) ^
      const DeepCollectionEquality().hash(aclOwner);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidAccessCtrlCopyWith<_SpecificRidAccessCtrl> get copyWith =>
      __$SpecificRidAccessCtrlCopyWithImpl<_SpecificRidAccessCtrl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidAccessCtrlToJson(this);
  }
}

abstract class _SpecificRidAccessCtrl implements SpecificRidAccessCtrl {
  const factory _SpecificRidAccessCtrl(
          {required int objectId,
          required int objectInstanceId,
          @JsonKey(name: "ACL") required int acl,
          @JsonKey(name: "ACLOwner") required int aclOwner}) =
      _$_SpecificRidAccessCtrl;

  factory _SpecificRidAccessCtrl.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidAccessCtrl.fromJson;

  @override
  int get objectId => throw _privateConstructorUsedError;
  @override
  int get objectInstanceId => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "ACL")
  int get acl => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "ACLOwner")
  int get aclOwner => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidAccessCtrlCopyWith<_SpecificRidAccessCtrl> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidActuation _$SpecificRidActuationFromJson(Map<String, dynamic> json) {
  return _SpecificRidActuation.fromJson(json);
}

/// @nodoc
class _$SpecificRidActuationTearOff {
  const _$SpecificRidActuationTearOff();

  _SpecificRidActuation call(
      {required int onOff,
      required int dimmer,
      required int onTime,
      required int mStateOut,
      required int appType}) {
    return _SpecificRidActuation(
      onOff: onOff,
      dimmer: dimmer,
      onTime: onTime,
      mStateOut: mStateOut,
      appType: appType,
    );
  }

  SpecificRidActuation fromJson(Map<String, Object> json) {
    return SpecificRidActuation.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidActuation = _$SpecificRidActuationTearOff();

/// @nodoc
mixin _$SpecificRidActuation {
  int get onOff => throw _privateConstructorUsedError;
  int get dimmer => throw _privateConstructorUsedError;
  int get onTime => throw _privateConstructorUsedError;
  int get mStateOut => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidActuationCopyWith<SpecificRidActuation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidActuationCopyWith<$Res> {
  factory $SpecificRidActuationCopyWith(SpecificRidActuation value,
          $Res Function(SpecificRidActuation) then) =
      _$SpecificRidActuationCopyWithImpl<$Res>;
  $Res call({int onOff, int dimmer, int onTime, int mStateOut, int appType});
}

/// @nodoc
class _$SpecificRidActuationCopyWithImpl<$Res>
    implements $SpecificRidActuationCopyWith<$Res> {
  _$SpecificRidActuationCopyWithImpl(this._value, this._then);

  final SpecificRidActuation _value;
  // ignore: unused_field
  final $Res Function(SpecificRidActuation) _then;

  @override
  $Res call({
    Object? onOff = freezed,
    Object? dimmer = freezed,
    Object? onTime = freezed,
    Object? mStateOut = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      onOff: onOff == freezed
          ? _value.onOff
          : onOff // ignore: cast_nullable_to_non_nullable
              as int,
      dimmer: dimmer == freezed
          ? _value.dimmer
          : dimmer // ignore: cast_nullable_to_non_nullable
              as int,
      onTime: onTime == freezed
          ? _value.onTime
          : onTime // ignore: cast_nullable_to_non_nullable
              as int,
      mStateOut: mStateOut == freezed
          ? _value.mStateOut
          : mStateOut // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidActuationCopyWith<$Res>
    implements $SpecificRidActuationCopyWith<$Res> {
  factory _$SpecificRidActuationCopyWith(_SpecificRidActuation value,
          $Res Function(_SpecificRidActuation) then) =
      __$SpecificRidActuationCopyWithImpl<$Res>;
  @override
  $Res call({int onOff, int dimmer, int onTime, int mStateOut, int appType});
}

/// @nodoc
class __$SpecificRidActuationCopyWithImpl<$Res>
    extends _$SpecificRidActuationCopyWithImpl<$Res>
    implements _$SpecificRidActuationCopyWith<$Res> {
  __$SpecificRidActuationCopyWithImpl(
      _SpecificRidActuation _value, $Res Function(_SpecificRidActuation) _then)
      : super(_value, (v) => _then(v as _SpecificRidActuation));

  @override
  _SpecificRidActuation get _value => super._value as _SpecificRidActuation;

  @override
  $Res call({
    Object? onOff = freezed,
    Object? dimmer = freezed,
    Object? onTime = freezed,
    Object? mStateOut = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidActuation(
      onOff: onOff == freezed
          ? _value.onOff
          : onOff // ignore: cast_nullable_to_non_nullable
              as int,
      dimmer: dimmer == freezed
          ? _value.dimmer
          : dimmer // ignore: cast_nullable_to_non_nullable
              as int,
      onTime: onTime == freezed
          ? _value.onTime
          : onTime // ignore: cast_nullable_to_non_nullable
              as int,
      mStateOut: mStateOut == freezed
          ? _value.mStateOut
          : mStateOut // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidActuation implements _SpecificRidActuation {
  const _$_SpecificRidActuation(
      {required this.onOff,
      required this.dimmer,
      required this.onTime,
      required this.mStateOut,
      required this.appType});

  factory _$_SpecificRidActuation.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidActuationFromJson(json);

  @override
  final int onOff;
  @override
  final int dimmer;
  @override
  final int onTime;
  @override
  final int mStateOut;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidActuation(onOff: $onOff, dimmer: $dimmer, onTime: $onTime, mStateOut: $mStateOut, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidActuation &&
            (identical(other.onOff, onOff) ||
                const DeepCollectionEquality().equals(other.onOff, onOff)) &&
            (identical(other.dimmer, dimmer) ||
                const DeepCollectionEquality().equals(other.dimmer, dimmer)) &&
            (identical(other.onTime, onTime) ||
                const DeepCollectionEquality().equals(other.onTime, onTime)) &&
            (identical(other.mStateOut, mStateOut) ||
                const DeepCollectionEquality()
                    .equals(other.mStateOut, mStateOut)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(onOff) ^
      const DeepCollectionEquality().hash(dimmer) ^
      const DeepCollectionEquality().hash(onTime) ^
      const DeepCollectionEquality().hash(mStateOut) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidActuationCopyWith<_SpecificRidActuation> get copyWith =>
      __$SpecificRidActuationCopyWithImpl<_SpecificRidActuation>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidActuationToJson(this);
  }
}

abstract class _SpecificRidActuation implements SpecificRidActuation {
  const factory _SpecificRidActuation(
      {required int onOff,
      required int dimmer,
      required int onTime,
      required int mStateOut,
      required int appType}) = _$_SpecificRidActuation;

  factory _SpecificRidActuation.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidActuation.fromJson;

  @override
  int get onOff => throw _privateConstructorUsedError;
  @override
  int get dimmer => throw _privateConstructorUsedError;
  @override
  int get onTime => throw _privateConstructorUsedError;
  @override
  int get mStateOut => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidActuationCopyWith<_SpecificRidActuation> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidAudioClip _$SpecificRidAudioClipFromJson(Map<String, dynamic> json) {
  return _SpecificRidAudioClip.fromJson(json);
}

/// @nodoc
class _$SpecificRidAudioClipTearOff {
  const _$SpecificRidAudioClipTearOff();

  _SpecificRidAudioClip call(
      {required int clip,
      required int trigger,
      required int level,
      required int soundDuration,
      required int appType}) {
    return _SpecificRidAudioClip(
      clip: clip,
      trigger: trigger,
      level: level,
      soundDuration: soundDuration,
      appType: appType,
    );
  }

  SpecificRidAudioClip fromJson(Map<String, Object> json) {
    return SpecificRidAudioClip.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidAudioClip = _$SpecificRidAudioClipTearOff();

/// @nodoc
mixin _$SpecificRidAudioClip {
  int get clip => throw _privateConstructorUsedError;
  int get trigger => throw _privateConstructorUsedError;
  int get level => throw _privateConstructorUsedError;
  int get soundDuration => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidAudioClipCopyWith<SpecificRidAudioClip> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidAudioClipCopyWith<$Res> {
  factory $SpecificRidAudioClipCopyWith(SpecificRidAudioClip value,
          $Res Function(SpecificRidAudioClip) then) =
      _$SpecificRidAudioClipCopyWithImpl<$Res>;
  $Res call({int clip, int trigger, int level, int soundDuration, int appType});
}

/// @nodoc
class _$SpecificRidAudioClipCopyWithImpl<$Res>
    implements $SpecificRidAudioClipCopyWith<$Res> {
  _$SpecificRidAudioClipCopyWithImpl(this._value, this._then);

  final SpecificRidAudioClip _value;
  // ignore: unused_field
  final $Res Function(SpecificRidAudioClip) _then;

  @override
  $Res call({
    Object? clip = freezed,
    Object? trigger = freezed,
    Object? level = freezed,
    Object? soundDuration = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      clip: clip == freezed
          ? _value.clip
          : clip // ignore: cast_nullable_to_non_nullable
              as int,
      trigger: trigger == freezed
          ? _value.trigger
          : trigger // ignore: cast_nullable_to_non_nullable
              as int,
      level: level == freezed
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as int,
      soundDuration: soundDuration == freezed
          ? _value.soundDuration
          : soundDuration // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidAudioClipCopyWith<$Res>
    implements $SpecificRidAudioClipCopyWith<$Res> {
  factory _$SpecificRidAudioClipCopyWith(_SpecificRidAudioClip value,
          $Res Function(_SpecificRidAudioClip) then) =
      __$SpecificRidAudioClipCopyWithImpl<$Res>;
  @override
  $Res call({int clip, int trigger, int level, int soundDuration, int appType});
}

/// @nodoc
class __$SpecificRidAudioClipCopyWithImpl<$Res>
    extends _$SpecificRidAudioClipCopyWithImpl<$Res>
    implements _$SpecificRidAudioClipCopyWith<$Res> {
  __$SpecificRidAudioClipCopyWithImpl(
      _SpecificRidAudioClip _value, $Res Function(_SpecificRidAudioClip) _then)
      : super(_value, (v) => _then(v as _SpecificRidAudioClip));

  @override
  _SpecificRidAudioClip get _value => super._value as _SpecificRidAudioClip;

  @override
  $Res call({
    Object? clip = freezed,
    Object? trigger = freezed,
    Object? level = freezed,
    Object? soundDuration = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidAudioClip(
      clip: clip == freezed
          ? _value.clip
          : clip // ignore: cast_nullable_to_non_nullable
              as int,
      trigger: trigger == freezed
          ? _value.trigger
          : trigger // ignore: cast_nullable_to_non_nullable
              as int,
      level: level == freezed
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as int,
      soundDuration: soundDuration == freezed
          ? _value.soundDuration
          : soundDuration // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidAudioClip implements _SpecificRidAudioClip {
  const _$_SpecificRidAudioClip(
      {required this.clip,
      required this.trigger,
      required this.level,
      required this.soundDuration,
      required this.appType});

  factory _$_SpecificRidAudioClip.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidAudioClipFromJson(json);

  @override
  final int clip;
  @override
  final int trigger;
  @override
  final int level;
  @override
  final int soundDuration;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidAudioClip(clip: $clip, trigger: $trigger, level: $level, soundDuration: $soundDuration, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidAudioClip &&
            (identical(other.clip, clip) ||
                const DeepCollectionEquality().equals(other.clip, clip)) &&
            (identical(other.trigger, trigger) ||
                const DeepCollectionEquality()
                    .equals(other.trigger, trigger)) &&
            (identical(other.level, level) ||
                const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.soundDuration, soundDuration) ||
                const DeepCollectionEquality()
                    .equals(other.soundDuration, soundDuration)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(clip) ^
      const DeepCollectionEquality().hash(trigger) ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(soundDuration) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidAudioClipCopyWith<_SpecificRidAudioClip> get copyWith =>
      __$SpecificRidAudioClipCopyWithImpl<_SpecificRidAudioClip>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidAudioClipToJson(this);
  }
}

abstract class _SpecificRidAudioClip implements SpecificRidAudioClip {
  const factory _SpecificRidAudioClip(
      {required int clip,
      required int trigger,
      required int level,
      required int soundDuration,
      required int appType}) = _$_SpecificRidAudioClip;

  factory _SpecificRidAudioClip.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidAudioClip.fromJson;

  @override
  int get clip => throw _privateConstructorUsedError;
  @override
  int get trigger => throw _privateConstructorUsedError;
  @override
  int get level => throw _privateConstructorUsedError;
  @override
  int get soundDuration => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidAudioClipCopyWith<_SpecificRidAudioClip> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidBarometer _$SpecificRidBarometerFromJson(Map<String, dynamic> json) {
  return _SpecificRidBarometer.fromJson(json);
}

/// @nodoc
class _$SpecificRidBarometerTearOff {
  const _$SpecificRidBarometerTearOff();

  _SpecificRidBarometer call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues}) {
    return _SpecificRidBarometer(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
    );
  }

  SpecificRidBarometer fromJson(Map<String, Object> json) {
    return SpecificRidBarometer.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidBarometer = _$SpecificRidBarometerTearOff();

/// @nodoc
mixin _$SpecificRidBarometer {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidBarometerCopyWith<SpecificRidBarometer> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidBarometerCopyWith<$Res> {
  factory $SpecificRidBarometerCopyWith(SpecificRidBarometer value,
          $Res Function(SpecificRidBarometer) then) =
      _$SpecificRidBarometerCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues});
}

/// @nodoc
class _$SpecificRidBarometerCopyWithImpl<$Res>
    implements $SpecificRidBarometerCopyWith<$Res> {
  _$SpecificRidBarometerCopyWithImpl(this._value, this._then);

  final SpecificRidBarometer _value;
  // ignore: unused_field
  final $Res Function(SpecificRidBarometer) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidBarometerCopyWith<$Res>
    implements $SpecificRidBarometerCopyWith<$Res> {
  factory _$SpecificRidBarometerCopyWith(_SpecificRidBarometer value,
          $Res Function(_SpecificRidBarometer) then) =
      __$SpecificRidBarometerCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues});
}

/// @nodoc
class __$SpecificRidBarometerCopyWithImpl<$Res>
    extends _$SpecificRidBarometerCopyWithImpl<$Res>
    implements _$SpecificRidBarometerCopyWith<$Res> {
  __$SpecificRidBarometerCopyWithImpl(
      _SpecificRidBarometer _value, $Res Function(_SpecificRidBarometer) _then)
      : super(_value, (v) => _then(v as _SpecificRidBarometer));

  @override
  _SpecificRidBarometer get _value => super._value as _SpecificRidBarometer;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
  }) {
    return _then(_SpecificRidBarometer(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidBarometer implements _SpecificRidBarometer {
  const _$_SpecificRidBarometer(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues});

  factory _$_SpecificRidBarometer.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidBarometerFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;

  @override
  String toString() {
    return 'SpecificRidBarometer(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidBarometer &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality()
                    .equals(other.resetMinMaxMeaValues, resetMinMaxMeaValues)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidBarometerCopyWith<_SpecificRidBarometer> get copyWith =>
      __$SpecificRidBarometerCopyWithImpl<_SpecificRidBarometer>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidBarometerToJson(this);
  }
}

abstract class _SpecificRidBarometer implements SpecificRidBarometer {
  const factory _SpecificRidBarometer(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues}) = _$_SpecificRidBarometer;

  factory _SpecificRidBarometer.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidBarometer.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidBarometerCopyWith<_SpecificRidBarometer> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidBuzzer _$SpecificRidBuzzerFromJson(Map<String, dynamic> json) {
  return _SpecificRidBuzzer.fromJson(json);
}

/// @nodoc
class _$SpecificRidBuzzerTearOff {
  const _$SpecificRidBuzzerTearOff();

  _SpecificRidBuzzer call(
      {required int onOff,
      required int level,
      required int timeDuration,
      required int minOffTime,
      required int appType}) {
    return _SpecificRidBuzzer(
      onOff: onOff,
      level: level,
      timeDuration: timeDuration,
      minOffTime: minOffTime,
      appType: appType,
    );
  }

  SpecificRidBuzzer fromJson(Map<String, Object> json) {
    return SpecificRidBuzzer.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidBuzzer = _$SpecificRidBuzzerTearOff();

/// @nodoc
mixin _$SpecificRidBuzzer {
  int get onOff => throw _privateConstructorUsedError;
  int get level => throw _privateConstructorUsedError;
  int get timeDuration => throw _privateConstructorUsedError;
  int get minOffTime => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidBuzzerCopyWith<SpecificRidBuzzer> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidBuzzerCopyWith<$Res> {
  factory $SpecificRidBuzzerCopyWith(
          SpecificRidBuzzer value, $Res Function(SpecificRidBuzzer) then) =
      _$SpecificRidBuzzerCopyWithImpl<$Res>;
  $Res call(
      {int onOff, int level, int timeDuration, int minOffTime, int appType});
}

/// @nodoc
class _$SpecificRidBuzzerCopyWithImpl<$Res>
    implements $SpecificRidBuzzerCopyWith<$Res> {
  _$SpecificRidBuzzerCopyWithImpl(this._value, this._then);

  final SpecificRidBuzzer _value;
  // ignore: unused_field
  final $Res Function(SpecificRidBuzzer) _then;

  @override
  $Res call({
    Object? onOff = freezed,
    Object? level = freezed,
    Object? timeDuration = freezed,
    Object? minOffTime = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      onOff: onOff == freezed
          ? _value.onOff
          : onOff // ignore: cast_nullable_to_non_nullable
              as int,
      level: level == freezed
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as int,
      timeDuration: timeDuration == freezed
          ? _value.timeDuration
          : timeDuration // ignore: cast_nullable_to_non_nullable
              as int,
      minOffTime: minOffTime == freezed
          ? _value.minOffTime
          : minOffTime // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidBuzzerCopyWith<$Res>
    implements $SpecificRidBuzzerCopyWith<$Res> {
  factory _$SpecificRidBuzzerCopyWith(
          _SpecificRidBuzzer value, $Res Function(_SpecificRidBuzzer) then) =
      __$SpecificRidBuzzerCopyWithImpl<$Res>;
  @override
  $Res call(
      {int onOff, int level, int timeDuration, int minOffTime, int appType});
}

/// @nodoc
class __$SpecificRidBuzzerCopyWithImpl<$Res>
    extends _$SpecificRidBuzzerCopyWithImpl<$Res>
    implements _$SpecificRidBuzzerCopyWith<$Res> {
  __$SpecificRidBuzzerCopyWithImpl(
      _SpecificRidBuzzer _value, $Res Function(_SpecificRidBuzzer) _then)
      : super(_value, (v) => _then(v as _SpecificRidBuzzer));

  @override
  _SpecificRidBuzzer get _value => super._value as _SpecificRidBuzzer;

  @override
  $Res call({
    Object? onOff = freezed,
    Object? level = freezed,
    Object? timeDuration = freezed,
    Object? minOffTime = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidBuzzer(
      onOff: onOff == freezed
          ? _value.onOff
          : onOff // ignore: cast_nullable_to_non_nullable
              as int,
      level: level == freezed
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as int,
      timeDuration: timeDuration == freezed
          ? _value.timeDuration
          : timeDuration // ignore: cast_nullable_to_non_nullable
              as int,
      minOffTime: minOffTime == freezed
          ? _value.minOffTime
          : minOffTime // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidBuzzer implements _SpecificRidBuzzer {
  const _$_SpecificRidBuzzer(
      {required this.onOff,
      required this.level,
      required this.timeDuration,
      required this.minOffTime,
      required this.appType});

  factory _$_SpecificRidBuzzer.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidBuzzerFromJson(json);

  @override
  final int onOff;
  @override
  final int level;
  @override
  final int timeDuration;
  @override
  final int minOffTime;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidBuzzer(onOff: $onOff, level: $level, timeDuration: $timeDuration, minOffTime: $minOffTime, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidBuzzer &&
            (identical(other.onOff, onOff) ||
                const DeepCollectionEquality().equals(other.onOff, onOff)) &&
            (identical(other.level, level) ||
                const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.timeDuration, timeDuration) ||
                const DeepCollectionEquality()
                    .equals(other.timeDuration, timeDuration)) &&
            (identical(other.minOffTime, minOffTime) ||
                const DeepCollectionEquality()
                    .equals(other.minOffTime, minOffTime)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(onOff) ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(timeDuration) ^
      const DeepCollectionEquality().hash(minOffTime) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidBuzzerCopyWith<_SpecificRidBuzzer> get copyWith =>
      __$SpecificRidBuzzerCopyWithImpl<_SpecificRidBuzzer>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidBuzzerToJson(this);
  }
}

abstract class _SpecificRidBuzzer implements SpecificRidBuzzer {
  const factory _SpecificRidBuzzer(
      {required int onOff,
      required int level,
      required int timeDuration,
      required int minOffTime,
      required int appType}) = _$_SpecificRidBuzzer;

  factory _SpecificRidBuzzer.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidBuzzer.fromJson;

  @override
  int get onOff => throw _privateConstructorUsedError;
  @override
  int get level => throw _privateConstructorUsedError;
  @override
  int get timeDuration => throw _privateConstructorUsedError;
  @override
  int get minOffTime => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidBuzzerCopyWith<_SpecificRidBuzzer> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidSetPoint _$SpecificRidSetPointFromJson(Map<String, dynamic> json) {
  return _SpecificRidSetPoint.fromJson(json);
}

/// @nodoc
class _$SpecificRidSetPointTearOff {
  const _$SpecificRidSetPointTearOff();

  _SpecificRidSetPoint call(
      {required int colour,
      required int units,
      required int appType,
      required int setPointValue}) {
    return _SpecificRidSetPoint(
      colour: colour,
      units: units,
      appType: appType,
      setPointValue: setPointValue,
    );
  }

  SpecificRidSetPoint fromJson(Map<String, Object> json) {
    return SpecificRidSetPoint.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidSetPoint = _$SpecificRidSetPointTearOff();

/// @nodoc
mixin _$SpecificRidSetPoint {
  int get colour => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;
  int get setPointValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidSetPointCopyWith<SpecificRidSetPoint> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidSetPointCopyWith<$Res> {
  factory $SpecificRidSetPointCopyWith(
          SpecificRidSetPoint value, $Res Function(SpecificRidSetPoint) then) =
      _$SpecificRidSetPointCopyWithImpl<$Res>;
  $Res call({int colour, int units, int appType, int setPointValue});
}

/// @nodoc
class _$SpecificRidSetPointCopyWithImpl<$Res>
    implements $SpecificRidSetPointCopyWith<$Res> {
  _$SpecificRidSetPointCopyWithImpl(this._value, this._then);

  final SpecificRidSetPoint _value;
  // ignore: unused_field
  final $Res Function(SpecificRidSetPoint) _then;

  @override
  $Res call({
    Object? colour = freezed,
    Object? units = freezed,
    Object? appType = freezed,
    Object? setPointValue = freezed,
  }) {
    return _then(_value.copyWith(
      colour: colour == freezed
          ? _value.colour
          : colour // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
      setPointValue: setPointValue == freezed
          ? _value.setPointValue
          : setPointValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidSetPointCopyWith<$Res>
    implements $SpecificRidSetPointCopyWith<$Res> {
  factory _$SpecificRidSetPointCopyWith(_SpecificRidSetPoint value,
          $Res Function(_SpecificRidSetPoint) then) =
      __$SpecificRidSetPointCopyWithImpl<$Res>;
  @override
  $Res call({int colour, int units, int appType, int setPointValue});
}

/// @nodoc
class __$SpecificRidSetPointCopyWithImpl<$Res>
    extends _$SpecificRidSetPointCopyWithImpl<$Res>
    implements _$SpecificRidSetPointCopyWith<$Res> {
  __$SpecificRidSetPointCopyWithImpl(
      _SpecificRidSetPoint _value, $Res Function(_SpecificRidSetPoint) _then)
      : super(_value, (v) => _then(v as _SpecificRidSetPoint));

  @override
  _SpecificRidSetPoint get _value => super._value as _SpecificRidSetPoint;

  @override
  $Res call({
    Object? colour = freezed,
    Object? units = freezed,
    Object? appType = freezed,
    Object? setPointValue = freezed,
  }) {
    return _then(_SpecificRidSetPoint(
      colour: colour == freezed
          ? _value.colour
          : colour // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
      setPointValue: setPointValue == freezed
          ? _value.setPointValue
          : setPointValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidSetPoint implements _SpecificRidSetPoint {
  const _$_SpecificRidSetPoint(
      {required this.colour,
      required this.units,
      required this.appType,
      required this.setPointValue});

  factory _$_SpecificRidSetPoint.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidSetPointFromJson(json);

  @override
  final int colour;
  @override
  final int units;
  @override
  final int appType;
  @override
  final int setPointValue;

  @override
  String toString() {
    return 'SpecificRidSetPoint(colour: $colour, units: $units, appType: $appType, setPointValue: $setPointValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidSetPoint &&
            (identical(other.colour, colour) ||
                const DeepCollectionEquality().equals(other.colour, colour)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality()
                    .equals(other.appType, appType)) &&
            (identical(other.setPointValue, setPointValue) ||
                const DeepCollectionEquality()
                    .equals(other.setPointValue, setPointValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(colour) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(appType) ^
      const DeepCollectionEquality().hash(setPointValue);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidSetPointCopyWith<_SpecificRidSetPoint> get copyWith =>
      __$SpecificRidSetPointCopyWithImpl<_SpecificRidSetPoint>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidSetPointToJson(this);
  }
}

abstract class _SpecificRidSetPoint implements SpecificRidSetPoint {
  const factory _SpecificRidSetPoint(
      {required int colour,
      required int units,
      required int appType,
      required int setPointValue}) = _$_SpecificRidSetPoint;

  factory _SpecificRidSetPoint.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidSetPoint.fromJson;

  @override
  int get colour => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  int get setPointValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidSetPointCopyWith<_SpecificRidSetPoint> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidColour _$SpecificRidColourFromJson(Map<String, dynamic> json) {
  return _SpecificRidColour.fromJson(json);
}

/// @nodoc
class _$SpecificRidColourTearOff {
  const _$SpecificRidColourTearOff();

  _SpecificRidColour call(
      {required int colour, required int units, required int appType}) {
    return _SpecificRidColour(
      colour: colour,
      units: units,
      appType: appType,
    );
  }

  SpecificRidColour fromJson(Map<String, Object> json) {
    return SpecificRidColour.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidColour = _$SpecificRidColourTearOff();

/// @nodoc
mixin _$SpecificRidColour {
  int get colour => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidColourCopyWith<SpecificRidColour> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidColourCopyWith<$Res> {
  factory $SpecificRidColourCopyWith(
          SpecificRidColour value, $Res Function(SpecificRidColour) then) =
      _$SpecificRidColourCopyWithImpl<$Res>;
  $Res call({int colour, int units, int appType});
}

/// @nodoc
class _$SpecificRidColourCopyWithImpl<$Res>
    implements $SpecificRidColourCopyWith<$Res> {
  _$SpecificRidColourCopyWithImpl(this._value, this._then);

  final SpecificRidColour _value;
  // ignore: unused_field
  final $Res Function(SpecificRidColour) _then;

  @override
  $Res call({
    Object? colour = freezed,
    Object? units = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      colour: colour == freezed
          ? _value.colour
          : colour // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidColourCopyWith<$Res>
    implements $SpecificRidColourCopyWith<$Res> {
  factory _$SpecificRidColourCopyWith(
          _SpecificRidColour value, $Res Function(_SpecificRidColour) then) =
      __$SpecificRidColourCopyWithImpl<$Res>;
  @override
  $Res call({int colour, int units, int appType});
}

/// @nodoc
class __$SpecificRidColourCopyWithImpl<$Res>
    extends _$SpecificRidColourCopyWithImpl<$Res>
    implements _$SpecificRidColourCopyWith<$Res> {
  __$SpecificRidColourCopyWithImpl(
      _SpecificRidColour _value, $Res Function(_SpecificRidColour) _then)
      : super(_value, (v) => _then(v as _SpecificRidColour));

  @override
  _SpecificRidColour get _value => super._value as _SpecificRidColour;

  @override
  $Res call({
    Object? colour = freezed,
    Object? units = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidColour(
      colour: colour == freezed
          ? _value.colour
          : colour // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidColour implements _SpecificRidColour {
  const _$_SpecificRidColour(
      {required this.colour, required this.units, required this.appType});

  factory _$_SpecificRidColour.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidColourFromJson(json);

  @override
  final int colour;
  @override
  final int units;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidColour(colour: $colour, units: $units, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidColour &&
            (identical(other.colour, colour) ||
                const DeepCollectionEquality().equals(other.colour, colour)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(colour) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidColourCopyWith<_SpecificRidColour> get copyWith =>
      __$SpecificRidColourCopyWithImpl<_SpecificRidColour>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidColourToJson(this);
  }
}

abstract class _SpecificRidColour implements SpecificRidColour {
  const factory _SpecificRidColour(
      {required int colour,
      required int units,
      required int appType}) = _$_SpecificRidColour;

  factory _SpecificRidColour.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidColour.fromJson;

  @override
  int get colour => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidColourCopyWith<_SpecificRidColour> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidConcentration _$SpecificRidConcentrationFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidConcentration.fromJson(json);
}

/// @nodoc
class _$SpecificRidConcentrationTearOff {
  const _$SpecificRidConcentrationTearOff();

  _SpecificRidConcentration call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) {
    return _SpecificRidConcentration(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      calOffset: calOffset,
      appType: appType,
    );
  }

  SpecificRidConcentration fromJson(Map<String, Object> json) {
    return SpecificRidConcentration.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidConcentration = _$SpecificRidConcentrationTearOff();

/// @nodoc
mixin _$SpecificRidConcentration {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get calOffset => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidConcentrationCopyWith<SpecificRidConcentration> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidConcentrationCopyWith<$Res> {
  factory $SpecificRidConcentrationCopyWith(SpecificRidConcentration value,
          $Res Function(SpecificRidConcentration) then) =
      _$SpecificRidConcentrationCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class _$SpecificRidConcentrationCopyWithImpl<$Res>
    implements $SpecificRidConcentrationCopyWith<$Res> {
  _$SpecificRidConcentrationCopyWithImpl(this._value, this._then);

  final SpecificRidConcentration _value;
  // ignore: unused_field
  final $Res Function(SpecificRidConcentration) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidConcentrationCopyWith<$Res>
    implements $SpecificRidConcentrationCopyWith<$Res> {
  factory _$SpecificRidConcentrationCopyWith(_SpecificRidConcentration value,
          $Res Function(_SpecificRidConcentration) then) =
      __$SpecificRidConcentrationCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class __$SpecificRidConcentrationCopyWithImpl<$Res>
    extends _$SpecificRidConcentrationCopyWithImpl<$Res>
    implements _$SpecificRidConcentrationCopyWith<$Res> {
  __$SpecificRidConcentrationCopyWithImpl(_SpecificRidConcentration _value,
      $Res Function(_SpecificRidConcentration) _then)
      : super(_value, (v) => _then(v as _SpecificRidConcentration));

  @override
  _SpecificRidConcentration get _value =>
      super._value as _SpecificRidConcentration;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidConcentration(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidConcentration implements _SpecificRidConcentration {
  const _$_SpecificRidConcentration(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues,
      required this.calOffset,
      required this.appType});

  factory _$_SpecificRidConcentration.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidConcentrationFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int calOffset;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidConcentration(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, calOffset: $calOffset, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidConcentration &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.calOffset, calOffset) ||
                const DeepCollectionEquality()
                    .equals(other.calOffset, calOffset)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(calOffset) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidConcentrationCopyWith<_SpecificRidConcentration> get copyWith =>
      __$SpecificRidConcentrationCopyWithImpl<_SpecificRidConcentration>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidConcentrationToJson(this);
  }
}

abstract class _SpecificRidConcentration implements SpecificRidConcentration {
  const factory _SpecificRidConcentration(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) = _$_SpecificRidConcentration;

  factory _SpecificRidConcentration.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidConcentration.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get calOffset => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidConcentrationCopyWith<_SpecificRidConcentration> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidConductivity _$SpecificRidConductivityFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidConductivity.fromJson(json);
}

/// @nodoc
class _$SpecificRidConductivityTearOff {
  const _$SpecificRidConductivityTearOff();

  _SpecificRidConductivity call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) {
    return _SpecificRidConductivity(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      calOffset: calOffset,
      appType: appType,
    );
  }

  SpecificRidConductivity fromJson(Map<String, Object> json) {
    return SpecificRidConductivity.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidConductivity = _$SpecificRidConductivityTearOff();

/// @nodoc
mixin _$SpecificRidConductivity {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get calOffset => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidConductivityCopyWith<SpecificRidConductivity> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidConductivityCopyWith<$Res> {
  factory $SpecificRidConductivityCopyWith(SpecificRidConductivity value,
          $Res Function(SpecificRidConductivity) then) =
      _$SpecificRidConductivityCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class _$SpecificRidConductivityCopyWithImpl<$Res>
    implements $SpecificRidConductivityCopyWith<$Res> {
  _$SpecificRidConductivityCopyWithImpl(this._value, this._then);

  final SpecificRidConductivity _value;
  // ignore: unused_field
  final $Res Function(SpecificRidConductivity) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidConductivityCopyWith<$Res>
    implements $SpecificRidConductivityCopyWith<$Res> {
  factory _$SpecificRidConductivityCopyWith(_SpecificRidConductivity value,
          $Res Function(_SpecificRidConductivity) then) =
      __$SpecificRidConductivityCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class __$SpecificRidConductivityCopyWithImpl<$Res>
    extends _$SpecificRidConductivityCopyWithImpl<$Res>
    implements _$SpecificRidConductivityCopyWith<$Res> {
  __$SpecificRidConductivityCopyWithImpl(_SpecificRidConductivity _value,
      $Res Function(_SpecificRidConductivity) _then)
      : super(_value, (v) => _then(v as _SpecificRidConductivity));

  @override
  _SpecificRidConductivity get _value =>
      super._value as _SpecificRidConductivity;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidConductivity(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidConductivity implements _SpecificRidConductivity {
  const _$_SpecificRidConductivity(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues,
      required this.calOffset,
      required this.appType});

  factory _$_SpecificRidConductivity.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidConductivityFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int calOffset;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidConductivity(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, calOffset: $calOffset, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidConductivity &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.calOffset, calOffset) ||
                const DeepCollectionEquality()
                    .equals(other.calOffset, calOffset)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(calOffset) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidConductivityCopyWith<_SpecificRidConductivity> get copyWith =>
      __$SpecificRidConductivityCopyWithImpl<_SpecificRidConductivity>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidConductivityToJson(this);
  }
}

abstract class _SpecificRidConductivity implements SpecificRidConductivity {
  const factory _SpecificRidConductivity(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) = _$_SpecificRidConductivity;

  factory _SpecificRidConductivity.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidConductivity.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get calOffset => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidConductivityCopyWith<_SpecificRidConductivity> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidConnMonitor _$SpecificRidConnMonitorFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidConnMonitor.fromJson(json);
}

/// @nodoc
class _$SpecificRidConnMonitorTearOff {
  const _$SpecificRidConnMonitorTearOff();

  _SpecificRidConnMonitor call(
      {required int nwkBearer,
      required int availNwkBearer,
      required int radioStrength,
      required int linkQuality,
      required int ip,
      required int routeIp,
      required int linkUtil,
      required int APN,
      required int cellId,
      required int SMNC,
      required int SMCC}) {
    return _SpecificRidConnMonitor(
      nwkBearer: nwkBearer,
      availNwkBearer: availNwkBearer,
      radioStrength: radioStrength,
      linkQuality: linkQuality,
      ip: ip,
      routeIp: routeIp,
      linkUtil: linkUtil,
      APN: APN,
      cellId: cellId,
      SMNC: SMNC,
      SMCC: SMCC,
    );
  }

  SpecificRidConnMonitor fromJson(Map<String, Object> json) {
    return SpecificRidConnMonitor.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidConnMonitor = _$SpecificRidConnMonitorTearOff();

/// @nodoc
mixin _$SpecificRidConnMonitor {
  int get nwkBearer => throw _privateConstructorUsedError;
  int get availNwkBearer => throw _privateConstructorUsedError;
  int get radioStrength => throw _privateConstructorUsedError;
  int get linkQuality => throw _privateConstructorUsedError;
  int get ip => throw _privateConstructorUsedError;
  int get routeIp => throw _privateConstructorUsedError;
  int get linkUtil => throw _privateConstructorUsedError;
  int get APN => throw _privateConstructorUsedError;
  int get cellId => throw _privateConstructorUsedError;
  int get SMNC => throw _privateConstructorUsedError;
  int get SMCC => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidConnMonitorCopyWith<SpecificRidConnMonitor> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidConnMonitorCopyWith<$Res> {
  factory $SpecificRidConnMonitorCopyWith(SpecificRidConnMonitor value,
          $Res Function(SpecificRidConnMonitor) then) =
      _$SpecificRidConnMonitorCopyWithImpl<$Res>;
  $Res call(
      {int nwkBearer,
      int availNwkBearer,
      int radioStrength,
      int linkQuality,
      int ip,
      int routeIp,
      int linkUtil,
      int APN,
      int cellId,
      int SMNC,
      int SMCC});
}

/// @nodoc
class _$SpecificRidConnMonitorCopyWithImpl<$Res>
    implements $SpecificRidConnMonitorCopyWith<$Res> {
  _$SpecificRidConnMonitorCopyWithImpl(this._value, this._then);

  final SpecificRidConnMonitor _value;
  // ignore: unused_field
  final $Res Function(SpecificRidConnMonitor) _then;

  @override
  $Res call({
    Object? nwkBearer = freezed,
    Object? availNwkBearer = freezed,
    Object? radioStrength = freezed,
    Object? linkQuality = freezed,
    Object? ip = freezed,
    Object? routeIp = freezed,
    Object? linkUtil = freezed,
    Object? APN = freezed,
    Object? cellId = freezed,
    Object? SMNC = freezed,
    Object? SMCC = freezed,
  }) {
    return _then(_value.copyWith(
      nwkBearer: nwkBearer == freezed
          ? _value.nwkBearer
          : nwkBearer // ignore: cast_nullable_to_non_nullable
              as int,
      availNwkBearer: availNwkBearer == freezed
          ? _value.availNwkBearer
          : availNwkBearer // ignore: cast_nullable_to_non_nullable
              as int,
      radioStrength: radioStrength == freezed
          ? _value.radioStrength
          : radioStrength // ignore: cast_nullable_to_non_nullable
              as int,
      linkQuality: linkQuality == freezed
          ? _value.linkQuality
          : linkQuality // ignore: cast_nullable_to_non_nullable
              as int,
      ip: ip == freezed
          ? _value.ip
          : ip // ignore: cast_nullable_to_non_nullable
              as int,
      routeIp: routeIp == freezed
          ? _value.routeIp
          : routeIp // ignore: cast_nullable_to_non_nullable
              as int,
      linkUtil: linkUtil == freezed
          ? _value.linkUtil
          : linkUtil // ignore: cast_nullable_to_non_nullable
              as int,
      APN: APN == freezed
          ? _value.APN
          : APN // ignore: cast_nullable_to_non_nullable
              as int,
      cellId: cellId == freezed
          ? _value.cellId
          : cellId // ignore: cast_nullable_to_non_nullable
              as int,
      SMNC: SMNC == freezed
          ? _value.SMNC
          : SMNC // ignore: cast_nullable_to_non_nullable
              as int,
      SMCC: SMCC == freezed
          ? _value.SMCC
          : SMCC // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidConnMonitorCopyWith<$Res>
    implements $SpecificRidConnMonitorCopyWith<$Res> {
  factory _$SpecificRidConnMonitorCopyWith(_SpecificRidConnMonitor value,
          $Res Function(_SpecificRidConnMonitor) then) =
      __$SpecificRidConnMonitorCopyWithImpl<$Res>;
  @override
  $Res call(
      {int nwkBearer,
      int availNwkBearer,
      int radioStrength,
      int linkQuality,
      int ip,
      int routeIp,
      int linkUtil,
      int APN,
      int cellId,
      int SMNC,
      int SMCC});
}

/// @nodoc
class __$SpecificRidConnMonitorCopyWithImpl<$Res>
    extends _$SpecificRidConnMonitorCopyWithImpl<$Res>
    implements _$SpecificRidConnMonitorCopyWith<$Res> {
  __$SpecificRidConnMonitorCopyWithImpl(_SpecificRidConnMonitor _value,
      $Res Function(_SpecificRidConnMonitor) _then)
      : super(_value, (v) => _then(v as _SpecificRidConnMonitor));

  @override
  _SpecificRidConnMonitor get _value => super._value as _SpecificRidConnMonitor;

  @override
  $Res call({
    Object? nwkBearer = freezed,
    Object? availNwkBearer = freezed,
    Object? radioStrength = freezed,
    Object? linkQuality = freezed,
    Object? ip = freezed,
    Object? routeIp = freezed,
    Object? linkUtil = freezed,
    Object? APN = freezed,
    Object? cellId = freezed,
    Object? SMNC = freezed,
    Object? SMCC = freezed,
  }) {
    return _then(_SpecificRidConnMonitor(
      nwkBearer: nwkBearer == freezed
          ? _value.nwkBearer
          : nwkBearer // ignore: cast_nullable_to_non_nullable
              as int,
      availNwkBearer: availNwkBearer == freezed
          ? _value.availNwkBearer
          : availNwkBearer // ignore: cast_nullable_to_non_nullable
              as int,
      radioStrength: radioStrength == freezed
          ? _value.radioStrength
          : radioStrength // ignore: cast_nullable_to_non_nullable
              as int,
      linkQuality: linkQuality == freezed
          ? _value.linkQuality
          : linkQuality // ignore: cast_nullable_to_non_nullable
              as int,
      ip: ip == freezed
          ? _value.ip
          : ip // ignore: cast_nullable_to_non_nullable
              as int,
      routeIp: routeIp == freezed
          ? _value.routeIp
          : routeIp // ignore: cast_nullable_to_non_nullable
              as int,
      linkUtil: linkUtil == freezed
          ? _value.linkUtil
          : linkUtil // ignore: cast_nullable_to_non_nullable
              as int,
      APN: APN == freezed
          ? _value.APN
          : APN // ignore: cast_nullable_to_non_nullable
              as int,
      cellId: cellId == freezed
          ? _value.cellId
          : cellId // ignore: cast_nullable_to_non_nullable
              as int,
      SMNC: SMNC == freezed
          ? _value.SMNC
          : SMNC // ignore: cast_nullable_to_non_nullable
              as int,
      SMCC: SMCC == freezed
          ? _value.SMCC
          : SMCC // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidConnMonitor implements _SpecificRidConnMonitor {
  const _$_SpecificRidConnMonitor(
      {required this.nwkBearer,
      required this.availNwkBearer,
      required this.radioStrength,
      required this.linkQuality,
      required this.ip,
      required this.routeIp,
      required this.linkUtil,
      required this.APN,
      required this.cellId,
      required this.SMNC,
      required this.SMCC});

  factory _$_SpecificRidConnMonitor.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidConnMonitorFromJson(json);

  @override
  final int nwkBearer;
  @override
  final int availNwkBearer;
  @override
  final int radioStrength;
  @override
  final int linkQuality;
  @override
  final int ip;
  @override
  final int routeIp;
  @override
  final int linkUtil;
  @override
  final int APN;
  @override
  final int cellId;
  @override
  final int SMNC;
  @override
  final int SMCC;

  @override
  String toString() {
    return 'SpecificRidConnMonitor(nwkBearer: $nwkBearer, availNwkBearer: $availNwkBearer, radioStrength: $radioStrength, linkQuality: $linkQuality, ip: $ip, routeIp: $routeIp, linkUtil: $linkUtil, APN: $APN, cellId: $cellId, SMNC: $SMNC, SMCC: $SMCC)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidConnMonitor &&
            (identical(other.nwkBearer, nwkBearer) ||
                const DeepCollectionEquality()
                    .equals(other.nwkBearer, nwkBearer)) &&
            (identical(other.availNwkBearer, availNwkBearer) ||
                const DeepCollectionEquality()
                    .equals(other.availNwkBearer, availNwkBearer)) &&
            (identical(other.radioStrength, radioStrength) ||
                const DeepCollectionEquality()
                    .equals(other.radioStrength, radioStrength)) &&
            (identical(other.linkQuality, linkQuality) ||
                const DeepCollectionEquality()
                    .equals(other.linkQuality, linkQuality)) &&
            (identical(other.ip, ip) ||
                const DeepCollectionEquality().equals(other.ip, ip)) &&
            (identical(other.routeIp, routeIp) ||
                const DeepCollectionEquality()
                    .equals(other.routeIp, routeIp)) &&
            (identical(other.linkUtil, linkUtil) ||
                const DeepCollectionEquality()
                    .equals(other.linkUtil, linkUtil)) &&
            (identical(other.APN, APN) ||
                const DeepCollectionEquality().equals(other.APN, APN)) &&
            (identical(other.cellId, cellId) ||
                const DeepCollectionEquality().equals(other.cellId, cellId)) &&
            (identical(other.SMNC, SMNC) ||
                const DeepCollectionEquality().equals(other.SMNC, SMNC)) &&
            (identical(other.SMCC, SMCC) ||
                const DeepCollectionEquality().equals(other.SMCC, SMCC)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(nwkBearer) ^
      const DeepCollectionEquality().hash(availNwkBearer) ^
      const DeepCollectionEquality().hash(radioStrength) ^
      const DeepCollectionEquality().hash(linkQuality) ^
      const DeepCollectionEquality().hash(ip) ^
      const DeepCollectionEquality().hash(routeIp) ^
      const DeepCollectionEquality().hash(linkUtil) ^
      const DeepCollectionEquality().hash(APN) ^
      const DeepCollectionEquality().hash(cellId) ^
      const DeepCollectionEquality().hash(SMNC) ^
      const DeepCollectionEquality().hash(SMCC);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidConnMonitorCopyWith<_SpecificRidConnMonitor> get copyWith =>
      __$SpecificRidConnMonitorCopyWithImpl<_SpecificRidConnMonitor>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidConnMonitorToJson(this);
  }
}

abstract class _SpecificRidConnMonitor implements SpecificRidConnMonitor {
  const factory _SpecificRidConnMonitor(
      {required int nwkBearer,
      required int availNwkBearer,
      required int radioStrength,
      required int linkQuality,
      required int ip,
      required int routeIp,
      required int linkUtil,
      required int APN,
      required int cellId,
      required int SMNC,
      required int SMCC}) = _$_SpecificRidConnMonitor;

  factory _SpecificRidConnMonitor.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidConnMonitor.fromJson;

  @override
  int get nwkBearer => throw _privateConstructorUsedError;
  @override
  int get availNwkBearer => throw _privateConstructorUsedError;
  @override
  int get radioStrength => throw _privateConstructorUsedError;
  @override
  int get linkQuality => throw _privateConstructorUsedError;
  @override
  int get ip => throw _privateConstructorUsedError;
  @override
  int get routeIp => throw _privateConstructorUsedError;
  @override
  int get linkUtil => throw _privateConstructorUsedError;
  @override
  int get APN => throw _privateConstructorUsedError;
  @override
  int get cellId => throw _privateConstructorUsedError;
  @override
  int get SMNC => throw _privateConstructorUsedError;
  @override
  int get SMCC => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidConnMonitorCopyWith<_SpecificRidConnMonitor> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidConnStatistics _$SpecificRidConnStatisticsFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidConnStatistics.fromJson(json);
}

/// @nodoc
class _$SpecificRidConnStatisticsTearOff {
  const _$SpecificRidConnStatisticsTearOff();

  _SpecificRidConnStatistics call(
      {@JsonKey(name: "SMSTxCounter") required int smsTxCounter,
      @JsonKey(name: "SMSRxCounter") required int smsRxCounter,
      required int txData,
      required int rxData,
      required int maxMsgSize,
      required int avgMsgSize,
      required int startOrReset}) {
    return _SpecificRidConnStatistics(
      smsTxCounter: smsTxCounter,
      smsRxCounter: smsRxCounter,
      txData: txData,
      rxData: rxData,
      maxMsgSize: maxMsgSize,
      avgMsgSize: avgMsgSize,
      startOrReset: startOrReset,
    );
  }

  SpecificRidConnStatistics fromJson(Map<String, Object> json) {
    return SpecificRidConnStatistics.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidConnStatistics = _$SpecificRidConnStatisticsTearOff();

/// @nodoc
mixin _$SpecificRidConnStatistics {
  @JsonKey(name: "SMSTxCounter")
  int get smsTxCounter => throw _privateConstructorUsedError;
  @JsonKey(name: "SMSRxCounter")
  int get smsRxCounter => throw _privateConstructorUsedError;
  int get txData => throw _privateConstructorUsedError;
  int get rxData => throw _privateConstructorUsedError;
  int get maxMsgSize => throw _privateConstructorUsedError;
  int get avgMsgSize => throw _privateConstructorUsedError;
  int get startOrReset => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidConnStatisticsCopyWith<SpecificRidConnStatistics> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidConnStatisticsCopyWith<$Res> {
  factory $SpecificRidConnStatisticsCopyWith(SpecificRidConnStatistics value,
          $Res Function(SpecificRidConnStatistics) then) =
      _$SpecificRidConnStatisticsCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(name: "SMSTxCounter") int smsTxCounter,
      @JsonKey(name: "SMSRxCounter") int smsRxCounter,
      int txData,
      int rxData,
      int maxMsgSize,
      int avgMsgSize,
      int startOrReset});
}

/// @nodoc
class _$SpecificRidConnStatisticsCopyWithImpl<$Res>
    implements $SpecificRidConnStatisticsCopyWith<$Res> {
  _$SpecificRidConnStatisticsCopyWithImpl(this._value, this._then);

  final SpecificRidConnStatistics _value;
  // ignore: unused_field
  final $Res Function(SpecificRidConnStatistics) _then;

  @override
  $Res call({
    Object? smsTxCounter = freezed,
    Object? smsRxCounter = freezed,
    Object? txData = freezed,
    Object? rxData = freezed,
    Object? maxMsgSize = freezed,
    Object? avgMsgSize = freezed,
    Object? startOrReset = freezed,
  }) {
    return _then(_value.copyWith(
      smsTxCounter: smsTxCounter == freezed
          ? _value.smsTxCounter
          : smsTxCounter // ignore: cast_nullable_to_non_nullable
              as int,
      smsRxCounter: smsRxCounter == freezed
          ? _value.smsRxCounter
          : smsRxCounter // ignore: cast_nullable_to_non_nullable
              as int,
      txData: txData == freezed
          ? _value.txData
          : txData // ignore: cast_nullable_to_non_nullable
              as int,
      rxData: rxData == freezed
          ? _value.rxData
          : rxData // ignore: cast_nullable_to_non_nullable
              as int,
      maxMsgSize: maxMsgSize == freezed
          ? _value.maxMsgSize
          : maxMsgSize // ignore: cast_nullable_to_non_nullable
              as int,
      avgMsgSize: avgMsgSize == freezed
          ? _value.avgMsgSize
          : avgMsgSize // ignore: cast_nullable_to_non_nullable
              as int,
      startOrReset: startOrReset == freezed
          ? _value.startOrReset
          : startOrReset // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidConnStatisticsCopyWith<$Res>
    implements $SpecificRidConnStatisticsCopyWith<$Res> {
  factory _$SpecificRidConnStatisticsCopyWith(_SpecificRidConnStatistics value,
          $Res Function(_SpecificRidConnStatistics) then) =
      __$SpecificRidConnStatisticsCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(name: "SMSTxCounter") int smsTxCounter,
      @JsonKey(name: "SMSRxCounter") int smsRxCounter,
      int txData,
      int rxData,
      int maxMsgSize,
      int avgMsgSize,
      int startOrReset});
}

/// @nodoc
class __$SpecificRidConnStatisticsCopyWithImpl<$Res>
    extends _$SpecificRidConnStatisticsCopyWithImpl<$Res>
    implements _$SpecificRidConnStatisticsCopyWith<$Res> {
  __$SpecificRidConnStatisticsCopyWithImpl(_SpecificRidConnStatistics _value,
      $Res Function(_SpecificRidConnStatistics) _then)
      : super(_value, (v) => _then(v as _SpecificRidConnStatistics));

  @override
  _SpecificRidConnStatistics get _value =>
      super._value as _SpecificRidConnStatistics;

  @override
  $Res call({
    Object? smsTxCounter = freezed,
    Object? smsRxCounter = freezed,
    Object? txData = freezed,
    Object? rxData = freezed,
    Object? maxMsgSize = freezed,
    Object? avgMsgSize = freezed,
    Object? startOrReset = freezed,
  }) {
    return _then(_SpecificRidConnStatistics(
      smsTxCounter: smsTxCounter == freezed
          ? _value.smsTxCounter
          : smsTxCounter // ignore: cast_nullable_to_non_nullable
              as int,
      smsRxCounter: smsRxCounter == freezed
          ? _value.smsRxCounter
          : smsRxCounter // ignore: cast_nullable_to_non_nullable
              as int,
      txData: txData == freezed
          ? _value.txData
          : txData // ignore: cast_nullable_to_non_nullable
              as int,
      rxData: rxData == freezed
          ? _value.rxData
          : rxData // ignore: cast_nullable_to_non_nullable
              as int,
      maxMsgSize: maxMsgSize == freezed
          ? _value.maxMsgSize
          : maxMsgSize // ignore: cast_nullable_to_non_nullable
              as int,
      avgMsgSize: avgMsgSize == freezed
          ? _value.avgMsgSize
          : avgMsgSize // ignore: cast_nullable_to_non_nullable
              as int,
      startOrReset: startOrReset == freezed
          ? _value.startOrReset
          : startOrReset // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidConnStatistics implements _SpecificRidConnStatistics {
  const _$_SpecificRidConnStatistics(
      {@JsonKey(name: "SMSTxCounter") required this.smsTxCounter,
      @JsonKey(name: "SMSRxCounter") required this.smsRxCounter,
      required this.txData,
      required this.rxData,
      required this.maxMsgSize,
      required this.avgMsgSize,
      required this.startOrReset});

  factory _$_SpecificRidConnStatistics.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidConnStatisticsFromJson(json);

  @override
  @JsonKey(name: "SMSTxCounter")
  final int smsTxCounter;
  @override
  @JsonKey(name: "SMSRxCounter")
  final int smsRxCounter;
  @override
  final int txData;
  @override
  final int rxData;
  @override
  final int maxMsgSize;
  @override
  final int avgMsgSize;
  @override
  final int startOrReset;

  @override
  String toString() {
    return 'SpecificRidConnStatistics(smsTxCounter: $smsTxCounter, smsRxCounter: $smsRxCounter, txData: $txData, rxData: $rxData, maxMsgSize: $maxMsgSize, avgMsgSize: $avgMsgSize, startOrReset: $startOrReset)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidConnStatistics &&
            (identical(other.smsTxCounter, smsTxCounter) ||
                const DeepCollectionEquality()
                    .equals(other.smsTxCounter, smsTxCounter)) &&
            (identical(other.smsRxCounter, smsRxCounter) ||
                const DeepCollectionEquality()
                    .equals(other.smsRxCounter, smsRxCounter)) &&
            (identical(other.txData, txData) ||
                const DeepCollectionEquality().equals(other.txData, txData)) &&
            (identical(other.rxData, rxData) ||
                const DeepCollectionEquality().equals(other.rxData, rxData)) &&
            (identical(other.maxMsgSize, maxMsgSize) ||
                const DeepCollectionEquality()
                    .equals(other.maxMsgSize, maxMsgSize)) &&
            (identical(other.avgMsgSize, avgMsgSize) ||
                const DeepCollectionEquality()
                    .equals(other.avgMsgSize, avgMsgSize)) &&
            (identical(other.startOrReset, startOrReset) ||
                const DeepCollectionEquality()
                    .equals(other.startOrReset, startOrReset)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(smsTxCounter) ^
      const DeepCollectionEquality().hash(smsRxCounter) ^
      const DeepCollectionEquality().hash(txData) ^
      const DeepCollectionEquality().hash(rxData) ^
      const DeepCollectionEquality().hash(maxMsgSize) ^
      const DeepCollectionEquality().hash(avgMsgSize) ^
      const DeepCollectionEquality().hash(startOrReset);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidConnStatisticsCopyWith<_SpecificRidConnStatistics>
      get copyWith =>
          __$SpecificRidConnStatisticsCopyWithImpl<_SpecificRidConnStatistics>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidConnStatisticsToJson(this);
  }
}

abstract class _SpecificRidConnStatistics implements SpecificRidConnStatistics {
  const factory _SpecificRidConnStatistics(
      {@JsonKey(name: "SMSTxCounter") required int smsTxCounter,
      @JsonKey(name: "SMSRxCounter") required int smsRxCounter,
      required int txData,
      required int rxData,
      required int maxMsgSize,
      required int avgMsgSize,
      required int startOrReset}) = _$_SpecificRidConnStatistics;

  factory _SpecificRidConnStatistics.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidConnStatistics.fromJson;

  @override
  @JsonKey(name: "SMSTxCounter")
  int get smsTxCounter => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "SMSRxCounter")
  int get smsRxCounter => throw _privateConstructorUsedError;
  @override
  int get txData => throw _privateConstructorUsedError;
  @override
  int get rxData => throw _privateConstructorUsedError;
  @override
  int get maxMsgSize => throw _privateConstructorUsedError;
  @override
  int get avgMsgSize => throw _privateConstructorUsedError;
  @override
  int get startOrReset => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidConnStatisticsCopyWith<_SpecificRidConnStatistics>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificRidCurrent _$SpecificRidCurrentFromJson(Map<String, dynamic> json) {
  return _SpecificRidCurrent.fromJson(json);
}

/// @nodoc
class _$SpecificRidCurrentTearOff {
  const _$SpecificRidCurrentTearOff();

  _SpecificRidCurrent call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) {
    return _SpecificRidCurrent(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      calOffset: calOffset,
      appType: appType,
    );
  }

  SpecificRidCurrent fromJson(Map<String, Object> json) {
    return SpecificRidCurrent.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidCurrent = _$SpecificRidCurrentTearOff();

/// @nodoc
mixin _$SpecificRidCurrent {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get calOffset => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidCurrentCopyWith<SpecificRidCurrent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidCurrentCopyWith<$Res> {
  factory $SpecificRidCurrentCopyWith(
          SpecificRidCurrent value, $Res Function(SpecificRidCurrent) then) =
      _$SpecificRidCurrentCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class _$SpecificRidCurrentCopyWithImpl<$Res>
    implements $SpecificRidCurrentCopyWith<$Res> {
  _$SpecificRidCurrentCopyWithImpl(this._value, this._then);

  final SpecificRidCurrent _value;
  // ignore: unused_field
  final $Res Function(SpecificRidCurrent) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidCurrentCopyWith<$Res>
    implements $SpecificRidCurrentCopyWith<$Res> {
  factory _$SpecificRidCurrentCopyWith(
          _SpecificRidCurrent value, $Res Function(_SpecificRidCurrent) then) =
      __$SpecificRidCurrentCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class __$SpecificRidCurrentCopyWithImpl<$Res>
    extends _$SpecificRidCurrentCopyWithImpl<$Res>
    implements _$SpecificRidCurrentCopyWith<$Res> {
  __$SpecificRidCurrentCopyWithImpl(
      _SpecificRidCurrent _value, $Res Function(_SpecificRidCurrent) _then)
      : super(_value, (v) => _then(v as _SpecificRidCurrent));

  @override
  _SpecificRidCurrent get _value => super._value as _SpecificRidCurrent;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidCurrent(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidCurrent implements _SpecificRidCurrent {
  const _$_SpecificRidCurrent(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues,
      required this.calOffset,
      required this.appType});

  factory _$_SpecificRidCurrent.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidCurrentFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int calOffset;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidCurrent(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, calOffset: $calOffset, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidCurrent &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.calOffset, calOffset) ||
                const DeepCollectionEquality()
                    .equals(other.calOffset, calOffset)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(calOffset) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidCurrentCopyWith<_SpecificRidCurrent> get copyWith =>
      __$SpecificRidCurrentCopyWithImpl<_SpecificRidCurrent>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidCurrentToJson(this);
  }
}

abstract class _SpecificRidCurrent implements SpecificRidCurrent {
  const factory _SpecificRidCurrent(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) = _$_SpecificRidCurrent;

  factory _SpecificRidCurrent.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidCurrent.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get calOffset => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidCurrentCopyWith<_SpecificRidCurrent> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidDepth _$SpecificRidDepthFromJson(Map<String, dynamic> json) {
  return _SpecificRidDepth.fromJson(json);
}

/// @nodoc
class _$SpecificRidDepthTearOff {
  const _$SpecificRidDepthTearOff();

  _SpecificRidDepth call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) {
    return _SpecificRidDepth(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      calOffset: calOffset,
      appType: appType,
    );
  }

  SpecificRidDepth fromJson(Map<String, Object> json) {
    return SpecificRidDepth.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidDepth = _$SpecificRidDepthTearOff();

/// @nodoc
mixin _$SpecificRidDepth {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get calOffset => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidDepthCopyWith<SpecificRidDepth> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidDepthCopyWith<$Res> {
  factory $SpecificRidDepthCopyWith(
          SpecificRidDepth value, $Res Function(SpecificRidDepth) then) =
      _$SpecificRidDepthCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class _$SpecificRidDepthCopyWithImpl<$Res>
    implements $SpecificRidDepthCopyWith<$Res> {
  _$SpecificRidDepthCopyWithImpl(this._value, this._then);

  final SpecificRidDepth _value;
  // ignore: unused_field
  final $Res Function(SpecificRidDepth) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidDepthCopyWith<$Res>
    implements $SpecificRidDepthCopyWith<$Res> {
  factory _$SpecificRidDepthCopyWith(
          _SpecificRidDepth value, $Res Function(_SpecificRidDepth) then) =
      __$SpecificRidDepthCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class __$SpecificRidDepthCopyWithImpl<$Res>
    extends _$SpecificRidDepthCopyWithImpl<$Res>
    implements _$SpecificRidDepthCopyWith<$Res> {
  __$SpecificRidDepthCopyWithImpl(
      _SpecificRidDepth _value, $Res Function(_SpecificRidDepth) _then)
      : super(_value, (v) => _then(v as _SpecificRidDepth));

  @override
  _SpecificRidDepth get _value => super._value as _SpecificRidDepth;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidDepth(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidDepth implements _SpecificRidDepth {
  const _$_SpecificRidDepth(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues,
      required this.calOffset,
      required this.appType});

  factory _$_SpecificRidDepth.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidDepthFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int calOffset;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidDepth(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, calOffset: $calOffset, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidDepth &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.calOffset, calOffset) ||
                const DeepCollectionEquality()
                    .equals(other.calOffset, calOffset)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(calOffset) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidDepthCopyWith<_SpecificRidDepth> get copyWith =>
      __$SpecificRidDepthCopyWithImpl<_SpecificRidDepth>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidDepthToJson(this);
  }
}

abstract class _SpecificRidDepth implements SpecificRidDepth {
  const factory _SpecificRidDepth(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) = _$_SpecificRidDepth;

  factory _SpecificRidDepth.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidDepth.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get calOffset => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidDepthCopyWith<_SpecificRidDepth> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidDevice _$SpecificRidDeviceFromJson(Map<String, dynamic> json) {
  return _SpecificRidDevice.fromJson(json);
}

/// @nodoc
class _$SpecificRidDeviceTearOff {
  const _$SpecificRidDeviceTearOff();

  _SpecificRidDevice call(
      {required int manuf,
      required int model,
      required int serial,
      required int firmware,
      required int reboot,
      required int factoryReset,
      required int availPwrSrc,
      required int pwrSrcVoltage,
      required int pwrSrcCurrent,
      required int battLevel,
      required int memFree,
      required int errCode,
      required int resetErrCode,
      required int currTime,
      required int UTCOffset,
      required int timezone,
      required int bindAndModes,
      required int devType,
      required int hwVer,
      required int swVer,
      required int battStatus,
      required int memTotal}) {
    return _SpecificRidDevice(
      manuf: manuf,
      model: model,
      serial: serial,
      firmware: firmware,
      reboot: reboot,
      factoryReset: factoryReset,
      availPwrSrc: availPwrSrc,
      pwrSrcVoltage: pwrSrcVoltage,
      pwrSrcCurrent: pwrSrcCurrent,
      battLevel: battLevel,
      memFree: memFree,
      errCode: errCode,
      resetErrCode: resetErrCode,
      currTime: currTime,
      UTCOffset: UTCOffset,
      timezone: timezone,
      bindAndModes: bindAndModes,
      devType: devType,
      hwVer: hwVer,
      swVer: swVer,
      battStatus: battStatus,
      memTotal: memTotal,
    );
  }

  SpecificRidDevice fromJson(Map<String, Object> json) {
    return SpecificRidDevice.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidDevice = _$SpecificRidDeviceTearOff();

/// @nodoc
mixin _$SpecificRidDevice {
  int get manuf => throw _privateConstructorUsedError;
  int get model => throw _privateConstructorUsedError;
  int get serial => throw _privateConstructorUsedError;
  int get firmware => throw _privateConstructorUsedError;
  int get reboot => throw _privateConstructorUsedError;
  int get factoryReset => throw _privateConstructorUsedError;
  int get availPwrSrc => throw _privateConstructorUsedError;
  int get pwrSrcVoltage => throw _privateConstructorUsedError;
  int get pwrSrcCurrent => throw _privateConstructorUsedError;
  int get battLevel => throw _privateConstructorUsedError;
  int get memFree => throw _privateConstructorUsedError;
  int get errCode => throw _privateConstructorUsedError;
  int get resetErrCode => throw _privateConstructorUsedError;
  int get currTime => throw _privateConstructorUsedError;
  int get UTCOffset => throw _privateConstructorUsedError;
  int get timezone => throw _privateConstructorUsedError;
  int get bindAndModes => throw _privateConstructorUsedError;
  int get devType => throw _privateConstructorUsedError;
  int get hwVer => throw _privateConstructorUsedError;
  int get swVer => throw _privateConstructorUsedError;
  int get battStatus => throw _privateConstructorUsedError;
  int get memTotal => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidDeviceCopyWith<SpecificRidDevice> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidDeviceCopyWith<$Res> {
  factory $SpecificRidDeviceCopyWith(
          SpecificRidDevice value, $Res Function(SpecificRidDevice) then) =
      _$SpecificRidDeviceCopyWithImpl<$Res>;
  $Res call(
      {int manuf,
      int model,
      int serial,
      int firmware,
      int reboot,
      int factoryReset,
      int availPwrSrc,
      int pwrSrcVoltage,
      int pwrSrcCurrent,
      int battLevel,
      int memFree,
      int errCode,
      int resetErrCode,
      int currTime,
      int UTCOffset,
      int timezone,
      int bindAndModes,
      int devType,
      int hwVer,
      int swVer,
      int battStatus,
      int memTotal});
}

/// @nodoc
class _$SpecificRidDeviceCopyWithImpl<$Res>
    implements $SpecificRidDeviceCopyWith<$Res> {
  _$SpecificRidDeviceCopyWithImpl(this._value, this._then);

  final SpecificRidDevice _value;
  // ignore: unused_field
  final $Res Function(SpecificRidDevice) _then;

  @override
  $Res call({
    Object? manuf = freezed,
    Object? model = freezed,
    Object? serial = freezed,
    Object? firmware = freezed,
    Object? reboot = freezed,
    Object? factoryReset = freezed,
    Object? availPwrSrc = freezed,
    Object? pwrSrcVoltage = freezed,
    Object? pwrSrcCurrent = freezed,
    Object? battLevel = freezed,
    Object? memFree = freezed,
    Object? errCode = freezed,
    Object? resetErrCode = freezed,
    Object? currTime = freezed,
    Object? UTCOffset = freezed,
    Object? timezone = freezed,
    Object? bindAndModes = freezed,
    Object? devType = freezed,
    Object? hwVer = freezed,
    Object? swVer = freezed,
    Object? battStatus = freezed,
    Object? memTotal = freezed,
  }) {
    return _then(_value.copyWith(
      manuf: manuf == freezed
          ? _value.manuf
          : manuf // ignore: cast_nullable_to_non_nullable
              as int,
      model: model == freezed
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as int,
      serial: serial == freezed
          ? _value.serial
          : serial // ignore: cast_nullable_to_non_nullable
              as int,
      firmware: firmware == freezed
          ? _value.firmware
          : firmware // ignore: cast_nullable_to_non_nullable
              as int,
      reboot: reboot == freezed
          ? _value.reboot
          : reboot // ignore: cast_nullable_to_non_nullable
              as int,
      factoryReset: factoryReset == freezed
          ? _value.factoryReset
          : factoryReset // ignore: cast_nullable_to_non_nullable
              as int,
      availPwrSrc: availPwrSrc == freezed
          ? _value.availPwrSrc
          : availPwrSrc // ignore: cast_nullable_to_non_nullable
              as int,
      pwrSrcVoltage: pwrSrcVoltage == freezed
          ? _value.pwrSrcVoltage
          : pwrSrcVoltage // ignore: cast_nullable_to_non_nullable
              as int,
      pwrSrcCurrent: pwrSrcCurrent == freezed
          ? _value.pwrSrcCurrent
          : pwrSrcCurrent // ignore: cast_nullable_to_non_nullable
              as int,
      battLevel: battLevel == freezed
          ? _value.battLevel
          : battLevel // ignore: cast_nullable_to_non_nullable
              as int,
      memFree: memFree == freezed
          ? _value.memFree
          : memFree // ignore: cast_nullable_to_non_nullable
              as int,
      errCode: errCode == freezed
          ? _value.errCode
          : errCode // ignore: cast_nullable_to_non_nullable
              as int,
      resetErrCode: resetErrCode == freezed
          ? _value.resetErrCode
          : resetErrCode // ignore: cast_nullable_to_non_nullable
              as int,
      currTime: currTime == freezed
          ? _value.currTime
          : currTime // ignore: cast_nullable_to_non_nullable
              as int,
      UTCOffset: UTCOffset == freezed
          ? _value.UTCOffset
          : UTCOffset // ignore: cast_nullable_to_non_nullable
              as int,
      timezone: timezone == freezed
          ? _value.timezone
          : timezone // ignore: cast_nullable_to_non_nullable
              as int,
      bindAndModes: bindAndModes == freezed
          ? _value.bindAndModes
          : bindAndModes // ignore: cast_nullable_to_non_nullable
              as int,
      devType: devType == freezed
          ? _value.devType
          : devType // ignore: cast_nullable_to_non_nullable
              as int,
      hwVer: hwVer == freezed
          ? _value.hwVer
          : hwVer // ignore: cast_nullable_to_non_nullable
              as int,
      swVer: swVer == freezed
          ? _value.swVer
          : swVer // ignore: cast_nullable_to_non_nullable
              as int,
      battStatus: battStatus == freezed
          ? _value.battStatus
          : battStatus // ignore: cast_nullable_to_non_nullable
              as int,
      memTotal: memTotal == freezed
          ? _value.memTotal
          : memTotal // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidDeviceCopyWith<$Res>
    implements $SpecificRidDeviceCopyWith<$Res> {
  factory _$SpecificRidDeviceCopyWith(
          _SpecificRidDevice value, $Res Function(_SpecificRidDevice) then) =
      __$SpecificRidDeviceCopyWithImpl<$Res>;
  @override
  $Res call(
      {int manuf,
      int model,
      int serial,
      int firmware,
      int reboot,
      int factoryReset,
      int availPwrSrc,
      int pwrSrcVoltage,
      int pwrSrcCurrent,
      int battLevel,
      int memFree,
      int errCode,
      int resetErrCode,
      int currTime,
      int UTCOffset,
      int timezone,
      int bindAndModes,
      int devType,
      int hwVer,
      int swVer,
      int battStatus,
      int memTotal});
}

/// @nodoc
class __$SpecificRidDeviceCopyWithImpl<$Res>
    extends _$SpecificRidDeviceCopyWithImpl<$Res>
    implements _$SpecificRidDeviceCopyWith<$Res> {
  __$SpecificRidDeviceCopyWithImpl(
      _SpecificRidDevice _value, $Res Function(_SpecificRidDevice) _then)
      : super(_value, (v) => _then(v as _SpecificRidDevice));

  @override
  _SpecificRidDevice get _value => super._value as _SpecificRidDevice;

  @override
  $Res call({
    Object? manuf = freezed,
    Object? model = freezed,
    Object? serial = freezed,
    Object? firmware = freezed,
    Object? reboot = freezed,
    Object? factoryReset = freezed,
    Object? availPwrSrc = freezed,
    Object? pwrSrcVoltage = freezed,
    Object? pwrSrcCurrent = freezed,
    Object? battLevel = freezed,
    Object? memFree = freezed,
    Object? errCode = freezed,
    Object? resetErrCode = freezed,
    Object? currTime = freezed,
    Object? UTCOffset = freezed,
    Object? timezone = freezed,
    Object? bindAndModes = freezed,
    Object? devType = freezed,
    Object? hwVer = freezed,
    Object? swVer = freezed,
    Object? battStatus = freezed,
    Object? memTotal = freezed,
  }) {
    return _then(_SpecificRidDevice(
      manuf: manuf == freezed
          ? _value.manuf
          : manuf // ignore: cast_nullable_to_non_nullable
              as int,
      model: model == freezed
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as int,
      serial: serial == freezed
          ? _value.serial
          : serial // ignore: cast_nullable_to_non_nullable
              as int,
      firmware: firmware == freezed
          ? _value.firmware
          : firmware // ignore: cast_nullable_to_non_nullable
              as int,
      reboot: reboot == freezed
          ? _value.reboot
          : reboot // ignore: cast_nullable_to_non_nullable
              as int,
      factoryReset: factoryReset == freezed
          ? _value.factoryReset
          : factoryReset // ignore: cast_nullable_to_non_nullable
              as int,
      availPwrSrc: availPwrSrc == freezed
          ? _value.availPwrSrc
          : availPwrSrc // ignore: cast_nullable_to_non_nullable
              as int,
      pwrSrcVoltage: pwrSrcVoltage == freezed
          ? _value.pwrSrcVoltage
          : pwrSrcVoltage // ignore: cast_nullable_to_non_nullable
              as int,
      pwrSrcCurrent: pwrSrcCurrent == freezed
          ? _value.pwrSrcCurrent
          : pwrSrcCurrent // ignore: cast_nullable_to_non_nullable
              as int,
      battLevel: battLevel == freezed
          ? _value.battLevel
          : battLevel // ignore: cast_nullable_to_non_nullable
              as int,
      memFree: memFree == freezed
          ? _value.memFree
          : memFree // ignore: cast_nullable_to_non_nullable
              as int,
      errCode: errCode == freezed
          ? _value.errCode
          : errCode // ignore: cast_nullable_to_non_nullable
              as int,
      resetErrCode: resetErrCode == freezed
          ? _value.resetErrCode
          : resetErrCode // ignore: cast_nullable_to_non_nullable
              as int,
      currTime: currTime == freezed
          ? _value.currTime
          : currTime // ignore: cast_nullable_to_non_nullable
              as int,
      UTCOffset: UTCOffset == freezed
          ? _value.UTCOffset
          : UTCOffset // ignore: cast_nullable_to_non_nullable
              as int,
      timezone: timezone == freezed
          ? _value.timezone
          : timezone // ignore: cast_nullable_to_non_nullable
              as int,
      bindAndModes: bindAndModes == freezed
          ? _value.bindAndModes
          : bindAndModes // ignore: cast_nullable_to_non_nullable
              as int,
      devType: devType == freezed
          ? _value.devType
          : devType // ignore: cast_nullable_to_non_nullable
              as int,
      hwVer: hwVer == freezed
          ? _value.hwVer
          : hwVer // ignore: cast_nullable_to_non_nullable
              as int,
      swVer: swVer == freezed
          ? _value.swVer
          : swVer // ignore: cast_nullable_to_non_nullable
              as int,
      battStatus: battStatus == freezed
          ? _value.battStatus
          : battStatus // ignore: cast_nullable_to_non_nullable
              as int,
      memTotal: memTotal == freezed
          ? _value.memTotal
          : memTotal // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidDevice implements _SpecificRidDevice {
  const _$_SpecificRidDevice(
      {required this.manuf,
      required this.model,
      required this.serial,
      required this.firmware,
      required this.reboot,
      required this.factoryReset,
      required this.availPwrSrc,
      required this.pwrSrcVoltage,
      required this.pwrSrcCurrent,
      required this.battLevel,
      required this.memFree,
      required this.errCode,
      required this.resetErrCode,
      required this.currTime,
      required this.UTCOffset,
      required this.timezone,
      required this.bindAndModes,
      required this.devType,
      required this.hwVer,
      required this.swVer,
      required this.battStatus,
      required this.memTotal});

  factory _$_SpecificRidDevice.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidDeviceFromJson(json);

  @override
  final int manuf;
  @override
  final int model;
  @override
  final int serial;
  @override
  final int firmware;
  @override
  final int reboot;
  @override
  final int factoryReset;
  @override
  final int availPwrSrc;
  @override
  final int pwrSrcVoltage;
  @override
  final int pwrSrcCurrent;
  @override
  final int battLevel;
  @override
  final int memFree;
  @override
  final int errCode;
  @override
  final int resetErrCode;
  @override
  final int currTime;
  @override
  final int UTCOffset;
  @override
  final int timezone;
  @override
  final int bindAndModes;
  @override
  final int devType;
  @override
  final int hwVer;
  @override
  final int swVer;
  @override
  final int battStatus;
  @override
  final int memTotal;

  @override
  String toString() {
    return 'SpecificRidDevice(manuf: $manuf, model: $model, serial: $serial, firmware: $firmware, reboot: $reboot, factoryReset: $factoryReset, availPwrSrc: $availPwrSrc, pwrSrcVoltage: $pwrSrcVoltage, pwrSrcCurrent: $pwrSrcCurrent, battLevel: $battLevel, memFree: $memFree, errCode: $errCode, resetErrCode: $resetErrCode, currTime: $currTime, UTCOffset: $UTCOffset, timezone: $timezone, bindAndModes: $bindAndModes, devType: $devType, hwVer: $hwVer, swVer: $swVer, battStatus: $battStatus, memTotal: $memTotal)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidDevice &&
            (identical(other.manuf, manuf) ||
                const DeepCollectionEquality().equals(other.manuf, manuf)) &&
            (identical(other.model, model) ||
                const DeepCollectionEquality().equals(other.model, model)) &&
            (identical(other.serial, serial) ||
                const DeepCollectionEquality().equals(other.serial, serial)) &&
            (identical(other.firmware, firmware) ||
                const DeepCollectionEquality()
                    .equals(other.firmware, firmware)) &&
            (identical(other.reboot, reboot) ||
                const DeepCollectionEquality().equals(other.reboot, reboot)) &&
            (identical(other.factoryReset, factoryReset) ||
                const DeepCollectionEquality()
                    .equals(other.factoryReset, factoryReset)) &&
            (identical(other.availPwrSrc, availPwrSrc) ||
                const DeepCollectionEquality()
                    .equals(other.availPwrSrc, availPwrSrc)) &&
            (identical(other.pwrSrcVoltage, pwrSrcVoltage) ||
                const DeepCollectionEquality()
                    .equals(other.pwrSrcVoltage, pwrSrcVoltage)) &&
            (identical(other.pwrSrcCurrent, pwrSrcCurrent) ||
                const DeepCollectionEquality()
                    .equals(other.pwrSrcCurrent, pwrSrcCurrent)) &&
            (identical(other.battLevel, battLevel) ||
                const DeepCollectionEquality()
                    .equals(other.battLevel, battLevel)) &&
            (identical(other.memFree, memFree) ||
                const DeepCollectionEquality()
                    .equals(other.memFree, memFree)) &&
            (identical(other.errCode, errCode) ||
                const DeepCollectionEquality()
                    .equals(other.errCode, errCode)) &&
            (identical(other.resetErrCode, resetErrCode) ||
                const DeepCollectionEquality()
                    .equals(other.resetErrCode, resetErrCode)) &&
            (identical(other.currTime, currTime) ||
                const DeepCollectionEquality()
                    .equals(other.currTime, currTime)) &&
            (identical(other.UTCOffset, UTCOffset) ||
                const DeepCollectionEquality()
                    .equals(other.UTCOffset, UTCOffset)) &&
            (identical(other.timezone, timezone) ||
                const DeepCollectionEquality()
                    .equals(other.timezone, timezone)) &&
            (identical(other.bindAndModes, bindAndModes) ||
                const DeepCollectionEquality()
                    .equals(other.bindAndModes, bindAndModes)) &&
            (identical(other.devType, devType) ||
                const DeepCollectionEquality()
                    .equals(other.devType, devType)) &&
            (identical(other.hwVer, hwVer) ||
                const DeepCollectionEquality().equals(other.hwVer, hwVer)) &&
            (identical(other.swVer, swVer) ||
                const DeepCollectionEquality().equals(other.swVer, swVer)) &&
            (identical(other.battStatus, battStatus) ||
                const DeepCollectionEquality()
                    .equals(other.battStatus, battStatus)) &&
            (identical(other.memTotal, memTotal) ||
                const DeepCollectionEquality()
                    .equals(other.memTotal, memTotal)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(manuf) ^
      const DeepCollectionEquality().hash(model) ^
      const DeepCollectionEquality().hash(serial) ^
      const DeepCollectionEquality().hash(firmware) ^
      const DeepCollectionEquality().hash(reboot) ^
      const DeepCollectionEquality().hash(factoryReset) ^
      const DeepCollectionEquality().hash(availPwrSrc) ^
      const DeepCollectionEquality().hash(pwrSrcVoltage) ^
      const DeepCollectionEquality().hash(pwrSrcCurrent) ^
      const DeepCollectionEquality().hash(battLevel) ^
      const DeepCollectionEquality().hash(memFree) ^
      const DeepCollectionEquality().hash(errCode) ^
      const DeepCollectionEquality().hash(resetErrCode) ^
      const DeepCollectionEquality().hash(currTime) ^
      const DeepCollectionEquality().hash(UTCOffset) ^
      const DeepCollectionEquality().hash(timezone) ^
      const DeepCollectionEquality().hash(bindAndModes) ^
      const DeepCollectionEquality().hash(devType) ^
      const DeepCollectionEquality().hash(hwVer) ^
      const DeepCollectionEquality().hash(swVer) ^
      const DeepCollectionEquality().hash(battStatus) ^
      const DeepCollectionEquality().hash(memTotal);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidDeviceCopyWith<_SpecificRidDevice> get copyWith =>
      __$SpecificRidDeviceCopyWithImpl<_SpecificRidDevice>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidDeviceToJson(this);
  }
}

abstract class _SpecificRidDevice implements SpecificRidDevice {
  const factory _SpecificRidDevice(
      {required int manuf,
      required int model,
      required int serial,
      required int firmware,
      required int reboot,
      required int factoryReset,
      required int availPwrSrc,
      required int pwrSrcVoltage,
      required int pwrSrcCurrent,
      required int battLevel,
      required int memFree,
      required int errCode,
      required int resetErrCode,
      required int currTime,
      required int UTCOffset,
      required int timezone,
      required int bindAndModes,
      required int devType,
      required int hwVer,
      required int swVer,
      required int battStatus,
      required int memTotal}) = _$_SpecificRidDevice;

  factory _SpecificRidDevice.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidDevice.fromJson;

  @override
  int get manuf => throw _privateConstructorUsedError;
  @override
  int get model => throw _privateConstructorUsedError;
  @override
  int get serial => throw _privateConstructorUsedError;
  @override
  int get firmware => throw _privateConstructorUsedError;
  @override
  int get reboot => throw _privateConstructorUsedError;
  @override
  int get factoryReset => throw _privateConstructorUsedError;
  @override
  int get availPwrSrc => throw _privateConstructorUsedError;
  @override
  int get pwrSrcVoltage => throw _privateConstructorUsedError;
  @override
  int get pwrSrcCurrent => throw _privateConstructorUsedError;
  @override
  int get battLevel => throw _privateConstructorUsedError;
  @override
  int get memFree => throw _privateConstructorUsedError;
  @override
  int get errCode => throw _privateConstructorUsedError;
  @override
  int get resetErrCode => throw _privateConstructorUsedError;
  @override
  int get currTime => throw _privateConstructorUsedError;
  @override
  int get UTCOffset => throw _privateConstructorUsedError;
  @override
  int get timezone => throw _privateConstructorUsedError;
  @override
  int get bindAndModes => throw _privateConstructorUsedError;
  @override
  int get devType => throw _privateConstructorUsedError;
  @override
  int get hwVer => throw _privateConstructorUsedError;
  @override
  int get swVer => throw _privateConstructorUsedError;
  @override
  int get battStatus => throw _privateConstructorUsedError;
  @override
  int get memTotal => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidDeviceCopyWith<_SpecificRidDevice> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidDIn _$SpecificRidDInFromJson(Map<String, dynamic> json) {
  return _SpecificRidDIn.fromJson(json);
}

/// @nodoc
class _$SpecificRidDInTearOff {
  const _$SpecificRidDInTearOff();

  _SpecificRidDIn call(
      {required int dInState,
      required int counter,
      required int dInPolarity,
      required int debouncePeriod,
      required int edgeSelection,
      required int counterReset,
      required int appType,
      required int sensorType}) {
    return _SpecificRidDIn(
      dInState: dInState,
      counter: counter,
      dInPolarity: dInPolarity,
      debouncePeriod: debouncePeriod,
      edgeSelection: edgeSelection,
      counterReset: counterReset,
      appType: appType,
      sensorType: sensorType,
    );
  }

  SpecificRidDIn fromJson(Map<String, Object> json) {
    return SpecificRidDIn.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidDIn = _$SpecificRidDInTearOff();

/// @nodoc
mixin _$SpecificRidDIn {
  int get dInState => throw _privateConstructorUsedError;
  int get counter => throw _privateConstructorUsedError;
  int get dInPolarity => throw _privateConstructorUsedError;
  int get debouncePeriod => throw _privateConstructorUsedError;
  int get edgeSelection => throw _privateConstructorUsedError;
  int get counterReset => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;
  int get sensorType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidDInCopyWith<SpecificRidDIn> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidDInCopyWith<$Res> {
  factory $SpecificRidDInCopyWith(
          SpecificRidDIn value, $Res Function(SpecificRidDIn) then) =
      _$SpecificRidDInCopyWithImpl<$Res>;
  $Res call(
      {int dInState,
      int counter,
      int dInPolarity,
      int debouncePeriod,
      int edgeSelection,
      int counterReset,
      int appType,
      int sensorType});
}

/// @nodoc
class _$SpecificRidDInCopyWithImpl<$Res>
    implements $SpecificRidDInCopyWith<$Res> {
  _$SpecificRidDInCopyWithImpl(this._value, this._then);

  final SpecificRidDIn _value;
  // ignore: unused_field
  final $Res Function(SpecificRidDIn) _then;

  @override
  $Res call({
    Object? dInState = freezed,
    Object? counter = freezed,
    Object? dInPolarity = freezed,
    Object? debouncePeriod = freezed,
    Object? edgeSelection = freezed,
    Object? counterReset = freezed,
    Object? appType = freezed,
    Object? sensorType = freezed,
  }) {
    return _then(_value.copyWith(
      dInState: dInState == freezed
          ? _value.dInState
          : dInState // ignore: cast_nullable_to_non_nullable
              as int,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as int,
      dInPolarity: dInPolarity == freezed
          ? _value.dInPolarity
          : dInPolarity // ignore: cast_nullable_to_non_nullable
              as int,
      debouncePeriod: debouncePeriod == freezed
          ? _value.debouncePeriod
          : debouncePeriod // ignore: cast_nullable_to_non_nullable
              as int,
      edgeSelection: edgeSelection == freezed
          ? _value.edgeSelection
          : edgeSelection // ignore: cast_nullable_to_non_nullable
              as int,
      counterReset: counterReset == freezed
          ? _value.counterReset
          : counterReset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
      sensorType: sensorType == freezed
          ? _value.sensorType
          : sensorType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidDInCopyWith<$Res>
    implements $SpecificRidDInCopyWith<$Res> {
  factory _$SpecificRidDInCopyWith(
          _SpecificRidDIn value, $Res Function(_SpecificRidDIn) then) =
      __$SpecificRidDInCopyWithImpl<$Res>;
  @override
  $Res call(
      {int dInState,
      int counter,
      int dInPolarity,
      int debouncePeriod,
      int edgeSelection,
      int counterReset,
      int appType,
      int sensorType});
}

/// @nodoc
class __$SpecificRidDInCopyWithImpl<$Res>
    extends _$SpecificRidDInCopyWithImpl<$Res>
    implements _$SpecificRidDInCopyWith<$Res> {
  __$SpecificRidDInCopyWithImpl(
      _SpecificRidDIn _value, $Res Function(_SpecificRidDIn) _then)
      : super(_value, (v) => _then(v as _SpecificRidDIn));

  @override
  _SpecificRidDIn get _value => super._value as _SpecificRidDIn;

  @override
  $Res call({
    Object? dInState = freezed,
    Object? counter = freezed,
    Object? dInPolarity = freezed,
    Object? debouncePeriod = freezed,
    Object? edgeSelection = freezed,
    Object? counterReset = freezed,
    Object? appType = freezed,
    Object? sensorType = freezed,
  }) {
    return _then(_SpecificRidDIn(
      dInState: dInState == freezed
          ? _value.dInState
          : dInState // ignore: cast_nullable_to_non_nullable
              as int,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as int,
      dInPolarity: dInPolarity == freezed
          ? _value.dInPolarity
          : dInPolarity // ignore: cast_nullable_to_non_nullable
              as int,
      debouncePeriod: debouncePeriod == freezed
          ? _value.debouncePeriod
          : debouncePeriod // ignore: cast_nullable_to_non_nullable
              as int,
      edgeSelection: edgeSelection == freezed
          ? _value.edgeSelection
          : edgeSelection // ignore: cast_nullable_to_non_nullable
              as int,
      counterReset: counterReset == freezed
          ? _value.counterReset
          : counterReset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
      sensorType: sensorType == freezed
          ? _value.sensorType
          : sensorType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidDIn implements _SpecificRidDIn {
  const _$_SpecificRidDIn(
      {required this.dInState,
      required this.counter,
      required this.dInPolarity,
      required this.debouncePeriod,
      required this.edgeSelection,
      required this.counterReset,
      required this.appType,
      required this.sensorType});

  factory _$_SpecificRidDIn.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidDInFromJson(json);

  @override
  final int dInState;
  @override
  final int counter;
  @override
  final int dInPolarity;
  @override
  final int debouncePeriod;
  @override
  final int edgeSelection;
  @override
  final int counterReset;
  @override
  final int appType;
  @override
  final int sensorType;

  @override
  String toString() {
    return 'SpecificRidDIn(dInState: $dInState, counter: $counter, dInPolarity: $dInPolarity, debouncePeriod: $debouncePeriod, edgeSelection: $edgeSelection, counterReset: $counterReset, appType: $appType, sensorType: $sensorType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidDIn &&
            (identical(other.dInState, dInState) ||
                const DeepCollectionEquality()
                    .equals(other.dInState, dInState)) &&
            (identical(other.counter, counter) ||
                const DeepCollectionEquality()
                    .equals(other.counter, counter)) &&
            (identical(other.dInPolarity, dInPolarity) ||
                const DeepCollectionEquality()
                    .equals(other.dInPolarity, dInPolarity)) &&
            (identical(other.debouncePeriod, debouncePeriod) ||
                const DeepCollectionEquality()
                    .equals(other.debouncePeriod, debouncePeriod)) &&
            (identical(other.edgeSelection, edgeSelection) ||
                const DeepCollectionEquality()
                    .equals(other.edgeSelection, edgeSelection)) &&
            (identical(other.counterReset, counterReset) ||
                const DeepCollectionEquality()
                    .equals(other.counterReset, counterReset)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality()
                    .equals(other.appType, appType)) &&
            (identical(other.sensorType, sensorType) ||
                const DeepCollectionEquality()
                    .equals(other.sensorType, sensorType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(dInState) ^
      const DeepCollectionEquality().hash(counter) ^
      const DeepCollectionEquality().hash(dInPolarity) ^
      const DeepCollectionEquality().hash(debouncePeriod) ^
      const DeepCollectionEquality().hash(edgeSelection) ^
      const DeepCollectionEquality().hash(counterReset) ^
      const DeepCollectionEquality().hash(appType) ^
      const DeepCollectionEquality().hash(sensorType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidDInCopyWith<_SpecificRidDIn> get copyWith =>
      __$SpecificRidDInCopyWithImpl<_SpecificRidDIn>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidDInToJson(this);
  }
}

abstract class _SpecificRidDIn implements SpecificRidDIn {
  const factory _SpecificRidDIn(
      {required int dInState,
      required int counter,
      required int dInPolarity,
      required int debouncePeriod,
      required int edgeSelection,
      required int counterReset,
      required int appType,
      required int sensorType}) = _$_SpecificRidDIn;

  factory _SpecificRidDIn.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidDIn.fromJson;

  @override
  int get dInState => throw _privateConstructorUsedError;
  @override
  int get counter => throw _privateConstructorUsedError;
  @override
  int get dInPolarity => throw _privateConstructorUsedError;
  @override
  int get debouncePeriod => throw _privateConstructorUsedError;
  @override
  int get edgeSelection => throw _privateConstructorUsedError;
  @override
  int get counterReset => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  int get sensorType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidDInCopyWith<_SpecificRidDIn> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidDistance _$SpecificRidDistanceFromJson(Map<String, dynamic> json) {
  return _SpecificRidDistance.fromJson(json);
}

/// @nodoc
class _$SpecificRidDistanceTearOff {
  const _$SpecificRidDistanceTearOff();

  _SpecificRidDistance call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) {
    return _SpecificRidDistance(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      calOffset: calOffset,
      appType: appType,
    );
  }

  SpecificRidDistance fromJson(Map<String, Object> json) {
    return SpecificRidDistance.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidDistance = _$SpecificRidDistanceTearOff();

/// @nodoc
mixin _$SpecificRidDistance {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get calOffset => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidDistanceCopyWith<SpecificRidDistance> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidDistanceCopyWith<$Res> {
  factory $SpecificRidDistanceCopyWith(
          SpecificRidDistance value, $Res Function(SpecificRidDistance) then) =
      _$SpecificRidDistanceCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class _$SpecificRidDistanceCopyWithImpl<$Res>
    implements $SpecificRidDistanceCopyWith<$Res> {
  _$SpecificRidDistanceCopyWithImpl(this._value, this._then);

  final SpecificRidDistance _value;
  // ignore: unused_field
  final $Res Function(SpecificRidDistance) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidDistanceCopyWith<$Res>
    implements $SpecificRidDistanceCopyWith<$Res> {
  factory _$SpecificRidDistanceCopyWith(_SpecificRidDistance value,
          $Res Function(_SpecificRidDistance) then) =
      __$SpecificRidDistanceCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class __$SpecificRidDistanceCopyWithImpl<$Res>
    extends _$SpecificRidDistanceCopyWithImpl<$Res>
    implements _$SpecificRidDistanceCopyWith<$Res> {
  __$SpecificRidDistanceCopyWithImpl(
      _SpecificRidDistance _value, $Res Function(_SpecificRidDistance) _then)
      : super(_value, (v) => _then(v as _SpecificRidDistance));

  @override
  _SpecificRidDistance get _value => super._value as _SpecificRidDistance;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidDistance(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidDistance implements _SpecificRidDistance {
  const _$_SpecificRidDistance(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues,
      required this.calOffset,
      required this.appType});

  factory _$_SpecificRidDistance.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidDistanceFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int calOffset;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidDistance(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, calOffset: $calOffset, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidDistance &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.calOffset, calOffset) ||
                const DeepCollectionEquality()
                    .equals(other.calOffset, calOffset)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(calOffset) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidDistanceCopyWith<_SpecificRidDistance> get copyWith =>
      __$SpecificRidDistanceCopyWithImpl<_SpecificRidDistance>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidDistanceToJson(this);
  }
}

abstract class _SpecificRidDistance implements SpecificRidDistance {
  const factory _SpecificRidDistance(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) = _$_SpecificRidDistance;

  factory _SpecificRidDistance.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidDistance.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get calOffset => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidDistanceCopyWith<_SpecificRidDistance> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidDOut _$SpecificRidDOutFromJson(Map<String, dynamic> json) {
  return _SpecificRidDOut.fromJson(json);
}

/// @nodoc
class _$SpecificRidDOutTearOff {
  const _$SpecificRidDOutTearOff();

  _SpecificRidDOut call(
      {required int dOutState,
      required int dOutPolarity,
      required int appType}) {
    return _SpecificRidDOut(
      dOutState: dOutState,
      dOutPolarity: dOutPolarity,
      appType: appType,
    );
  }

  SpecificRidDOut fromJson(Map<String, Object> json) {
    return SpecificRidDOut.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidDOut = _$SpecificRidDOutTearOff();

/// @nodoc
mixin _$SpecificRidDOut {
  int get dOutState => throw _privateConstructorUsedError;
  int get dOutPolarity => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidDOutCopyWith<SpecificRidDOut> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidDOutCopyWith<$Res> {
  factory $SpecificRidDOutCopyWith(
          SpecificRidDOut value, $Res Function(SpecificRidDOut) then) =
      _$SpecificRidDOutCopyWithImpl<$Res>;
  $Res call({int dOutState, int dOutPolarity, int appType});
}

/// @nodoc
class _$SpecificRidDOutCopyWithImpl<$Res>
    implements $SpecificRidDOutCopyWith<$Res> {
  _$SpecificRidDOutCopyWithImpl(this._value, this._then);

  final SpecificRidDOut _value;
  // ignore: unused_field
  final $Res Function(SpecificRidDOut) _then;

  @override
  $Res call({
    Object? dOutState = freezed,
    Object? dOutPolarity = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      dOutState: dOutState == freezed
          ? _value.dOutState
          : dOutState // ignore: cast_nullable_to_non_nullable
              as int,
      dOutPolarity: dOutPolarity == freezed
          ? _value.dOutPolarity
          : dOutPolarity // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidDOutCopyWith<$Res>
    implements $SpecificRidDOutCopyWith<$Res> {
  factory _$SpecificRidDOutCopyWith(
          _SpecificRidDOut value, $Res Function(_SpecificRidDOut) then) =
      __$SpecificRidDOutCopyWithImpl<$Res>;
  @override
  $Res call({int dOutState, int dOutPolarity, int appType});
}

/// @nodoc
class __$SpecificRidDOutCopyWithImpl<$Res>
    extends _$SpecificRidDOutCopyWithImpl<$Res>
    implements _$SpecificRidDOutCopyWith<$Res> {
  __$SpecificRidDOutCopyWithImpl(
      _SpecificRidDOut _value, $Res Function(_SpecificRidDOut) _then)
      : super(_value, (v) => _then(v as _SpecificRidDOut));

  @override
  _SpecificRidDOut get _value => super._value as _SpecificRidDOut;

  @override
  $Res call({
    Object? dOutState = freezed,
    Object? dOutPolarity = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidDOut(
      dOutState: dOutState == freezed
          ? _value.dOutState
          : dOutState // ignore: cast_nullable_to_non_nullable
              as int,
      dOutPolarity: dOutPolarity == freezed
          ? _value.dOutPolarity
          : dOutPolarity // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidDOut implements _SpecificRidDOut {
  const _$_SpecificRidDOut(
      {required this.dOutState,
      required this.dOutPolarity,
      required this.appType});

  factory _$_SpecificRidDOut.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidDOutFromJson(json);

  @override
  final int dOutState;
  @override
  final int dOutPolarity;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidDOut(dOutState: $dOutState, dOutPolarity: $dOutPolarity, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidDOut &&
            (identical(other.dOutState, dOutState) ||
                const DeepCollectionEquality()
                    .equals(other.dOutState, dOutState)) &&
            (identical(other.dOutPolarity, dOutPolarity) ||
                const DeepCollectionEquality()
                    .equals(other.dOutPolarity, dOutPolarity)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(dOutState) ^
      const DeepCollectionEquality().hash(dOutPolarity) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidDOutCopyWith<_SpecificRidDOut> get copyWith =>
      __$SpecificRidDOutCopyWithImpl<_SpecificRidDOut>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidDOutToJson(this);
  }
}

abstract class _SpecificRidDOut implements SpecificRidDOut {
  const factory _SpecificRidDOut(
      {required int dOutState,
      required int dOutPolarity,
      required int appType}) = _$_SpecificRidDOut;

  factory _SpecificRidDOut.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidDOut.fromJson;

  @override
  int get dOutState => throw _privateConstructorUsedError;
  @override
  int get dOutPolarity => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidDOutCopyWith<_SpecificRidDOut> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidDirection _$SpecificRidDirectionFromJson(Map<String, dynamic> json) {
  return _SpecificRidDirection.fromJson(json);
}

/// @nodoc
class _$SpecificRidDirectionTearOff {
  const _$SpecificRidDirectionTearOff();

  _SpecificRidDirection call(
      {required int compassDir,
      required int minMeaValue,
      required int maxMeaValue,
      required int resetMinMaxMeaValues,
      required int appType}) {
    return _SpecificRidDirection(
      compassDir: compassDir,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      appType: appType,
    );
  }

  SpecificRidDirection fromJson(Map<String, Object> json) {
    return SpecificRidDirection.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidDirection = _$SpecificRidDirectionTearOff();

/// @nodoc
mixin _$SpecificRidDirection {
  int get compassDir => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidDirectionCopyWith<SpecificRidDirection> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidDirectionCopyWith<$Res> {
  factory $SpecificRidDirectionCopyWith(SpecificRidDirection value,
          $Res Function(SpecificRidDirection) then) =
      _$SpecificRidDirectionCopyWithImpl<$Res>;
  $Res call(
      {int compassDir,
      int minMeaValue,
      int maxMeaValue,
      int resetMinMaxMeaValues,
      int appType});
}

/// @nodoc
class _$SpecificRidDirectionCopyWithImpl<$Res>
    implements $SpecificRidDirectionCopyWith<$Res> {
  _$SpecificRidDirectionCopyWithImpl(this._value, this._then);

  final SpecificRidDirection _value;
  // ignore: unused_field
  final $Res Function(SpecificRidDirection) _then;

  @override
  $Res call({
    Object? compassDir = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      compassDir: compassDir == freezed
          ? _value.compassDir
          : compassDir // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidDirectionCopyWith<$Res>
    implements $SpecificRidDirectionCopyWith<$Res> {
  factory _$SpecificRidDirectionCopyWith(_SpecificRidDirection value,
          $Res Function(_SpecificRidDirection) then) =
      __$SpecificRidDirectionCopyWithImpl<$Res>;
  @override
  $Res call(
      {int compassDir,
      int minMeaValue,
      int maxMeaValue,
      int resetMinMaxMeaValues,
      int appType});
}

/// @nodoc
class __$SpecificRidDirectionCopyWithImpl<$Res>
    extends _$SpecificRidDirectionCopyWithImpl<$Res>
    implements _$SpecificRidDirectionCopyWith<$Res> {
  __$SpecificRidDirectionCopyWithImpl(
      _SpecificRidDirection _value, $Res Function(_SpecificRidDirection) _then)
      : super(_value, (v) => _then(v as _SpecificRidDirection));

  @override
  _SpecificRidDirection get _value => super._value as _SpecificRidDirection;

  @override
  $Res call({
    Object? compassDir = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidDirection(
      compassDir: compassDir == freezed
          ? _value.compassDir
          : compassDir // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidDirection implements _SpecificRidDirection {
  const _$_SpecificRidDirection(
      {required this.compassDir,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.resetMinMaxMeaValues,
      required this.appType});

  factory _$_SpecificRidDirection.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidDirectionFromJson(json);

  @override
  final int compassDir;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidDirection(compassDir: $compassDir, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidDirection &&
            (identical(other.compassDir, compassDir) ||
                const DeepCollectionEquality()
                    .equals(other.compassDir, compassDir)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(compassDir) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidDirectionCopyWith<_SpecificRidDirection> get copyWith =>
      __$SpecificRidDirectionCopyWithImpl<_SpecificRidDirection>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidDirectionToJson(this);
  }
}

abstract class _SpecificRidDirection implements SpecificRidDirection {
  const factory _SpecificRidDirection(
      {required int compassDir,
      required int minMeaValue,
      required int maxMeaValue,
      required int resetMinMaxMeaValues,
      required int appType}) = _$_SpecificRidDirection;

  factory _SpecificRidDirection.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidDirection.fromJson;

  @override
  int get compassDir => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidDirectionCopyWith<_SpecificRidDirection> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidEnergy _$SpecificRidEnergyFromJson(Map<String, dynamic> json) {
  return _SpecificRidEnergy.fromJson(json);
}

/// @nodoc
class _$SpecificRidEnergyTearOff {
  const _$SpecificRidEnergyTearOff();

  _SpecificRidEnergy call(
      {required int cumulActivePwr,
      required int units,
      required int resetCumulEnergy,
      required int appType}) {
    return _SpecificRidEnergy(
      cumulActivePwr: cumulActivePwr,
      units: units,
      resetCumulEnergy: resetCumulEnergy,
      appType: appType,
    );
  }

  SpecificRidEnergy fromJson(Map<String, Object> json) {
    return SpecificRidEnergy.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidEnergy = _$SpecificRidEnergyTearOff();

/// @nodoc
mixin _$SpecificRidEnergy {
  int get cumulActivePwr => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get resetCumulEnergy => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidEnergyCopyWith<SpecificRidEnergy> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidEnergyCopyWith<$Res> {
  factory $SpecificRidEnergyCopyWith(
          SpecificRidEnergy value, $Res Function(SpecificRidEnergy) then) =
      _$SpecificRidEnergyCopyWithImpl<$Res>;
  $Res call({int cumulActivePwr, int units, int resetCumulEnergy, int appType});
}

/// @nodoc
class _$SpecificRidEnergyCopyWithImpl<$Res>
    implements $SpecificRidEnergyCopyWith<$Res> {
  _$SpecificRidEnergyCopyWithImpl(this._value, this._then);

  final SpecificRidEnergy _value;
  // ignore: unused_field
  final $Res Function(SpecificRidEnergy) _then;

  @override
  $Res call({
    Object? cumulActivePwr = freezed,
    Object? units = freezed,
    Object? resetCumulEnergy = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      cumulActivePwr: cumulActivePwr == freezed
          ? _value.cumulActivePwr
          : cumulActivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      resetCumulEnergy: resetCumulEnergy == freezed
          ? _value.resetCumulEnergy
          : resetCumulEnergy // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidEnergyCopyWith<$Res>
    implements $SpecificRidEnergyCopyWith<$Res> {
  factory _$SpecificRidEnergyCopyWith(
          _SpecificRidEnergy value, $Res Function(_SpecificRidEnergy) then) =
      __$SpecificRidEnergyCopyWithImpl<$Res>;
  @override
  $Res call({int cumulActivePwr, int units, int resetCumulEnergy, int appType});
}

/// @nodoc
class __$SpecificRidEnergyCopyWithImpl<$Res>
    extends _$SpecificRidEnergyCopyWithImpl<$Res>
    implements _$SpecificRidEnergyCopyWith<$Res> {
  __$SpecificRidEnergyCopyWithImpl(
      _SpecificRidEnergy _value, $Res Function(_SpecificRidEnergy) _then)
      : super(_value, (v) => _then(v as _SpecificRidEnergy));

  @override
  _SpecificRidEnergy get _value => super._value as _SpecificRidEnergy;

  @override
  $Res call({
    Object? cumulActivePwr = freezed,
    Object? units = freezed,
    Object? resetCumulEnergy = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidEnergy(
      cumulActivePwr: cumulActivePwr == freezed
          ? _value.cumulActivePwr
          : cumulActivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      resetCumulEnergy: resetCumulEnergy == freezed
          ? _value.resetCumulEnergy
          : resetCumulEnergy // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidEnergy implements _SpecificRidEnergy {
  const _$_SpecificRidEnergy(
      {required this.cumulActivePwr,
      required this.units,
      required this.resetCumulEnergy,
      required this.appType});

  factory _$_SpecificRidEnergy.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidEnergyFromJson(json);

  @override
  final int cumulActivePwr;
  @override
  final int units;
  @override
  final int resetCumulEnergy;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidEnergy(cumulActivePwr: $cumulActivePwr, units: $units, resetCumulEnergy: $resetCumulEnergy, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidEnergy &&
            (identical(other.cumulActivePwr, cumulActivePwr) ||
                const DeepCollectionEquality()
                    .equals(other.cumulActivePwr, cumulActivePwr)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.resetCumulEnergy, resetCumulEnergy) ||
                const DeepCollectionEquality()
                    .equals(other.resetCumulEnergy, resetCumulEnergy)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(cumulActivePwr) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(resetCumulEnergy) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidEnergyCopyWith<_SpecificRidEnergy> get copyWith =>
      __$SpecificRidEnergyCopyWithImpl<_SpecificRidEnergy>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidEnergyToJson(this);
  }
}

abstract class _SpecificRidEnergy implements SpecificRidEnergy {
  const factory _SpecificRidEnergy(
      {required int cumulActivePwr,
      required int units,
      required int resetCumulEnergy,
      required int appType}) = _$_SpecificRidEnergy;

  factory _SpecificRidEnergy.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidEnergy.fromJson;

  @override
  int get cumulActivePwr => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get resetCumulEnergy => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidEnergyCopyWith<_SpecificRidEnergy> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidFirmware _$SpecificRidFirmwareFromJson(Map<String, dynamic> json) {
  return _SpecificRidFirmware.fromJson(json);
}

/// @nodoc
class _$SpecificRidFirmwareTearOff {
  const _$SpecificRidFirmwareTearOff();

  _SpecificRidFirmware call(
      {required int package,
      @JsonKey(name: "packageURI") required int packageUri,
      required int update,
      required int state,
      required int updateSuppObjects,
      required int updateResult,
      required int pkgName,
      required int pkgVer}) {
    return _SpecificRidFirmware(
      package: package,
      packageUri: packageUri,
      update: update,
      state: state,
      updateSuppObjects: updateSuppObjects,
      updateResult: updateResult,
      pkgName: pkgName,
      pkgVer: pkgVer,
    );
  }

  SpecificRidFirmware fromJson(Map<String, Object> json) {
    return SpecificRidFirmware.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidFirmware = _$SpecificRidFirmwareTearOff();

/// @nodoc
mixin _$SpecificRidFirmware {
  int get package => throw _privateConstructorUsedError;
  @JsonKey(name: "packageURI")
  int get packageUri => throw _privateConstructorUsedError;
  int get update => throw _privateConstructorUsedError;
  int get state => throw _privateConstructorUsedError;
  int get updateSuppObjects => throw _privateConstructorUsedError;
  int get updateResult => throw _privateConstructorUsedError;
  int get pkgName => throw _privateConstructorUsedError;
  int get pkgVer => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidFirmwareCopyWith<SpecificRidFirmware> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidFirmwareCopyWith<$Res> {
  factory $SpecificRidFirmwareCopyWith(
          SpecificRidFirmware value, $Res Function(SpecificRidFirmware) then) =
      _$SpecificRidFirmwareCopyWithImpl<$Res>;
  $Res call(
      {int package,
      @JsonKey(name: "packageURI") int packageUri,
      int update,
      int state,
      int updateSuppObjects,
      int updateResult,
      int pkgName,
      int pkgVer});
}

/// @nodoc
class _$SpecificRidFirmwareCopyWithImpl<$Res>
    implements $SpecificRidFirmwareCopyWith<$Res> {
  _$SpecificRidFirmwareCopyWithImpl(this._value, this._then);

  final SpecificRidFirmware _value;
  // ignore: unused_field
  final $Res Function(SpecificRidFirmware) _then;

  @override
  $Res call({
    Object? package = freezed,
    Object? packageUri = freezed,
    Object? update = freezed,
    Object? state = freezed,
    Object? updateSuppObjects = freezed,
    Object? updateResult = freezed,
    Object? pkgName = freezed,
    Object? pkgVer = freezed,
  }) {
    return _then(_value.copyWith(
      package: package == freezed
          ? _value.package
          : package // ignore: cast_nullable_to_non_nullable
              as int,
      packageUri: packageUri == freezed
          ? _value.packageUri
          : packageUri // ignore: cast_nullable_to_non_nullable
              as int,
      update: update == freezed
          ? _value.update
          : update // ignore: cast_nullable_to_non_nullable
              as int,
      state: state == freezed
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as int,
      updateSuppObjects: updateSuppObjects == freezed
          ? _value.updateSuppObjects
          : updateSuppObjects // ignore: cast_nullable_to_non_nullable
              as int,
      updateResult: updateResult == freezed
          ? _value.updateResult
          : updateResult // ignore: cast_nullable_to_non_nullable
              as int,
      pkgName: pkgName == freezed
          ? _value.pkgName
          : pkgName // ignore: cast_nullable_to_non_nullable
              as int,
      pkgVer: pkgVer == freezed
          ? _value.pkgVer
          : pkgVer // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidFirmwareCopyWith<$Res>
    implements $SpecificRidFirmwareCopyWith<$Res> {
  factory _$SpecificRidFirmwareCopyWith(_SpecificRidFirmware value,
          $Res Function(_SpecificRidFirmware) then) =
      __$SpecificRidFirmwareCopyWithImpl<$Res>;
  @override
  $Res call(
      {int package,
      @JsonKey(name: "packageURI") int packageUri,
      int update,
      int state,
      int updateSuppObjects,
      int updateResult,
      int pkgName,
      int pkgVer});
}

/// @nodoc
class __$SpecificRidFirmwareCopyWithImpl<$Res>
    extends _$SpecificRidFirmwareCopyWithImpl<$Res>
    implements _$SpecificRidFirmwareCopyWith<$Res> {
  __$SpecificRidFirmwareCopyWithImpl(
      _SpecificRidFirmware _value, $Res Function(_SpecificRidFirmware) _then)
      : super(_value, (v) => _then(v as _SpecificRidFirmware));

  @override
  _SpecificRidFirmware get _value => super._value as _SpecificRidFirmware;

  @override
  $Res call({
    Object? package = freezed,
    Object? packageUri = freezed,
    Object? update = freezed,
    Object? state = freezed,
    Object? updateSuppObjects = freezed,
    Object? updateResult = freezed,
    Object? pkgName = freezed,
    Object? pkgVer = freezed,
  }) {
    return _then(_SpecificRidFirmware(
      package: package == freezed
          ? _value.package
          : package // ignore: cast_nullable_to_non_nullable
              as int,
      packageUri: packageUri == freezed
          ? _value.packageUri
          : packageUri // ignore: cast_nullable_to_non_nullable
              as int,
      update: update == freezed
          ? _value.update
          : update // ignore: cast_nullable_to_non_nullable
              as int,
      state: state == freezed
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as int,
      updateSuppObjects: updateSuppObjects == freezed
          ? _value.updateSuppObjects
          : updateSuppObjects // ignore: cast_nullable_to_non_nullable
              as int,
      updateResult: updateResult == freezed
          ? _value.updateResult
          : updateResult // ignore: cast_nullable_to_non_nullable
              as int,
      pkgName: pkgName == freezed
          ? _value.pkgName
          : pkgName // ignore: cast_nullable_to_non_nullable
              as int,
      pkgVer: pkgVer == freezed
          ? _value.pkgVer
          : pkgVer // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidFirmware implements _SpecificRidFirmware {
  const _$_SpecificRidFirmware(
      {required this.package,
      @JsonKey(name: "packageURI") required this.packageUri,
      required this.update,
      required this.state,
      required this.updateSuppObjects,
      required this.updateResult,
      required this.pkgName,
      required this.pkgVer});

  factory _$_SpecificRidFirmware.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidFirmwareFromJson(json);

  @override
  final int package;
  @override
  @JsonKey(name: "packageURI")
  final int packageUri;
  @override
  final int update;
  @override
  final int state;
  @override
  final int updateSuppObjects;
  @override
  final int updateResult;
  @override
  final int pkgName;
  @override
  final int pkgVer;

  @override
  String toString() {
    return 'SpecificRidFirmware(package: $package, packageUri: $packageUri, update: $update, state: $state, updateSuppObjects: $updateSuppObjects, updateResult: $updateResult, pkgName: $pkgName, pkgVer: $pkgVer)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidFirmware &&
            (identical(other.package, package) ||
                const DeepCollectionEquality()
                    .equals(other.package, package)) &&
            (identical(other.packageUri, packageUri) ||
                const DeepCollectionEquality()
                    .equals(other.packageUri, packageUri)) &&
            (identical(other.update, update) ||
                const DeepCollectionEquality().equals(other.update, update)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.updateSuppObjects, updateSuppObjects) ||
                const DeepCollectionEquality()
                    .equals(other.updateSuppObjects, updateSuppObjects)) &&
            (identical(other.updateResult, updateResult) ||
                const DeepCollectionEquality()
                    .equals(other.updateResult, updateResult)) &&
            (identical(other.pkgName, pkgName) ||
                const DeepCollectionEquality()
                    .equals(other.pkgName, pkgName)) &&
            (identical(other.pkgVer, pkgVer) ||
                const DeepCollectionEquality().equals(other.pkgVer, pkgVer)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(package) ^
      const DeepCollectionEquality().hash(packageUri) ^
      const DeepCollectionEquality().hash(update) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(updateSuppObjects) ^
      const DeepCollectionEquality().hash(updateResult) ^
      const DeepCollectionEquality().hash(pkgName) ^
      const DeepCollectionEquality().hash(pkgVer);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidFirmwareCopyWith<_SpecificRidFirmware> get copyWith =>
      __$SpecificRidFirmwareCopyWithImpl<_SpecificRidFirmware>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidFirmwareToJson(this);
  }
}

abstract class _SpecificRidFirmware implements SpecificRidFirmware {
  const factory _SpecificRidFirmware(
      {required int package,
      @JsonKey(name: "packageURI") required int packageUri,
      required int update,
      required int state,
      required int updateSuppObjects,
      required int updateResult,
      required int pkgName,
      required int pkgVer}) = _$_SpecificRidFirmware;

  factory _SpecificRidFirmware.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidFirmware.fromJson;

  @override
  int get package => throw _privateConstructorUsedError;
  @override
  @JsonKey(name: "packageURI")
  int get packageUri => throw _privateConstructorUsedError;
  @override
  int get update => throw _privateConstructorUsedError;
  @override
  int get state => throw _privateConstructorUsedError;
  @override
  int get updateSuppObjects => throw _privateConstructorUsedError;
  @override
  int get updateResult => throw _privateConstructorUsedError;
  @override
  int get pkgName => throw _privateConstructorUsedError;
  @override
  int get pkgVer => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidFirmwareCopyWith<_SpecificRidFirmware> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidFrequency _$SpecificRidFrequencyFromJson(Map<String, dynamic> json) {
  return _SpecificRidFrequency.fromJson(json);
}

/// @nodoc
class _$SpecificRidFrequencyTearOff {
  const _$SpecificRidFrequencyTearOff();

  _SpecificRidFrequency call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) {
    return _SpecificRidFrequency(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      calOffset: calOffset,
      appType: appType,
    );
  }

  SpecificRidFrequency fromJson(Map<String, Object> json) {
    return SpecificRidFrequency.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidFrequency = _$SpecificRidFrequencyTearOff();

/// @nodoc
mixin _$SpecificRidFrequency {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get calOffset => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidFrequencyCopyWith<SpecificRidFrequency> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidFrequencyCopyWith<$Res> {
  factory $SpecificRidFrequencyCopyWith(SpecificRidFrequency value,
          $Res Function(SpecificRidFrequency) then) =
      _$SpecificRidFrequencyCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class _$SpecificRidFrequencyCopyWithImpl<$Res>
    implements $SpecificRidFrequencyCopyWith<$Res> {
  _$SpecificRidFrequencyCopyWithImpl(this._value, this._then);

  final SpecificRidFrequency _value;
  // ignore: unused_field
  final $Res Function(SpecificRidFrequency) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidFrequencyCopyWith<$Res>
    implements $SpecificRidFrequencyCopyWith<$Res> {
  factory _$SpecificRidFrequencyCopyWith(_SpecificRidFrequency value,
          $Res Function(_SpecificRidFrequency) then) =
      __$SpecificRidFrequencyCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class __$SpecificRidFrequencyCopyWithImpl<$Res>
    extends _$SpecificRidFrequencyCopyWithImpl<$Res>
    implements _$SpecificRidFrequencyCopyWith<$Res> {
  __$SpecificRidFrequencyCopyWithImpl(
      _SpecificRidFrequency _value, $Res Function(_SpecificRidFrequency) _then)
      : super(_value, (v) => _then(v as _SpecificRidFrequency));

  @override
  _SpecificRidFrequency get _value => super._value as _SpecificRidFrequency;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidFrequency(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidFrequency implements _SpecificRidFrequency {
  const _$_SpecificRidFrequency(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues,
      required this.calOffset,
      required this.appType});

  factory _$_SpecificRidFrequency.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidFrequencyFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int calOffset;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidFrequency(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, calOffset: $calOffset, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidFrequency &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.calOffset, calOffset) ||
                const DeepCollectionEquality()
                    .equals(other.calOffset, calOffset)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(calOffset) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidFrequencyCopyWith<_SpecificRidFrequency> get copyWith =>
      __$SpecificRidFrequencyCopyWithImpl<_SpecificRidFrequency>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidFrequencyToJson(this);
  }
}

abstract class _SpecificRidFrequency implements SpecificRidFrequency {
  const factory _SpecificRidFrequency(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) = _$_SpecificRidFrequency;

  factory _SpecificRidFrequency.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidFrequency.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get calOffset => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidFrequencyCopyWith<_SpecificRidFrequency> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidGeneric _$SpecificRidGenericFromJson(Map<String, dynamic> json) {
  return _SpecificRidGeneric.fromJson(json);
}

/// @nodoc
class _$SpecificRidGenericTearOff {
  const _$SpecificRidGenericTearOff();

  _SpecificRidGeneric call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int appType,
      required int sensorType}) {
    return _SpecificRidGeneric(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      appType: appType,
      sensorType: sensorType,
    );
  }

  SpecificRidGeneric fromJson(Map<String, Object> json) {
    return SpecificRidGeneric.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidGeneric = _$SpecificRidGenericTearOff();

/// @nodoc
mixin _$SpecificRidGeneric {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;
  int get sensorType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidGenericCopyWith<SpecificRidGeneric> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidGenericCopyWith<$Res> {
  factory $SpecificRidGenericCopyWith(
          SpecificRidGeneric value, $Res Function(SpecificRidGeneric) then) =
      _$SpecificRidGenericCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int appType,
      int sensorType});
}

/// @nodoc
class _$SpecificRidGenericCopyWithImpl<$Res>
    implements $SpecificRidGenericCopyWith<$Res> {
  _$SpecificRidGenericCopyWithImpl(this._value, this._then);

  final SpecificRidGeneric _value;
  // ignore: unused_field
  final $Res Function(SpecificRidGeneric) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? appType = freezed,
    Object? sensorType = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
      sensorType: sensorType == freezed
          ? _value.sensorType
          : sensorType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidGenericCopyWith<$Res>
    implements $SpecificRidGenericCopyWith<$Res> {
  factory _$SpecificRidGenericCopyWith(
          _SpecificRidGeneric value, $Res Function(_SpecificRidGeneric) then) =
      __$SpecificRidGenericCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int appType,
      int sensorType});
}

/// @nodoc
class __$SpecificRidGenericCopyWithImpl<$Res>
    extends _$SpecificRidGenericCopyWithImpl<$Res>
    implements _$SpecificRidGenericCopyWith<$Res> {
  __$SpecificRidGenericCopyWithImpl(
      _SpecificRidGeneric _value, $Res Function(_SpecificRidGeneric) _then)
      : super(_value, (v) => _then(v as _SpecificRidGeneric));

  @override
  _SpecificRidGeneric get _value => super._value as _SpecificRidGeneric;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? appType = freezed,
    Object? sensorType = freezed,
  }) {
    return _then(_SpecificRidGeneric(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
      sensorType: sensorType == freezed
          ? _value.sensorType
          : sensorType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidGeneric implements _SpecificRidGeneric {
  const _$_SpecificRidGeneric(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues,
      required this.appType,
      required this.sensorType});

  factory _$_SpecificRidGeneric.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidGenericFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int appType;
  @override
  final int sensorType;

  @override
  String toString() {
    return 'SpecificRidGeneric(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, appType: $appType, sensorType: $sensorType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidGeneric &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality()
                    .equals(other.appType, appType)) &&
            (identical(other.sensorType, sensorType) ||
                const DeepCollectionEquality()
                    .equals(other.sensorType, sensorType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(appType) ^
      const DeepCollectionEquality().hash(sensorType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidGenericCopyWith<_SpecificRidGeneric> get copyWith =>
      __$SpecificRidGenericCopyWithImpl<_SpecificRidGeneric>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidGenericToJson(this);
  }
}

abstract class _SpecificRidGeneric implements SpecificRidGeneric {
  const factory _SpecificRidGeneric(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int appType,
      required int sensorType}) = _$_SpecificRidGeneric;

  factory _SpecificRidGeneric.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidGeneric.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  int get sensorType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidGenericCopyWith<_SpecificRidGeneric> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidGpsLocation _$SpecificRidGpsLocationFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidGpsLocation.fromJson(json);
}

/// @nodoc
class _$SpecificRidGpsLocationTearOff {
  const _$SpecificRidGpsLocationTearOff();

  _SpecificRidGpsLocation call(
      {required int latitude,
      required int longitude,
      required int uncertainty,
      required int compassDir,
      required int velocity,
      required int timestamp,
      required int appType}) {
    return _SpecificRidGpsLocation(
      latitude: latitude,
      longitude: longitude,
      uncertainty: uncertainty,
      compassDir: compassDir,
      velocity: velocity,
      timestamp: timestamp,
      appType: appType,
    );
  }

  SpecificRidGpsLocation fromJson(Map<String, Object> json) {
    return SpecificRidGpsLocation.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidGpsLocation = _$SpecificRidGpsLocationTearOff();

/// @nodoc
mixin _$SpecificRidGpsLocation {
  int get latitude => throw _privateConstructorUsedError;
  int get longitude => throw _privateConstructorUsedError;
  int get uncertainty => throw _privateConstructorUsedError;
  int get compassDir => throw _privateConstructorUsedError;
  int get velocity => throw _privateConstructorUsedError;
  int get timestamp => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidGpsLocationCopyWith<SpecificRidGpsLocation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidGpsLocationCopyWith<$Res> {
  factory $SpecificRidGpsLocationCopyWith(SpecificRidGpsLocation value,
          $Res Function(SpecificRidGpsLocation) then) =
      _$SpecificRidGpsLocationCopyWithImpl<$Res>;
  $Res call(
      {int latitude,
      int longitude,
      int uncertainty,
      int compassDir,
      int velocity,
      int timestamp,
      int appType});
}

/// @nodoc
class _$SpecificRidGpsLocationCopyWithImpl<$Res>
    implements $SpecificRidGpsLocationCopyWith<$Res> {
  _$SpecificRidGpsLocationCopyWithImpl(this._value, this._then);

  final SpecificRidGpsLocation _value;
  // ignore: unused_field
  final $Res Function(SpecificRidGpsLocation) _then;

  @override
  $Res call({
    Object? latitude = freezed,
    Object? longitude = freezed,
    Object? uncertainty = freezed,
    Object? compassDir = freezed,
    Object? velocity = freezed,
    Object? timestamp = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      latitude: latitude == freezed
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as int,
      longitude: longitude == freezed
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as int,
      uncertainty: uncertainty == freezed
          ? _value.uncertainty
          : uncertainty // ignore: cast_nullable_to_non_nullable
              as int,
      compassDir: compassDir == freezed
          ? _value.compassDir
          : compassDir // ignore: cast_nullable_to_non_nullable
              as int,
      velocity: velocity == freezed
          ? _value.velocity
          : velocity // ignore: cast_nullable_to_non_nullable
              as int,
      timestamp: timestamp == freezed
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidGpsLocationCopyWith<$Res>
    implements $SpecificRidGpsLocationCopyWith<$Res> {
  factory _$SpecificRidGpsLocationCopyWith(_SpecificRidGpsLocation value,
          $Res Function(_SpecificRidGpsLocation) then) =
      __$SpecificRidGpsLocationCopyWithImpl<$Res>;
  @override
  $Res call(
      {int latitude,
      int longitude,
      int uncertainty,
      int compassDir,
      int velocity,
      int timestamp,
      int appType});
}

/// @nodoc
class __$SpecificRidGpsLocationCopyWithImpl<$Res>
    extends _$SpecificRidGpsLocationCopyWithImpl<$Res>
    implements _$SpecificRidGpsLocationCopyWith<$Res> {
  __$SpecificRidGpsLocationCopyWithImpl(_SpecificRidGpsLocation _value,
      $Res Function(_SpecificRidGpsLocation) _then)
      : super(_value, (v) => _then(v as _SpecificRidGpsLocation));

  @override
  _SpecificRidGpsLocation get _value => super._value as _SpecificRidGpsLocation;

  @override
  $Res call({
    Object? latitude = freezed,
    Object? longitude = freezed,
    Object? uncertainty = freezed,
    Object? compassDir = freezed,
    Object? velocity = freezed,
    Object? timestamp = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidGpsLocation(
      latitude: latitude == freezed
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as int,
      longitude: longitude == freezed
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as int,
      uncertainty: uncertainty == freezed
          ? _value.uncertainty
          : uncertainty // ignore: cast_nullable_to_non_nullable
              as int,
      compassDir: compassDir == freezed
          ? _value.compassDir
          : compassDir // ignore: cast_nullable_to_non_nullable
              as int,
      velocity: velocity == freezed
          ? _value.velocity
          : velocity // ignore: cast_nullable_to_non_nullable
              as int,
      timestamp: timestamp == freezed
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidGpsLocation implements _SpecificRidGpsLocation {
  const _$_SpecificRidGpsLocation(
      {required this.latitude,
      required this.longitude,
      required this.uncertainty,
      required this.compassDir,
      required this.velocity,
      required this.timestamp,
      required this.appType});

  factory _$_SpecificRidGpsLocation.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidGpsLocationFromJson(json);

  @override
  final int latitude;
  @override
  final int longitude;
  @override
  final int uncertainty;
  @override
  final int compassDir;
  @override
  final int velocity;
  @override
  final int timestamp;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidGpsLocation(latitude: $latitude, longitude: $longitude, uncertainty: $uncertainty, compassDir: $compassDir, velocity: $velocity, timestamp: $timestamp, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidGpsLocation &&
            (identical(other.latitude, latitude) ||
                const DeepCollectionEquality()
                    .equals(other.latitude, latitude)) &&
            (identical(other.longitude, longitude) ||
                const DeepCollectionEquality()
                    .equals(other.longitude, longitude)) &&
            (identical(other.uncertainty, uncertainty) ||
                const DeepCollectionEquality()
                    .equals(other.uncertainty, uncertainty)) &&
            (identical(other.compassDir, compassDir) ||
                const DeepCollectionEquality()
                    .equals(other.compassDir, compassDir)) &&
            (identical(other.velocity, velocity) ||
                const DeepCollectionEquality()
                    .equals(other.velocity, velocity)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality()
                    .equals(other.timestamp, timestamp)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(latitude) ^
      const DeepCollectionEquality().hash(longitude) ^
      const DeepCollectionEquality().hash(uncertainty) ^
      const DeepCollectionEquality().hash(compassDir) ^
      const DeepCollectionEquality().hash(velocity) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidGpsLocationCopyWith<_SpecificRidGpsLocation> get copyWith =>
      __$SpecificRidGpsLocationCopyWithImpl<_SpecificRidGpsLocation>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidGpsLocationToJson(this);
  }
}

abstract class _SpecificRidGpsLocation implements SpecificRidGpsLocation {
  const factory _SpecificRidGpsLocation(
      {required int latitude,
      required int longitude,
      required int uncertainty,
      required int compassDir,
      required int velocity,
      required int timestamp,
      required int appType}) = _$_SpecificRidGpsLocation;

  factory _SpecificRidGpsLocation.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidGpsLocation.fromJson;

  @override
  int get latitude => throw _privateConstructorUsedError;
  @override
  int get longitude => throw _privateConstructorUsedError;
  @override
  int get uncertainty => throw _privateConstructorUsedError;
  @override
  int get compassDir => throw _privateConstructorUsedError;
  @override
  int get velocity => throw _privateConstructorUsedError;
  @override
  int get timestamp => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidGpsLocationCopyWith<_SpecificRidGpsLocation> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidGyrometer _$SpecificRidGyrometerFromJson(Map<String, dynamic> json) {
  return _SpecificRidGyrometer.fromJson(json);
}

/// @nodoc
class _$SpecificRidGyrometerTearOff {
  const _$SpecificRidGyrometerTearOff();

  _SpecificRidGyrometer call(
      {required int units,
      required int xValue,
      required int yValue,
      required int zValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int minXValue,
      required int maxXValue,
      required int minYValue,
      required int maxYValue,
      required int minZValue,
      required int maxZValue,
      required int resetMinMaxMeaValues,
      required int appType}) {
    return _SpecificRidGyrometer(
      units: units,
      xValue: xValue,
      yValue: yValue,
      zValue: zValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      minXValue: minXValue,
      maxXValue: maxXValue,
      minYValue: minYValue,
      maxYValue: maxYValue,
      minZValue: minZValue,
      maxZValue: maxZValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      appType: appType,
    );
  }

  SpecificRidGyrometer fromJson(Map<String, Object> json) {
    return SpecificRidGyrometer.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidGyrometer = _$SpecificRidGyrometerTearOff();

/// @nodoc
mixin _$SpecificRidGyrometer {
  int get units => throw _privateConstructorUsedError;
  int get xValue => throw _privateConstructorUsedError;
  int get yValue => throw _privateConstructorUsedError;
  int get zValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get minXValue => throw _privateConstructorUsedError;
  int get maxXValue => throw _privateConstructorUsedError;
  int get minYValue => throw _privateConstructorUsedError;
  int get maxYValue => throw _privateConstructorUsedError;
  int get minZValue => throw _privateConstructorUsedError;
  int get maxZValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidGyrometerCopyWith<SpecificRidGyrometer> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidGyrometerCopyWith<$Res> {
  factory $SpecificRidGyrometerCopyWith(SpecificRidGyrometer value,
          $Res Function(SpecificRidGyrometer) then) =
      _$SpecificRidGyrometerCopyWithImpl<$Res>;
  $Res call(
      {int units,
      int xValue,
      int yValue,
      int zValue,
      int minRangeValue,
      int maxRangeValue,
      int minXValue,
      int maxXValue,
      int minYValue,
      int maxYValue,
      int minZValue,
      int maxZValue,
      int resetMinMaxMeaValues,
      int appType});
}

/// @nodoc
class _$SpecificRidGyrometerCopyWithImpl<$Res>
    implements $SpecificRidGyrometerCopyWith<$Res> {
  _$SpecificRidGyrometerCopyWithImpl(this._value, this._then);

  final SpecificRidGyrometer _value;
  // ignore: unused_field
  final $Res Function(SpecificRidGyrometer) _then;

  @override
  $Res call({
    Object? units = freezed,
    Object? xValue = freezed,
    Object? yValue = freezed,
    Object? zValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? minXValue = freezed,
    Object? maxXValue = freezed,
    Object? minYValue = freezed,
    Object? maxYValue = freezed,
    Object? minZValue = freezed,
    Object? maxZValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      xValue: xValue == freezed
          ? _value.xValue
          : xValue // ignore: cast_nullable_to_non_nullable
              as int,
      yValue: yValue == freezed
          ? _value.yValue
          : yValue // ignore: cast_nullable_to_non_nullable
              as int,
      zValue: zValue == freezed
          ? _value.zValue
          : zValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      minXValue: minXValue == freezed
          ? _value.minXValue
          : minXValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxXValue: maxXValue == freezed
          ? _value.maxXValue
          : maxXValue // ignore: cast_nullable_to_non_nullable
              as int,
      minYValue: minYValue == freezed
          ? _value.minYValue
          : minYValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxYValue: maxYValue == freezed
          ? _value.maxYValue
          : maxYValue // ignore: cast_nullable_to_non_nullable
              as int,
      minZValue: minZValue == freezed
          ? _value.minZValue
          : minZValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxZValue: maxZValue == freezed
          ? _value.maxZValue
          : maxZValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidGyrometerCopyWith<$Res>
    implements $SpecificRidGyrometerCopyWith<$Res> {
  factory _$SpecificRidGyrometerCopyWith(_SpecificRidGyrometer value,
          $Res Function(_SpecificRidGyrometer) then) =
      __$SpecificRidGyrometerCopyWithImpl<$Res>;
  @override
  $Res call(
      {int units,
      int xValue,
      int yValue,
      int zValue,
      int minRangeValue,
      int maxRangeValue,
      int minXValue,
      int maxXValue,
      int minYValue,
      int maxYValue,
      int minZValue,
      int maxZValue,
      int resetMinMaxMeaValues,
      int appType});
}

/// @nodoc
class __$SpecificRidGyrometerCopyWithImpl<$Res>
    extends _$SpecificRidGyrometerCopyWithImpl<$Res>
    implements _$SpecificRidGyrometerCopyWith<$Res> {
  __$SpecificRidGyrometerCopyWithImpl(
      _SpecificRidGyrometer _value, $Res Function(_SpecificRidGyrometer) _then)
      : super(_value, (v) => _then(v as _SpecificRidGyrometer));

  @override
  _SpecificRidGyrometer get _value => super._value as _SpecificRidGyrometer;

  @override
  $Res call({
    Object? units = freezed,
    Object? xValue = freezed,
    Object? yValue = freezed,
    Object? zValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? minXValue = freezed,
    Object? maxXValue = freezed,
    Object? minYValue = freezed,
    Object? maxYValue = freezed,
    Object? minZValue = freezed,
    Object? maxZValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidGyrometer(
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      xValue: xValue == freezed
          ? _value.xValue
          : xValue // ignore: cast_nullable_to_non_nullable
              as int,
      yValue: yValue == freezed
          ? _value.yValue
          : yValue // ignore: cast_nullable_to_non_nullable
              as int,
      zValue: zValue == freezed
          ? _value.zValue
          : zValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      minXValue: minXValue == freezed
          ? _value.minXValue
          : minXValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxXValue: maxXValue == freezed
          ? _value.maxXValue
          : maxXValue // ignore: cast_nullable_to_non_nullable
              as int,
      minYValue: minYValue == freezed
          ? _value.minYValue
          : minYValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxYValue: maxYValue == freezed
          ? _value.maxYValue
          : maxYValue // ignore: cast_nullable_to_non_nullable
              as int,
      minZValue: minZValue == freezed
          ? _value.minZValue
          : minZValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxZValue: maxZValue == freezed
          ? _value.maxZValue
          : maxZValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidGyrometer implements _SpecificRidGyrometer {
  const _$_SpecificRidGyrometer(
      {required this.units,
      required this.xValue,
      required this.yValue,
      required this.zValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.minXValue,
      required this.maxXValue,
      required this.minYValue,
      required this.maxYValue,
      required this.minZValue,
      required this.maxZValue,
      required this.resetMinMaxMeaValues,
      required this.appType});

  factory _$_SpecificRidGyrometer.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidGyrometerFromJson(json);

  @override
  final int units;
  @override
  final int xValue;
  @override
  final int yValue;
  @override
  final int zValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int minXValue;
  @override
  final int maxXValue;
  @override
  final int minYValue;
  @override
  final int maxYValue;
  @override
  final int minZValue;
  @override
  final int maxZValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidGyrometer(units: $units, xValue: $xValue, yValue: $yValue, zValue: $zValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, minXValue: $minXValue, maxXValue: $maxXValue, minYValue: $minYValue, maxYValue: $maxYValue, minZValue: $minZValue, maxZValue: $maxZValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidGyrometer &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.xValue, xValue) ||
                const DeepCollectionEquality().equals(other.xValue, xValue)) &&
            (identical(other.yValue, yValue) ||
                const DeepCollectionEquality().equals(other.yValue, yValue)) &&
            (identical(other.zValue, zValue) ||
                const DeepCollectionEquality().equals(other.zValue, zValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.minXValue, minXValue) ||
                const DeepCollectionEquality()
                    .equals(other.minXValue, minXValue)) &&
            (identical(other.maxXValue, maxXValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxXValue, maxXValue)) &&
            (identical(other.minYValue, minYValue) ||
                const DeepCollectionEquality()
                    .equals(other.minYValue, minYValue)) &&
            (identical(other.maxYValue, maxYValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxYValue, maxYValue)) &&
            (identical(other.minZValue, minZValue) ||
                const DeepCollectionEquality()
                    .equals(other.minZValue, minZValue)) &&
            (identical(other.maxZValue, maxZValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxZValue, maxZValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(xValue) ^
      const DeepCollectionEquality().hash(yValue) ^
      const DeepCollectionEquality().hash(zValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(minXValue) ^
      const DeepCollectionEquality().hash(maxXValue) ^
      const DeepCollectionEquality().hash(minYValue) ^
      const DeepCollectionEquality().hash(maxYValue) ^
      const DeepCollectionEquality().hash(minZValue) ^
      const DeepCollectionEquality().hash(maxZValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidGyrometerCopyWith<_SpecificRidGyrometer> get copyWith =>
      __$SpecificRidGyrometerCopyWithImpl<_SpecificRidGyrometer>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidGyrometerToJson(this);
  }
}

abstract class _SpecificRidGyrometer implements SpecificRidGyrometer {
  const factory _SpecificRidGyrometer(
      {required int units,
      required int xValue,
      required int yValue,
      required int zValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int minXValue,
      required int maxXValue,
      required int minYValue,
      required int maxYValue,
      required int minZValue,
      required int maxZValue,
      required int resetMinMaxMeaValues,
      required int appType}) = _$_SpecificRidGyrometer;

  factory _SpecificRidGyrometer.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidGyrometer.fromJson;

  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get xValue => throw _privateConstructorUsedError;
  @override
  int get yValue => throw _privateConstructorUsedError;
  @override
  int get zValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get minXValue => throw _privateConstructorUsedError;
  @override
  int get maxXValue => throw _privateConstructorUsedError;
  @override
  int get minYValue => throw _privateConstructorUsedError;
  @override
  int get maxYValue => throw _privateConstructorUsedError;
  @override
  int get minZValue => throw _privateConstructorUsedError;
  @override
  int get maxZValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidGyrometerCopyWith<_SpecificRidGyrometer> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidHumidity _$SpecificRidHumidityFromJson(Map<String, dynamic> json) {
  return _SpecificRidHumidity.fromJson(json);
}

/// @nodoc
class _$SpecificRidHumidityTearOff {
  const _$SpecificRidHumidityTearOff();

  _SpecificRidHumidity call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues}) {
    return _SpecificRidHumidity(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
    );
  }

  SpecificRidHumidity fromJson(Map<String, Object> json) {
    return SpecificRidHumidity.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidHumidity = _$SpecificRidHumidityTearOff();

/// @nodoc
mixin _$SpecificRidHumidity {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidHumidityCopyWith<SpecificRidHumidity> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidHumidityCopyWith<$Res> {
  factory $SpecificRidHumidityCopyWith(
          SpecificRidHumidity value, $Res Function(SpecificRidHumidity) then) =
      _$SpecificRidHumidityCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues});
}

/// @nodoc
class _$SpecificRidHumidityCopyWithImpl<$Res>
    implements $SpecificRidHumidityCopyWith<$Res> {
  _$SpecificRidHumidityCopyWithImpl(this._value, this._then);

  final SpecificRidHumidity _value;
  // ignore: unused_field
  final $Res Function(SpecificRidHumidity) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidHumidityCopyWith<$Res>
    implements $SpecificRidHumidityCopyWith<$Res> {
  factory _$SpecificRidHumidityCopyWith(_SpecificRidHumidity value,
          $Res Function(_SpecificRidHumidity) then) =
      __$SpecificRidHumidityCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues});
}

/// @nodoc
class __$SpecificRidHumidityCopyWithImpl<$Res>
    extends _$SpecificRidHumidityCopyWithImpl<$Res>
    implements _$SpecificRidHumidityCopyWith<$Res> {
  __$SpecificRidHumidityCopyWithImpl(
      _SpecificRidHumidity _value, $Res Function(_SpecificRidHumidity) _then)
      : super(_value, (v) => _then(v as _SpecificRidHumidity));

  @override
  _SpecificRidHumidity get _value => super._value as _SpecificRidHumidity;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
  }) {
    return _then(_SpecificRidHumidity(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidHumidity implements _SpecificRidHumidity {
  const _$_SpecificRidHumidity(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues});

  factory _$_SpecificRidHumidity.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidHumidityFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;

  @override
  String toString() {
    return 'SpecificRidHumidity(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidHumidity &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality()
                    .equals(other.resetMinMaxMeaValues, resetMinMaxMeaValues)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidHumidityCopyWith<_SpecificRidHumidity> get copyWith =>
      __$SpecificRidHumidityCopyWithImpl<_SpecificRidHumidity>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidHumidityToJson(this);
  }
}

abstract class _SpecificRidHumidity implements SpecificRidHumidity {
  const factory _SpecificRidHumidity(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues}) = _$_SpecificRidHumidity;

  factory _SpecificRidHumidity.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidHumidity.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidHumidityCopyWith<_SpecificRidHumidity> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidIlluminance _$SpecificRidIlluminanceFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidIlluminance.fromJson(json);
}

/// @nodoc
class _$SpecificRidIlluminanceTearOff {
  const _$SpecificRidIlluminanceTearOff();

  _SpecificRidIlluminance call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues}) {
    return _SpecificRidIlluminance(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
    );
  }

  SpecificRidIlluminance fromJson(Map<String, Object> json) {
    return SpecificRidIlluminance.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidIlluminance = _$SpecificRidIlluminanceTearOff();

/// @nodoc
mixin _$SpecificRidIlluminance {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidIlluminanceCopyWith<SpecificRidIlluminance> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidIlluminanceCopyWith<$Res> {
  factory $SpecificRidIlluminanceCopyWith(SpecificRidIlluminance value,
          $Res Function(SpecificRidIlluminance) then) =
      _$SpecificRidIlluminanceCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues});
}

/// @nodoc
class _$SpecificRidIlluminanceCopyWithImpl<$Res>
    implements $SpecificRidIlluminanceCopyWith<$Res> {
  _$SpecificRidIlluminanceCopyWithImpl(this._value, this._then);

  final SpecificRidIlluminance _value;
  // ignore: unused_field
  final $Res Function(SpecificRidIlluminance) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidIlluminanceCopyWith<$Res>
    implements $SpecificRidIlluminanceCopyWith<$Res> {
  factory _$SpecificRidIlluminanceCopyWith(_SpecificRidIlluminance value,
          $Res Function(_SpecificRidIlluminance) then) =
      __$SpecificRidIlluminanceCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues});
}

/// @nodoc
class __$SpecificRidIlluminanceCopyWithImpl<$Res>
    extends _$SpecificRidIlluminanceCopyWithImpl<$Res>
    implements _$SpecificRidIlluminanceCopyWith<$Res> {
  __$SpecificRidIlluminanceCopyWithImpl(_SpecificRidIlluminance _value,
      $Res Function(_SpecificRidIlluminance) _then)
      : super(_value, (v) => _then(v as _SpecificRidIlluminance));

  @override
  _SpecificRidIlluminance get _value => super._value as _SpecificRidIlluminance;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
  }) {
    return _then(_SpecificRidIlluminance(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidIlluminance implements _SpecificRidIlluminance {
  const _$_SpecificRidIlluminance(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues});

  factory _$_SpecificRidIlluminance.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidIlluminanceFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;

  @override
  String toString() {
    return 'SpecificRidIlluminance(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidIlluminance &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality()
                    .equals(other.resetMinMaxMeaValues, resetMinMaxMeaValues)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidIlluminanceCopyWith<_SpecificRidIlluminance> get copyWith =>
      __$SpecificRidIlluminanceCopyWithImpl<_SpecificRidIlluminance>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidIlluminanceToJson(this);
  }
}

abstract class _SpecificRidIlluminance implements SpecificRidIlluminance {
  const factory _SpecificRidIlluminance(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues}) = _$_SpecificRidIlluminance;

  factory _SpecificRidIlluminance.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidIlluminance.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidIlluminanceCopyWith<_SpecificRidIlluminance> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidLevelControl _$SpecificRidLevelControlFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidLevelControl.fromJson(json);
}

/// @nodoc
class _$SpecificRidLevelControlTearOff {
  const _$SpecificRidLevelControlTearOff();

  _SpecificRidLevelControl call(
      {required int level,
      required int onTime,
      required int offTime,
      required int appType}) {
    return _SpecificRidLevelControl(
      level: level,
      onTime: onTime,
      offTime: offTime,
      appType: appType,
    );
  }

  SpecificRidLevelControl fromJson(Map<String, Object> json) {
    return SpecificRidLevelControl.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidLevelControl = _$SpecificRidLevelControlTearOff();

/// @nodoc
mixin _$SpecificRidLevelControl {
  int get level => throw _privateConstructorUsedError;
  int get onTime => throw _privateConstructorUsedError;
  int get offTime => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidLevelControlCopyWith<SpecificRidLevelControl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidLevelControlCopyWith<$Res> {
  factory $SpecificRidLevelControlCopyWith(SpecificRidLevelControl value,
          $Res Function(SpecificRidLevelControl) then) =
      _$SpecificRidLevelControlCopyWithImpl<$Res>;
  $Res call({int level, int onTime, int offTime, int appType});
}

/// @nodoc
class _$SpecificRidLevelControlCopyWithImpl<$Res>
    implements $SpecificRidLevelControlCopyWith<$Res> {
  _$SpecificRidLevelControlCopyWithImpl(this._value, this._then);

  final SpecificRidLevelControl _value;
  // ignore: unused_field
  final $Res Function(SpecificRidLevelControl) _then;

  @override
  $Res call({
    Object? level = freezed,
    Object? onTime = freezed,
    Object? offTime = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      level: level == freezed
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as int,
      onTime: onTime == freezed
          ? _value.onTime
          : onTime // ignore: cast_nullable_to_non_nullable
              as int,
      offTime: offTime == freezed
          ? _value.offTime
          : offTime // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidLevelControlCopyWith<$Res>
    implements $SpecificRidLevelControlCopyWith<$Res> {
  factory _$SpecificRidLevelControlCopyWith(_SpecificRidLevelControl value,
          $Res Function(_SpecificRidLevelControl) then) =
      __$SpecificRidLevelControlCopyWithImpl<$Res>;
  @override
  $Res call({int level, int onTime, int offTime, int appType});
}

/// @nodoc
class __$SpecificRidLevelControlCopyWithImpl<$Res>
    extends _$SpecificRidLevelControlCopyWithImpl<$Res>
    implements _$SpecificRidLevelControlCopyWith<$Res> {
  __$SpecificRidLevelControlCopyWithImpl(_SpecificRidLevelControl _value,
      $Res Function(_SpecificRidLevelControl) _then)
      : super(_value, (v) => _then(v as _SpecificRidLevelControl));

  @override
  _SpecificRidLevelControl get _value =>
      super._value as _SpecificRidLevelControl;

  @override
  $Res call({
    Object? level = freezed,
    Object? onTime = freezed,
    Object? offTime = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidLevelControl(
      level: level == freezed
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as int,
      onTime: onTime == freezed
          ? _value.onTime
          : onTime // ignore: cast_nullable_to_non_nullable
              as int,
      offTime: offTime == freezed
          ? _value.offTime
          : offTime // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidLevelControl implements _SpecificRidLevelControl {
  const _$_SpecificRidLevelControl(
      {required this.level,
      required this.onTime,
      required this.offTime,
      required this.appType});

  factory _$_SpecificRidLevelControl.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidLevelControlFromJson(json);

  @override
  final int level;
  @override
  final int onTime;
  @override
  final int offTime;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidLevelControl(level: $level, onTime: $onTime, offTime: $offTime, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidLevelControl &&
            (identical(other.level, level) ||
                const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.onTime, onTime) ||
                const DeepCollectionEquality().equals(other.onTime, onTime)) &&
            (identical(other.offTime, offTime) ||
                const DeepCollectionEquality()
                    .equals(other.offTime, offTime)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(onTime) ^
      const DeepCollectionEquality().hash(offTime) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidLevelControlCopyWith<_SpecificRidLevelControl> get copyWith =>
      __$SpecificRidLevelControlCopyWithImpl<_SpecificRidLevelControl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidLevelControlToJson(this);
  }
}

abstract class _SpecificRidLevelControl implements SpecificRidLevelControl {
  const factory _SpecificRidLevelControl(
      {required int level,
      required int onTime,
      required int offTime,
      required int appType}) = _$_SpecificRidLevelControl;

  factory _SpecificRidLevelControl.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidLevelControl.fromJson;

  @override
  int get level => throw _privateConstructorUsedError;
  @override
  int get onTime => throw _privateConstructorUsedError;
  @override
  int get offTime => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidLevelControlCopyWith<_SpecificRidLevelControl> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidLightCtrl _$SpecificRidLightCtrlFromJson(Map<String, dynamic> json) {
  return _SpecificRidLightCtrl.fromJson(json);
}

/// @nodoc
class _$SpecificRidLightCtrlTearOff {
  const _$SpecificRidLightCtrlTearOff();

  _SpecificRidLightCtrl call(
      {required int onOff,
      required int dimmer,
      required int colour,
      required int units,
      required int onTime,
      required int cumulActivePwr,
      required int pwrFactor}) {
    return _SpecificRidLightCtrl(
      onOff: onOff,
      dimmer: dimmer,
      colour: colour,
      units: units,
      onTime: onTime,
      cumulActivePwr: cumulActivePwr,
      pwrFactor: pwrFactor,
    );
  }

  SpecificRidLightCtrl fromJson(Map<String, Object> json) {
    return SpecificRidLightCtrl.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidLightCtrl = _$SpecificRidLightCtrlTearOff();

/// @nodoc
mixin _$SpecificRidLightCtrl {
  int get onOff => throw _privateConstructorUsedError;
  int get dimmer => throw _privateConstructorUsedError;
  int get colour => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get onTime => throw _privateConstructorUsedError;
  int get cumulActivePwr => throw _privateConstructorUsedError;
  int get pwrFactor => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidLightCtrlCopyWith<SpecificRidLightCtrl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidLightCtrlCopyWith<$Res> {
  factory $SpecificRidLightCtrlCopyWith(SpecificRidLightCtrl value,
          $Res Function(SpecificRidLightCtrl) then) =
      _$SpecificRidLightCtrlCopyWithImpl<$Res>;
  $Res call(
      {int onOff,
      int dimmer,
      int colour,
      int units,
      int onTime,
      int cumulActivePwr,
      int pwrFactor});
}

/// @nodoc
class _$SpecificRidLightCtrlCopyWithImpl<$Res>
    implements $SpecificRidLightCtrlCopyWith<$Res> {
  _$SpecificRidLightCtrlCopyWithImpl(this._value, this._then);

  final SpecificRidLightCtrl _value;
  // ignore: unused_field
  final $Res Function(SpecificRidLightCtrl) _then;

  @override
  $Res call({
    Object? onOff = freezed,
    Object? dimmer = freezed,
    Object? colour = freezed,
    Object? units = freezed,
    Object? onTime = freezed,
    Object? cumulActivePwr = freezed,
    Object? pwrFactor = freezed,
  }) {
    return _then(_value.copyWith(
      onOff: onOff == freezed
          ? _value.onOff
          : onOff // ignore: cast_nullable_to_non_nullable
              as int,
      dimmer: dimmer == freezed
          ? _value.dimmer
          : dimmer // ignore: cast_nullable_to_non_nullable
              as int,
      colour: colour == freezed
          ? _value.colour
          : colour // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      onTime: onTime == freezed
          ? _value.onTime
          : onTime // ignore: cast_nullable_to_non_nullable
              as int,
      cumulActivePwr: cumulActivePwr == freezed
          ? _value.cumulActivePwr
          : cumulActivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      pwrFactor: pwrFactor == freezed
          ? _value.pwrFactor
          : pwrFactor // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidLightCtrlCopyWith<$Res>
    implements $SpecificRidLightCtrlCopyWith<$Res> {
  factory _$SpecificRidLightCtrlCopyWith(_SpecificRidLightCtrl value,
          $Res Function(_SpecificRidLightCtrl) then) =
      __$SpecificRidLightCtrlCopyWithImpl<$Res>;
  @override
  $Res call(
      {int onOff,
      int dimmer,
      int colour,
      int units,
      int onTime,
      int cumulActivePwr,
      int pwrFactor});
}

/// @nodoc
class __$SpecificRidLightCtrlCopyWithImpl<$Res>
    extends _$SpecificRidLightCtrlCopyWithImpl<$Res>
    implements _$SpecificRidLightCtrlCopyWith<$Res> {
  __$SpecificRidLightCtrlCopyWithImpl(
      _SpecificRidLightCtrl _value, $Res Function(_SpecificRidLightCtrl) _then)
      : super(_value, (v) => _then(v as _SpecificRidLightCtrl));

  @override
  _SpecificRidLightCtrl get _value => super._value as _SpecificRidLightCtrl;

  @override
  $Res call({
    Object? onOff = freezed,
    Object? dimmer = freezed,
    Object? colour = freezed,
    Object? units = freezed,
    Object? onTime = freezed,
    Object? cumulActivePwr = freezed,
    Object? pwrFactor = freezed,
  }) {
    return _then(_SpecificRidLightCtrl(
      onOff: onOff == freezed
          ? _value.onOff
          : onOff // ignore: cast_nullable_to_non_nullable
              as int,
      dimmer: dimmer == freezed
          ? _value.dimmer
          : dimmer // ignore: cast_nullable_to_non_nullable
              as int,
      colour: colour == freezed
          ? _value.colour
          : colour // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      onTime: onTime == freezed
          ? _value.onTime
          : onTime // ignore: cast_nullable_to_non_nullable
              as int,
      cumulActivePwr: cumulActivePwr == freezed
          ? _value.cumulActivePwr
          : cumulActivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      pwrFactor: pwrFactor == freezed
          ? _value.pwrFactor
          : pwrFactor // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidLightCtrl implements _SpecificRidLightCtrl {
  const _$_SpecificRidLightCtrl(
      {required this.onOff,
      required this.dimmer,
      required this.colour,
      required this.units,
      required this.onTime,
      required this.cumulActivePwr,
      required this.pwrFactor});

  factory _$_SpecificRidLightCtrl.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidLightCtrlFromJson(json);

  @override
  final int onOff;
  @override
  final int dimmer;
  @override
  final int colour;
  @override
  final int units;
  @override
  final int onTime;
  @override
  final int cumulActivePwr;
  @override
  final int pwrFactor;

  @override
  String toString() {
    return 'SpecificRidLightCtrl(onOff: $onOff, dimmer: $dimmer, colour: $colour, units: $units, onTime: $onTime, cumulActivePwr: $cumulActivePwr, pwrFactor: $pwrFactor)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidLightCtrl &&
            (identical(other.onOff, onOff) ||
                const DeepCollectionEquality().equals(other.onOff, onOff)) &&
            (identical(other.dimmer, dimmer) ||
                const DeepCollectionEquality().equals(other.dimmer, dimmer)) &&
            (identical(other.colour, colour) ||
                const DeepCollectionEquality().equals(other.colour, colour)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.onTime, onTime) ||
                const DeepCollectionEquality().equals(other.onTime, onTime)) &&
            (identical(other.cumulActivePwr, cumulActivePwr) ||
                const DeepCollectionEquality()
                    .equals(other.cumulActivePwr, cumulActivePwr)) &&
            (identical(other.pwrFactor, pwrFactor) ||
                const DeepCollectionEquality()
                    .equals(other.pwrFactor, pwrFactor)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(onOff) ^
      const DeepCollectionEquality().hash(dimmer) ^
      const DeepCollectionEquality().hash(colour) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(onTime) ^
      const DeepCollectionEquality().hash(cumulActivePwr) ^
      const DeepCollectionEquality().hash(pwrFactor);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidLightCtrlCopyWith<_SpecificRidLightCtrl> get copyWith =>
      __$SpecificRidLightCtrlCopyWithImpl<_SpecificRidLightCtrl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidLightCtrlToJson(this);
  }
}

abstract class _SpecificRidLightCtrl implements SpecificRidLightCtrl {
  const factory _SpecificRidLightCtrl(
      {required int onOff,
      required int dimmer,
      required int colour,
      required int units,
      required int onTime,
      required int cumulActivePwr,
      required int pwrFactor}) = _$_SpecificRidLightCtrl;

  factory _SpecificRidLightCtrl.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidLightCtrl.fromJson;

  @override
  int get onOff => throw _privateConstructorUsedError;
  @override
  int get dimmer => throw _privateConstructorUsedError;
  @override
  int get colour => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get onTime => throw _privateConstructorUsedError;
  @override
  int get cumulActivePwr => throw _privateConstructorUsedError;
  @override
  int get pwrFactor => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidLightCtrlCopyWith<_SpecificRidLightCtrl> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidLoad _$SpecificRidLoadFromJson(Map<String, dynamic> json) {
  return _SpecificRidLoad.fromJson(json);
}

/// @nodoc
class _$SpecificRidLoadTearOff {
  const _$SpecificRidLoadTearOff();

  _SpecificRidLoad call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) {
    return _SpecificRidLoad(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      calOffset: calOffset,
      appType: appType,
    );
  }

  SpecificRidLoad fromJson(Map<String, Object> json) {
    return SpecificRidLoad.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidLoad = _$SpecificRidLoadTearOff();

/// @nodoc
mixin _$SpecificRidLoad {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get calOffset => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidLoadCopyWith<SpecificRidLoad> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidLoadCopyWith<$Res> {
  factory $SpecificRidLoadCopyWith(
          SpecificRidLoad value, $Res Function(SpecificRidLoad) then) =
      _$SpecificRidLoadCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class _$SpecificRidLoadCopyWithImpl<$Res>
    implements $SpecificRidLoadCopyWith<$Res> {
  _$SpecificRidLoadCopyWithImpl(this._value, this._then);

  final SpecificRidLoad _value;
  // ignore: unused_field
  final $Res Function(SpecificRidLoad) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidLoadCopyWith<$Res>
    implements $SpecificRidLoadCopyWith<$Res> {
  factory _$SpecificRidLoadCopyWith(
          _SpecificRidLoad value, $Res Function(_SpecificRidLoad) then) =
      __$SpecificRidLoadCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class __$SpecificRidLoadCopyWithImpl<$Res>
    extends _$SpecificRidLoadCopyWithImpl<$Res>
    implements _$SpecificRidLoadCopyWith<$Res> {
  __$SpecificRidLoadCopyWithImpl(
      _SpecificRidLoad _value, $Res Function(_SpecificRidLoad) _then)
      : super(_value, (v) => _then(v as _SpecificRidLoad));

  @override
  _SpecificRidLoad get _value => super._value as _SpecificRidLoad;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidLoad(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidLoad implements _SpecificRidLoad {
  const _$_SpecificRidLoad(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues,
      required this.calOffset,
      required this.appType});

  factory _$_SpecificRidLoad.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidLoadFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int calOffset;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidLoad(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, calOffset: $calOffset, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidLoad &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.calOffset, calOffset) ||
                const DeepCollectionEquality()
                    .equals(other.calOffset, calOffset)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(calOffset) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidLoadCopyWith<_SpecificRidLoad> get copyWith =>
      __$SpecificRidLoadCopyWithImpl<_SpecificRidLoad>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidLoadToJson(this);
  }
}

abstract class _SpecificRidLoad implements SpecificRidLoad {
  const factory _SpecificRidLoad(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) = _$_SpecificRidLoad;

  factory _SpecificRidLoad.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidLoad.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get calOffset => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidLoadCopyWith<_SpecificRidLoad> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidLoadCtrl _$SpecificRidLoadCtrlFromJson(Map<String, dynamic> json) {
  return _SpecificRidLoadCtrl.fromJson(json);
}

/// @nodoc
class _$SpecificRidLoadCtrlTearOff {
  const _$SpecificRidLoadCtrlTearOff();

  _SpecificRidLoadCtrl call(
      {required int eventId,
      required int startTime,
      required int durationInMin,
      required int criticalLevel,
      required int avgLoadAdjPct,
      required int dutyCycle}) {
    return _SpecificRidLoadCtrl(
      eventId: eventId,
      startTime: startTime,
      durationInMin: durationInMin,
      criticalLevel: criticalLevel,
      avgLoadAdjPct: avgLoadAdjPct,
      dutyCycle: dutyCycle,
    );
  }

  SpecificRidLoadCtrl fromJson(Map<String, Object> json) {
    return SpecificRidLoadCtrl.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidLoadCtrl = _$SpecificRidLoadCtrlTearOff();

/// @nodoc
mixin _$SpecificRidLoadCtrl {
  int get eventId => throw _privateConstructorUsedError;
  int get startTime => throw _privateConstructorUsedError;
  int get durationInMin => throw _privateConstructorUsedError;
  int get criticalLevel => throw _privateConstructorUsedError;
  int get avgLoadAdjPct => throw _privateConstructorUsedError;
  int get dutyCycle => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidLoadCtrlCopyWith<SpecificRidLoadCtrl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidLoadCtrlCopyWith<$Res> {
  factory $SpecificRidLoadCtrlCopyWith(
          SpecificRidLoadCtrl value, $Res Function(SpecificRidLoadCtrl) then) =
      _$SpecificRidLoadCtrlCopyWithImpl<$Res>;
  $Res call(
      {int eventId,
      int startTime,
      int durationInMin,
      int criticalLevel,
      int avgLoadAdjPct,
      int dutyCycle});
}

/// @nodoc
class _$SpecificRidLoadCtrlCopyWithImpl<$Res>
    implements $SpecificRidLoadCtrlCopyWith<$Res> {
  _$SpecificRidLoadCtrlCopyWithImpl(this._value, this._then);

  final SpecificRidLoadCtrl _value;
  // ignore: unused_field
  final $Res Function(SpecificRidLoadCtrl) _then;

  @override
  $Res call({
    Object? eventId = freezed,
    Object? startTime = freezed,
    Object? durationInMin = freezed,
    Object? criticalLevel = freezed,
    Object? avgLoadAdjPct = freezed,
    Object? dutyCycle = freezed,
  }) {
    return _then(_value.copyWith(
      eventId: eventId == freezed
          ? _value.eventId
          : eventId // ignore: cast_nullable_to_non_nullable
              as int,
      startTime: startTime == freezed
          ? _value.startTime
          : startTime // ignore: cast_nullable_to_non_nullable
              as int,
      durationInMin: durationInMin == freezed
          ? _value.durationInMin
          : durationInMin // ignore: cast_nullable_to_non_nullable
              as int,
      criticalLevel: criticalLevel == freezed
          ? _value.criticalLevel
          : criticalLevel // ignore: cast_nullable_to_non_nullable
              as int,
      avgLoadAdjPct: avgLoadAdjPct == freezed
          ? _value.avgLoadAdjPct
          : avgLoadAdjPct // ignore: cast_nullable_to_non_nullable
              as int,
      dutyCycle: dutyCycle == freezed
          ? _value.dutyCycle
          : dutyCycle // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidLoadCtrlCopyWith<$Res>
    implements $SpecificRidLoadCtrlCopyWith<$Res> {
  factory _$SpecificRidLoadCtrlCopyWith(_SpecificRidLoadCtrl value,
          $Res Function(_SpecificRidLoadCtrl) then) =
      __$SpecificRidLoadCtrlCopyWithImpl<$Res>;
  @override
  $Res call(
      {int eventId,
      int startTime,
      int durationInMin,
      int criticalLevel,
      int avgLoadAdjPct,
      int dutyCycle});
}

/// @nodoc
class __$SpecificRidLoadCtrlCopyWithImpl<$Res>
    extends _$SpecificRidLoadCtrlCopyWithImpl<$Res>
    implements _$SpecificRidLoadCtrlCopyWith<$Res> {
  __$SpecificRidLoadCtrlCopyWithImpl(
      _SpecificRidLoadCtrl _value, $Res Function(_SpecificRidLoadCtrl) _then)
      : super(_value, (v) => _then(v as _SpecificRidLoadCtrl));

  @override
  _SpecificRidLoadCtrl get _value => super._value as _SpecificRidLoadCtrl;

  @override
  $Res call({
    Object? eventId = freezed,
    Object? startTime = freezed,
    Object? durationInMin = freezed,
    Object? criticalLevel = freezed,
    Object? avgLoadAdjPct = freezed,
    Object? dutyCycle = freezed,
  }) {
    return _then(_SpecificRidLoadCtrl(
      eventId: eventId == freezed
          ? _value.eventId
          : eventId // ignore: cast_nullable_to_non_nullable
              as int,
      startTime: startTime == freezed
          ? _value.startTime
          : startTime // ignore: cast_nullable_to_non_nullable
              as int,
      durationInMin: durationInMin == freezed
          ? _value.durationInMin
          : durationInMin // ignore: cast_nullable_to_non_nullable
              as int,
      criticalLevel: criticalLevel == freezed
          ? _value.criticalLevel
          : criticalLevel // ignore: cast_nullable_to_non_nullable
              as int,
      avgLoadAdjPct: avgLoadAdjPct == freezed
          ? _value.avgLoadAdjPct
          : avgLoadAdjPct // ignore: cast_nullable_to_non_nullable
              as int,
      dutyCycle: dutyCycle == freezed
          ? _value.dutyCycle
          : dutyCycle // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidLoadCtrl implements _SpecificRidLoadCtrl {
  const _$_SpecificRidLoadCtrl(
      {required this.eventId,
      required this.startTime,
      required this.durationInMin,
      required this.criticalLevel,
      required this.avgLoadAdjPct,
      required this.dutyCycle});

  factory _$_SpecificRidLoadCtrl.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidLoadCtrlFromJson(json);

  @override
  final int eventId;
  @override
  final int startTime;
  @override
  final int durationInMin;
  @override
  final int criticalLevel;
  @override
  final int avgLoadAdjPct;
  @override
  final int dutyCycle;

  @override
  String toString() {
    return 'SpecificRidLoadCtrl(eventId: $eventId, startTime: $startTime, durationInMin: $durationInMin, criticalLevel: $criticalLevel, avgLoadAdjPct: $avgLoadAdjPct, dutyCycle: $dutyCycle)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidLoadCtrl &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality()
                    .equals(other.eventId, eventId)) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality()
                    .equals(other.startTime, startTime)) &&
            (identical(other.durationInMin, durationInMin) ||
                const DeepCollectionEquality()
                    .equals(other.durationInMin, durationInMin)) &&
            (identical(other.criticalLevel, criticalLevel) ||
                const DeepCollectionEquality()
                    .equals(other.criticalLevel, criticalLevel)) &&
            (identical(other.avgLoadAdjPct, avgLoadAdjPct) ||
                const DeepCollectionEquality()
                    .equals(other.avgLoadAdjPct, avgLoadAdjPct)) &&
            (identical(other.dutyCycle, dutyCycle) ||
                const DeepCollectionEquality()
                    .equals(other.dutyCycle, dutyCycle)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(durationInMin) ^
      const DeepCollectionEquality().hash(criticalLevel) ^
      const DeepCollectionEquality().hash(avgLoadAdjPct) ^
      const DeepCollectionEquality().hash(dutyCycle);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidLoadCtrlCopyWith<_SpecificRidLoadCtrl> get copyWith =>
      __$SpecificRidLoadCtrlCopyWithImpl<_SpecificRidLoadCtrl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidLoadCtrlToJson(this);
  }
}

abstract class _SpecificRidLoadCtrl implements SpecificRidLoadCtrl {
  const factory _SpecificRidLoadCtrl(
      {required int eventId,
      required int startTime,
      required int durationInMin,
      required int criticalLevel,
      required int avgLoadAdjPct,
      required int dutyCycle}) = _$_SpecificRidLoadCtrl;

  factory _SpecificRidLoadCtrl.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidLoadCtrl.fromJson;

  @override
  int get eventId => throw _privateConstructorUsedError;
  @override
  int get startTime => throw _privateConstructorUsedError;
  @override
  int get durationInMin => throw _privateConstructorUsedError;
  @override
  int get criticalLevel => throw _privateConstructorUsedError;
  @override
  int get avgLoadAdjPct => throw _privateConstructorUsedError;
  @override
  int get dutyCycle => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidLoadCtrlCopyWith<_SpecificRidLoadCtrl> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidLocation _$SpecificRidLocationFromJson(Map<String, dynamic> json) {
  return _SpecificRidLocation.fromJson(json);
}

/// @nodoc
class _$SpecificRidLocationTearOff {
  const _$SpecificRidLocationTearOff();

  _SpecificRidLocation call(
      {required int lat,
      required int lon,
      required int alt,
      required int radius,
      required int velocity,
      required int timestamp,
      required int speed}) {
    return _SpecificRidLocation(
      lat: lat,
      lon: lon,
      alt: alt,
      radius: radius,
      velocity: velocity,
      timestamp: timestamp,
      speed: speed,
    );
  }

  SpecificRidLocation fromJson(Map<String, Object> json) {
    return SpecificRidLocation.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidLocation = _$SpecificRidLocationTearOff();

/// @nodoc
mixin _$SpecificRidLocation {
  int get lat => throw _privateConstructorUsedError;
  int get lon => throw _privateConstructorUsedError;
  int get alt => throw _privateConstructorUsedError;
  int get radius => throw _privateConstructorUsedError;
  int get velocity => throw _privateConstructorUsedError;
  int get timestamp => throw _privateConstructorUsedError;
  int get speed => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidLocationCopyWith<SpecificRidLocation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidLocationCopyWith<$Res> {
  factory $SpecificRidLocationCopyWith(
          SpecificRidLocation value, $Res Function(SpecificRidLocation) then) =
      _$SpecificRidLocationCopyWithImpl<$Res>;
  $Res call(
      {int lat,
      int lon,
      int alt,
      int radius,
      int velocity,
      int timestamp,
      int speed});
}

/// @nodoc
class _$SpecificRidLocationCopyWithImpl<$Res>
    implements $SpecificRidLocationCopyWith<$Res> {
  _$SpecificRidLocationCopyWithImpl(this._value, this._then);

  final SpecificRidLocation _value;
  // ignore: unused_field
  final $Res Function(SpecificRidLocation) _then;

  @override
  $Res call({
    Object? lat = freezed,
    Object? lon = freezed,
    Object? alt = freezed,
    Object? radius = freezed,
    Object? velocity = freezed,
    Object? timestamp = freezed,
    Object? speed = freezed,
  }) {
    return _then(_value.copyWith(
      lat: lat == freezed
          ? _value.lat
          : lat // ignore: cast_nullable_to_non_nullable
              as int,
      lon: lon == freezed
          ? _value.lon
          : lon // ignore: cast_nullable_to_non_nullable
              as int,
      alt: alt == freezed
          ? _value.alt
          : alt // ignore: cast_nullable_to_non_nullable
              as int,
      radius: radius == freezed
          ? _value.radius
          : radius // ignore: cast_nullable_to_non_nullable
              as int,
      velocity: velocity == freezed
          ? _value.velocity
          : velocity // ignore: cast_nullable_to_non_nullable
              as int,
      timestamp: timestamp == freezed
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as int,
      speed: speed == freezed
          ? _value.speed
          : speed // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidLocationCopyWith<$Res>
    implements $SpecificRidLocationCopyWith<$Res> {
  factory _$SpecificRidLocationCopyWith(_SpecificRidLocation value,
          $Res Function(_SpecificRidLocation) then) =
      __$SpecificRidLocationCopyWithImpl<$Res>;
  @override
  $Res call(
      {int lat,
      int lon,
      int alt,
      int radius,
      int velocity,
      int timestamp,
      int speed});
}

/// @nodoc
class __$SpecificRidLocationCopyWithImpl<$Res>
    extends _$SpecificRidLocationCopyWithImpl<$Res>
    implements _$SpecificRidLocationCopyWith<$Res> {
  __$SpecificRidLocationCopyWithImpl(
      _SpecificRidLocation _value, $Res Function(_SpecificRidLocation) _then)
      : super(_value, (v) => _then(v as _SpecificRidLocation));

  @override
  _SpecificRidLocation get _value => super._value as _SpecificRidLocation;

  @override
  $Res call({
    Object? lat = freezed,
    Object? lon = freezed,
    Object? alt = freezed,
    Object? radius = freezed,
    Object? velocity = freezed,
    Object? timestamp = freezed,
    Object? speed = freezed,
  }) {
    return _then(_SpecificRidLocation(
      lat: lat == freezed
          ? _value.lat
          : lat // ignore: cast_nullable_to_non_nullable
              as int,
      lon: lon == freezed
          ? _value.lon
          : lon // ignore: cast_nullable_to_non_nullable
              as int,
      alt: alt == freezed
          ? _value.alt
          : alt // ignore: cast_nullable_to_non_nullable
              as int,
      radius: radius == freezed
          ? _value.radius
          : radius // ignore: cast_nullable_to_non_nullable
              as int,
      velocity: velocity == freezed
          ? _value.velocity
          : velocity // ignore: cast_nullable_to_non_nullable
              as int,
      timestamp: timestamp == freezed
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as int,
      speed: speed == freezed
          ? _value.speed
          : speed // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidLocation implements _SpecificRidLocation {
  const _$_SpecificRidLocation(
      {required this.lat,
      required this.lon,
      required this.alt,
      required this.radius,
      required this.velocity,
      required this.timestamp,
      required this.speed});

  factory _$_SpecificRidLocation.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidLocationFromJson(json);

  @override
  final int lat;
  @override
  final int lon;
  @override
  final int alt;
  @override
  final int radius;
  @override
  final int velocity;
  @override
  final int timestamp;
  @override
  final int speed;

  @override
  String toString() {
    return 'SpecificRidLocation(lat: $lat, lon: $lon, alt: $alt, radius: $radius, velocity: $velocity, timestamp: $timestamp, speed: $speed)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidLocation &&
            (identical(other.lat, lat) ||
                const DeepCollectionEquality().equals(other.lat, lat)) &&
            (identical(other.lon, lon) ||
                const DeepCollectionEquality().equals(other.lon, lon)) &&
            (identical(other.alt, alt) ||
                const DeepCollectionEquality().equals(other.alt, alt)) &&
            (identical(other.radius, radius) ||
                const DeepCollectionEquality().equals(other.radius, radius)) &&
            (identical(other.velocity, velocity) ||
                const DeepCollectionEquality()
                    .equals(other.velocity, velocity)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality()
                    .equals(other.timestamp, timestamp)) &&
            (identical(other.speed, speed) ||
                const DeepCollectionEquality().equals(other.speed, speed)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(lat) ^
      const DeepCollectionEquality().hash(lon) ^
      const DeepCollectionEquality().hash(alt) ^
      const DeepCollectionEquality().hash(radius) ^
      const DeepCollectionEquality().hash(velocity) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(speed);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidLocationCopyWith<_SpecificRidLocation> get copyWith =>
      __$SpecificRidLocationCopyWithImpl<_SpecificRidLocation>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidLocationToJson(this);
  }
}

abstract class _SpecificRidLocation implements SpecificRidLocation {
  const factory _SpecificRidLocation(
      {required int lat,
      required int lon,
      required int alt,
      required int radius,
      required int velocity,
      required int timestamp,
      required int speed}) = _$_SpecificRidLocation;

  factory _SpecificRidLocation.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidLocation.fromJson;

  @override
  int get lat => throw _privateConstructorUsedError;
  @override
  int get lon => throw _privateConstructorUsedError;
  @override
  int get alt => throw _privateConstructorUsedError;
  @override
  int get radius => throw _privateConstructorUsedError;
  @override
  int get velocity => throw _privateConstructorUsedError;
  @override
  int get timestamp => throw _privateConstructorUsedError;
  @override
  int get speed => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidLocationCopyWith<_SpecificRidLocation> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidLoudness _$SpecificRidLoudnessFromJson(Map<String, dynamic> json) {
  return _SpecificRidLoudness.fromJson(json);
}

/// @nodoc
class _$SpecificRidLoudnessTearOff {
  const _$SpecificRidLoudnessTearOff();

  _SpecificRidLoudness call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) {
    return _SpecificRidLoudness(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      calOffset: calOffset,
      appType: appType,
    );
  }

  SpecificRidLoudness fromJson(Map<String, Object> json) {
    return SpecificRidLoudness.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidLoudness = _$SpecificRidLoudnessTearOff();

/// @nodoc
mixin _$SpecificRidLoudness {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get calOffset => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidLoudnessCopyWith<SpecificRidLoudness> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidLoudnessCopyWith<$Res> {
  factory $SpecificRidLoudnessCopyWith(
          SpecificRidLoudness value, $Res Function(SpecificRidLoudness) then) =
      _$SpecificRidLoudnessCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class _$SpecificRidLoudnessCopyWithImpl<$Res>
    implements $SpecificRidLoudnessCopyWith<$Res> {
  _$SpecificRidLoudnessCopyWithImpl(this._value, this._then);

  final SpecificRidLoudness _value;
  // ignore: unused_field
  final $Res Function(SpecificRidLoudness) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidLoudnessCopyWith<$Res>
    implements $SpecificRidLoudnessCopyWith<$Res> {
  factory _$SpecificRidLoudnessCopyWith(_SpecificRidLoudness value,
          $Res Function(_SpecificRidLoudness) then) =
      __$SpecificRidLoudnessCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class __$SpecificRidLoudnessCopyWithImpl<$Res>
    extends _$SpecificRidLoudnessCopyWithImpl<$Res>
    implements _$SpecificRidLoudnessCopyWith<$Res> {
  __$SpecificRidLoudnessCopyWithImpl(
      _SpecificRidLoudness _value, $Res Function(_SpecificRidLoudness) _then)
      : super(_value, (v) => _then(v as _SpecificRidLoudness));

  @override
  _SpecificRidLoudness get _value => super._value as _SpecificRidLoudness;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidLoudness(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidLoudness implements _SpecificRidLoudness {
  const _$_SpecificRidLoudness(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues,
      required this.calOffset,
      required this.appType});

  factory _$_SpecificRidLoudness.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidLoudnessFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int calOffset;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidLoudness(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, calOffset: $calOffset, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidLoudness &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.calOffset, calOffset) ||
                const DeepCollectionEquality()
                    .equals(other.calOffset, calOffset)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(calOffset) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidLoudnessCopyWith<_SpecificRidLoudness> get copyWith =>
      __$SpecificRidLoudnessCopyWithImpl<_SpecificRidLoudness>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidLoudnessToJson(this);
  }
}

abstract class _SpecificRidLoudness implements SpecificRidLoudness {
  const factory _SpecificRidLoudness(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) = _$_SpecificRidLoudness;

  factory _SpecificRidLoudness.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidLoudness.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get calOffset => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidLoudnessCopyWith<_SpecificRidLoudness> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidLwm2mSecurity _$SpecificRidLwm2mSecurityFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidLwm2mSecurity.fromJson(json);
}

/// @nodoc
class _$SpecificRidLwm2mSecurityTearOff {
  const _$SpecificRidLwm2mSecurityTearOff();

  _SpecificRidLwm2mSecurity call(
      {required int lwm2mServerURI,
      required int bootstrapServer,
      required int securityMode,
      required int pubKeyId,
      required int serverPubKeyId,
      required int secretKey,
      required int smsSecurityMode,
      required int smsBindingKeyParam,
      required int smsBindingSecretKey,
      required int lwm2mServerSmsNum,
      required int shortServerId,
      required int clientHoldOffTime}) {
    return _SpecificRidLwm2mSecurity(
      lwm2mServerURI: lwm2mServerURI,
      bootstrapServer: bootstrapServer,
      securityMode: securityMode,
      pubKeyId: pubKeyId,
      serverPubKeyId: serverPubKeyId,
      secretKey: secretKey,
      smsSecurityMode: smsSecurityMode,
      smsBindingKeyParam: smsBindingKeyParam,
      smsBindingSecretKey: smsBindingSecretKey,
      lwm2mServerSmsNum: lwm2mServerSmsNum,
      shortServerId: shortServerId,
      clientHoldOffTime: clientHoldOffTime,
    );
  }

  SpecificRidLwm2mSecurity fromJson(Map<String, Object> json) {
    return SpecificRidLwm2mSecurity.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidLwm2mSecurity = _$SpecificRidLwm2mSecurityTearOff();

/// @nodoc
mixin _$SpecificRidLwm2mSecurity {
  int get lwm2mServerURI => throw _privateConstructorUsedError;
  int get bootstrapServer => throw _privateConstructorUsedError;
  int get securityMode => throw _privateConstructorUsedError;
  int get pubKeyId => throw _privateConstructorUsedError;
  int get serverPubKeyId => throw _privateConstructorUsedError;
  int get secretKey => throw _privateConstructorUsedError;
  int get smsSecurityMode => throw _privateConstructorUsedError;
  int get smsBindingKeyParam => throw _privateConstructorUsedError;
  int get smsBindingSecretKey => throw _privateConstructorUsedError;
  int get lwm2mServerSmsNum => throw _privateConstructorUsedError;
  int get shortServerId => throw _privateConstructorUsedError;
  int get clientHoldOffTime => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidLwm2mSecurityCopyWith<SpecificRidLwm2mSecurity> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidLwm2mSecurityCopyWith<$Res> {
  factory $SpecificRidLwm2mSecurityCopyWith(SpecificRidLwm2mSecurity value,
          $Res Function(SpecificRidLwm2mSecurity) then) =
      _$SpecificRidLwm2mSecurityCopyWithImpl<$Res>;
  $Res call(
      {int lwm2mServerURI,
      int bootstrapServer,
      int securityMode,
      int pubKeyId,
      int serverPubKeyId,
      int secretKey,
      int smsSecurityMode,
      int smsBindingKeyParam,
      int smsBindingSecretKey,
      int lwm2mServerSmsNum,
      int shortServerId,
      int clientHoldOffTime});
}

/// @nodoc
class _$SpecificRidLwm2mSecurityCopyWithImpl<$Res>
    implements $SpecificRidLwm2mSecurityCopyWith<$Res> {
  _$SpecificRidLwm2mSecurityCopyWithImpl(this._value, this._then);

  final SpecificRidLwm2mSecurity _value;
  // ignore: unused_field
  final $Res Function(SpecificRidLwm2mSecurity) _then;

  @override
  $Res call({
    Object? lwm2mServerURI = freezed,
    Object? bootstrapServer = freezed,
    Object? securityMode = freezed,
    Object? pubKeyId = freezed,
    Object? serverPubKeyId = freezed,
    Object? secretKey = freezed,
    Object? smsSecurityMode = freezed,
    Object? smsBindingKeyParam = freezed,
    Object? smsBindingSecretKey = freezed,
    Object? lwm2mServerSmsNum = freezed,
    Object? shortServerId = freezed,
    Object? clientHoldOffTime = freezed,
  }) {
    return _then(_value.copyWith(
      lwm2mServerURI: lwm2mServerURI == freezed
          ? _value.lwm2mServerURI
          : lwm2mServerURI // ignore: cast_nullable_to_non_nullable
              as int,
      bootstrapServer: bootstrapServer == freezed
          ? _value.bootstrapServer
          : bootstrapServer // ignore: cast_nullable_to_non_nullable
              as int,
      securityMode: securityMode == freezed
          ? _value.securityMode
          : securityMode // ignore: cast_nullable_to_non_nullable
              as int,
      pubKeyId: pubKeyId == freezed
          ? _value.pubKeyId
          : pubKeyId // ignore: cast_nullable_to_non_nullable
              as int,
      serverPubKeyId: serverPubKeyId == freezed
          ? _value.serverPubKeyId
          : serverPubKeyId // ignore: cast_nullable_to_non_nullable
              as int,
      secretKey: secretKey == freezed
          ? _value.secretKey
          : secretKey // ignore: cast_nullable_to_non_nullable
              as int,
      smsSecurityMode: smsSecurityMode == freezed
          ? _value.smsSecurityMode
          : smsSecurityMode // ignore: cast_nullable_to_non_nullable
              as int,
      smsBindingKeyParam: smsBindingKeyParam == freezed
          ? _value.smsBindingKeyParam
          : smsBindingKeyParam // ignore: cast_nullable_to_non_nullable
              as int,
      smsBindingSecretKey: smsBindingSecretKey == freezed
          ? _value.smsBindingSecretKey
          : smsBindingSecretKey // ignore: cast_nullable_to_non_nullable
              as int,
      lwm2mServerSmsNum: lwm2mServerSmsNum == freezed
          ? _value.lwm2mServerSmsNum
          : lwm2mServerSmsNum // ignore: cast_nullable_to_non_nullable
              as int,
      shortServerId: shortServerId == freezed
          ? _value.shortServerId
          : shortServerId // ignore: cast_nullable_to_non_nullable
              as int,
      clientHoldOffTime: clientHoldOffTime == freezed
          ? _value.clientHoldOffTime
          : clientHoldOffTime // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidLwm2mSecurityCopyWith<$Res>
    implements $SpecificRidLwm2mSecurityCopyWith<$Res> {
  factory _$SpecificRidLwm2mSecurityCopyWith(_SpecificRidLwm2mSecurity value,
          $Res Function(_SpecificRidLwm2mSecurity) then) =
      __$SpecificRidLwm2mSecurityCopyWithImpl<$Res>;
  @override
  $Res call(
      {int lwm2mServerURI,
      int bootstrapServer,
      int securityMode,
      int pubKeyId,
      int serverPubKeyId,
      int secretKey,
      int smsSecurityMode,
      int smsBindingKeyParam,
      int smsBindingSecretKey,
      int lwm2mServerSmsNum,
      int shortServerId,
      int clientHoldOffTime});
}

/// @nodoc
class __$SpecificRidLwm2mSecurityCopyWithImpl<$Res>
    extends _$SpecificRidLwm2mSecurityCopyWithImpl<$Res>
    implements _$SpecificRidLwm2mSecurityCopyWith<$Res> {
  __$SpecificRidLwm2mSecurityCopyWithImpl(_SpecificRidLwm2mSecurity _value,
      $Res Function(_SpecificRidLwm2mSecurity) _then)
      : super(_value, (v) => _then(v as _SpecificRidLwm2mSecurity));

  @override
  _SpecificRidLwm2mSecurity get _value =>
      super._value as _SpecificRidLwm2mSecurity;

  @override
  $Res call({
    Object? lwm2mServerURI = freezed,
    Object? bootstrapServer = freezed,
    Object? securityMode = freezed,
    Object? pubKeyId = freezed,
    Object? serverPubKeyId = freezed,
    Object? secretKey = freezed,
    Object? smsSecurityMode = freezed,
    Object? smsBindingKeyParam = freezed,
    Object? smsBindingSecretKey = freezed,
    Object? lwm2mServerSmsNum = freezed,
    Object? shortServerId = freezed,
    Object? clientHoldOffTime = freezed,
  }) {
    return _then(_SpecificRidLwm2mSecurity(
      lwm2mServerURI: lwm2mServerURI == freezed
          ? _value.lwm2mServerURI
          : lwm2mServerURI // ignore: cast_nullable_to_non_nullable
              as int,
      bootstrapServer: bootstrapServer == freezed
          ? _value.bootstrapServer
          : bootstrapServer // ignore: cast_nullable_to_non_nullable
              as int,
      securityMode: securityMode == freezed
          ? _value.securityMode
          : securityMode // ignore: cast_nullable_to_non_nullable
              as int,
      pubKeyId: pubKeyId == freezed
          ? _value.pubKeyId
          : pubKeyId // ignore: cast_nullable_to_non_nullable
              as int,
      serverPubKeyId: serverPubKeyId == freezed
          ? _value.serverPubKeyId
          : serverPubKeyId // ignore: cast_nullable_to_non_nullable
              as int,
      secretKey: secretKey == freezed
          ? _value.secretKey
          : secretKey // ignore: cast_nullable_to_non_nullable
              as int,
      smsSecurityMode: smsSecurityMode == freezed
          ? _value.smsSecurityMode
          : smsSecurityMode // ignore: cast_nullable_to_non_nullable
              as int,
      smsBindingKeyParam: smsBindingKeyParam == freezed
          ? _value.smsBindingKeyParam
          : smsBindingKeyParam // ignore: cast_nullable_to_non_nullable
              as int,
      smsBindingSecretKey: smsBindingSecretKey == freezed
          ? _value.smsBindingSecretKey
          : smsBindingSecretKey // ignore: cast_nullable_to_non_nullable
              as int,
      lwm2mServerSmsNum: lwm2mServerSmsNum == freezed
          ? _value.lwm2mServerSmsNum
          : lwm2mServerSmsNum // ignore: cast_nullable_to_non_nullable
              as int,
      shortServerId: shortServerId == freezed
          ? _value.shortServerId
          : shortServerId // ignore: cast_nullable_to_non_nullable
              as int,
      clientHoldOffTime: clientHoldOffTime == freezed
          ? _value.clientHoldOffTime
          : clientHoldOffTime // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidLwm2mSecurity implements _SpecificRidLwm2mSecurity {
  const _$_SpecificRidLwm2mSecurity(
      {required this.lwm2mServerURI,
      required this.bootstrapServer,
      required this.securityMode,
      required this.pubKeyId,
      required this.serverPubKeyId,
      required this.secretKey,
      required this.smsSecurityMode,
      required this.smsBindingKeyParam,
      required this.smsBindingSecretKey,
      required this.lwm2mServerSmsNum,
      required this.shortServerId,
      required this.clientHoldOffTime});

  factory _$_SpecificRidLwm2mSecurity.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidLwm2mSecurityFromJson(json);

  @override
  final int lwm2mServerURI;
  @override
  final int bootstrapServer;
  @override
  final int securityMode;
  @override
  final int pubKeyId;
  @override
  final int serverPubKeyId;
  @override
  final int secretKey;
  @override
  final int smsSecurityMode;
  @override
  final int smsBindingKeyParam;
  @override
  final int smsBindingSecretKey;
  @override
  final int lwm2mServerSmsNum;
  @override
  final int shortServerId;
  @override
  final int clientHoldOffTime;

  @override
  String toString() {
    return 'SpecificRidLwm2mSecurity(lwm2mServerURI: $lwm2mServerURI, bootstrapServer: $bootstrapServer, securityMode: $securityMode, pubKeyId: $pubKeyId, serverPubKeyId: $serverPubKeyId, secretKey: $secretKey, smsSecurityMode: $smsSecurityMode, smsBindingKeyParam: $smsBindingKeyParam, smsBindingSecretKey: $smsBindingSecretKey, lwm2mServerSmsNum: $lwm2mServerSmsNum, shortServerId: $shortServerId, clientHoldOffTime: $clientHoldOffTime)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidLwm2mSecurity &&
            (identical(other.lwm2mServerURI, lwm2mServerURI) ||
                const DeepCollectionEquality()
                    .equals(other.lwm2mServerURI, lwm2mServerURI)) &&
            (identical(other.bootstrapServer, bootstrapServer) ||
                const DeepCollectionEquality()
                    .equals(other.bootstrapServer, bootstrapServer)) &&
            (identical(other.securityMode, securityMode) ||
                const DeepCollectionEquality()
                    .equals(other.securityMode, securityMode)) &&
            (identical(other.pubKeyId, pubKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.pubKeyId, pubKeyId)) &&
            (identical(other.serverPubKeyId, serverPubKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.serverPubKeyId, serverPubKeyId)) &&
            (identical(other.secretKey, secretKey) ||
                const DeepCollectionEquality()
                    .equals(other.secretKey, secretKey)) &&
            (identical(other.smsSecurityMode, smsSecurityMode) ||
                const DeepCollectionEquality()
                    .equals(other.smsSecurityMode, smsSecurityMode)) &&
            (identical(other.smsBindingKeyParam, smsBindingKeyParam) ||
                const DeepCollectionEquality()
                    .equals(other.smsBindingKeyParam, smsBindingKeyParam)) &&
            (identical(other.smsBindingSecretKey, smsBindingSecretKey) ||
                const DeepCollectionEquality()
                    .equals(other.smsBindingSecretKey, smsBindingSecretKey)) &&
            (identical(other.lwm2mServerSmsNum, lwm2mServerSmsNum) ||
                const DeepCollectionEquality()
                    .equals(other.lwm2mServerSmsNum, lwm2mServerSmsNum)) &&
            (identical(other.shortServerId, shortServerId) ||
                const DeepCollectionEquality()
                    .equals(other.shortServerId, shortServerId)) &&
            (identical(other.clientHoldOffTime, clientHoldOffTime) ||
                const DeepCollectionEquality()
                    .equals(other.clientHoldOffTime, clientHoldOffTime)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(lwm2mServerURI) ^
      const DeepCollectionEquality().hash(bootstrapServer) ^
      const DeepCollectionEquality().hash(securityMode) ^
      const DeepCollectionEquality().hash(pubKeyId) ^
      const DeepCollectionEquality().hash(serverPubKeyId) ^
      const DeepCollectionEquality().hash(secretKey) ^
      const DeepCollectionEquality().hash(smsSecurityMode) ^
      const DeepCollectionEquality().hash(smsBindingKeyParam) ^
      const DeepCollectionEquality().hash(smsBindingSecretKey) ^
      const DeepCollectionEquality().hash(lwm2mServerSmsNum) ^
      const DeepCollectionEquality().hash(shortServerId) ^
      const DeepCollectionEquality().hash(clientHoldOffTime);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidLwm2mSecurityCopyWith<_SpecificRidLwm2mSecurity> get copyWith =>
      __$SpecificRidLwm2mSecurityCopyWithImpl<_SpecificRidLwm2mSecurity>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidLwm2mSecurityToJson(this);
  }
}

abstract class _SpecificRidLwm2mSecurity implements SpecificRidLwm2mSecurity {
  const factory _SpecificRidLwm2mSecurity(
      {required int lwm2mServerURI,
      required int bootstrapServer,
      required int securityMode,
      required int pubKeyId,
      required int serverPubKeyId,
      required int secretKey,
      required int smsSecurityMode,
      required int smsBindingKeyParam,
      required int smsBindingSecretKey,
      required int lwm2mServerSmsNum,
      required int shortServerId,
      required int clientHoldOffTime}) = _$_SpecificRidLwm2mSecurity;

  factory _SpecificRidLwm2mSecurity.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidLwm2mSecurity.fromJson;

  @override
  int get lwm2mServerURI => throw _privateConstructorUsedError;
  @override
  int get bootstrapServer => throw _privateConstructorUsedError;
  @override
  int get securityMode => throw _privateConstructorUsedError;
  @override
  int get pubKeyId => throw _privateConstructorUsedError;
  @override
  int get serverPubKeyId => throw _privateConstructorUsedError;
  @override
  int get secretKey => throw _privateConstructorUsedError;
  @override
  int get smsSecurityMode => throw _privateConstructorUsedError;
  @override
  int get smsBindingKeyParam => throw _privateConstructorUsedError;
  @override
  int get smsBindingSecretKey => throw _privateConstructorUsedError;
  @override
  int get lwm2mServerSmsNum => throw _privateConstructorUsedError;
  @override
  int get shortServerId => throw _privateConstructorUsedError;
  @override
  int get clientHoldOffTime => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidLwm2mSecurityCopyWith<_SpecificRidLwm2mSecurity> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidLwm2mServer _$SpecificRidLwm2mServerFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidLwm2mServer.fromJson(json);
}

/// @nodoc
class _$SpecificRidLwm2mServerTearOff {
  const _$SpecificRidLwm2mServerTearOff();

  _SpecificRidLwm2mServer call(
      {required int shortServerId,
      required int lifetime,
      required int defaultMinPeriod,
      required int defaultMaxPeriod,
      required int disable,
      required int disableTimeout,
      required int notificationStoring,
      required int binding,
      required int regUpdateTrigger}) {
    return _SpecificRidLwm2mServer(
      shortServerId: shortServerId,
      lifetime: lifetime,
      defaultMinPeriod: defaultMinPeriod,
      defaultMaxPeriod: defaultMaxPeriod,
      disable: disable,
      disableTimeout: disableTimeout,
      notificationStoring: notificationStoring,
      binding: binding,
      regUpdateTrigger: regUpdateTrigger,
    );
  }

  SpecificRidLwm2mServer fromJson(Map<String, Object> json) {
    return SpecificRidLwm2mServer.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidLwm2mServer = _$SpecificRidLwm2mServerTearOff();

/// @nodoc
mixin _$SpecificRidLwm2mServer {
  int get shortServerId => throw _privateConstructorUsedError;
  int get lifetime => throw _privateConstructorUsedError;
  int get defaultMinPeriod => throw _privateConstructorUsedError;
  int get defaultMaxPeriod => throw _privateConstructorUsedError;
  int get disable => throw _privateConstructorUsedError;
  int get disableTimeout => throw _privateConstructorUsedError;
  int get notificationStoring => throw _privateConstructorUsedError;
  int get binding => throw _privateConstructorUsedError;
  int get regUpdateTrigger => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidLwm2mServerCopyWith<SpecificRidLwm2mServer> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidLwm2mServerCopyWith<$Res> {
  factory $SpecificRidLwm2mServerCopyWith(SpecificRidLwm2mServer value,
          $Res Function(SpecificRidLwm2mServer) then) =
      _$SpecificRidLwm2mServerCopyWithImpl<$Res>;
  $Res call(
      {int shortServerId,
      int lifetime,
      int defaultMinPeriod,
      int defaultMaxPeriod,
      int disable,
      int disableTimeout,
      int notificationStoring,
      int binding,
      int regUpdateTrigger});
}

/// @nodoc
class _$SpecificRidLwm2mServerCopyWithImpl<$Res>
    implements $SpecificRidLwm2mServerCopyWith<$Res> {
  _$SpecificRidLwm2mServerCopyWithImpl(this._value, this._then);

  final SpecificRidLwm2mServer _value;
  // ignore: unused_field
  final $Res Function(SpecificRidLwm2mServer) _then;

  @override
  $Res call({
    Object? shortServerId = freezed,
    Object? lifetime = freezed,
    Object? defaultMinPeriod = freezed,
    Object? defaultMaxPeriod = freezed,
    Object? disable = freezed,
    Object? disableTimeout = freezed,
    Object? notificationStoring = freezed,
    Object? binding = freezed,
    Object? regUpdateTrigger = freezed,
  }) {
    return _then(_value.copyWith(
      shortServerId: shortServerId == freezed
          ? _value.shortServerId
          : shortServerId // ignore: cast_nullable_to_non_nullable
              as int,
      lifetime: lifetime == freezed
          ? _value.lifetime
          : lifetime // ignore: cast_nullable_to_non_nullable
              as int,
      defaultMinPeriod: defaultMinPeriod == freezed
          ? _value.defaultMinPeriod
          : defaultMinPeriod // ignore: cast_nullable_to_non_nullable
              as int,
      defaultMaxPeriod: defaultMaxPeriod == freezed
          ? _value.defaultMaxPeriod
          : defaultMaxPeriod // ignore: cast_nullable_to_non_nullable
              as int,
      disable: disable == freezed
          ? _value.disable
          : disable // ignore: cast_nullable_to_non_nullable
              as int,
      disableTimeout: disableTimeout == freezed
          ? _value.disableTimeout
          : disableTimeout // ignore: cast_nullable_to_non_nullable
              as int,
      notificationStoring: notificationStoring == freezed
          ? _value.notificationStoring
          : notificationStoring // ignore: cast_nullable_to_non_nullable
              as int,
      binding: binding == freezed
          ? _value.binding
          : binding // ignore: cast_nullable_to_non_nullable
              as int,
      regUpdateTrigger: regUpdateTrigger == freezed
          ? _value.regUpdateTrigger
          : regUpdateTrigger // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidLwm2mServerCopyWith<$Res>
    implements $SpecificRidLwm2mServerCopyWith<$Res> {
  factory _$SpecificRidLwm2mServerCopyWith(_SpecificRidLwm2mServer value,
          $Res Function(_SpecificRidLwm2mServer) then) =
      __$SpecificRidLwm2mServerCopyWithImpl<$Res>;
  @override
  $Res call(
      {int shortServerId,
      int lifetime,
      int defaultMinPeriod,
      int defaultMaxPeriod,
      int disable,
      int disableTimeout,
      int notificationStoring,
      int binding,
      int regUpdateTrigger});
}

/// @nodoc
class __$SpecificRidLwm2mServerCopyWithImpl<$Res>
    extends _$SpecificRidLwm2mServerCopyWithImpl<$Res>
    implements _$SpecificRidLwm2mServerCopyWith<$Res> {
  __$SpecificRidLwm2mServerCopyWithImpl(_SpecificRidLwm2mServer _value,
      $Res Function(_SpecificRidLwm2mServer) _then)
      : super(_value, (v) => _then(v as _SpecificRidLwm2mServer));

  @override
  _SpecificRidLwm2mServer get _value => super._value as _SpecificRidLwm2mServer;

  @override
  $Res call({
    Object? shortServerId = freezed,
    Object? lifetime = freezed,
    Object? defaultMinPeriod = freezed,
    Object? defaultMaxPeriod = freezed,
    Object? disable = freezed,
    Object? disableTimeout = freezed,
    Object? notificationStoring = freezed,
    Object? binding = freezed,
    Object? regUpdateTrigger = freezed,
  }) {
    return _then(_SpecificRidLwm2mServer(
      shortServerId: shortServerId == freezed
          ? _value.shortServerId
          : shortServerId // ignore: cast_nullable_to_non_nullable
              as int,
      lifetime: lifetime == freezed
          ? _value.lifetime
          : lifetime // ignore: cast_nullable_to_non_nullable
              as int,
      defaultMinPeriod: defaultMinPeriod == freezed
          ? _value.defaultMinPeriod
          : defaultMinPeriod // ignore: cast_nullable_to_non_nullable
              as int,
      defaultMaxPeriod: defaultMaxPeriod == freezed
          ? _value.defaultMaxPeriod
          : defaultMaxPeriod // ignore: cast_nullable_to_non_nullable
              as int,
      disable: disable == freezed
          ? _value.disable
          : disable // ignore: cast_nullable_to_non_nullable
              as int,
      disableTimeout: disableTimeout == freezed
          ? _value.disableTimeout
          : disableTimeout // ignore: cast_nullable_to_non_nullable
              as int,
      notificationStoring: notificationStoring == freezed
          ? _value.notificationStoring
          : notificationStoring // ignore: cast_nullable_to_non_nullable
              as int,
      binding: binding == freezed
          ? _value.binding
          : binding // ignore: cast_nullable_to_non_nullable
              as int,
      regUpdateTrigger: regUpdateTrigger == freezed
          ? _value.regUpdateTrigger
          : regUpdateTrigger // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidLwm2mServer implements _SpecificRidLwm2mServer {
  const _$_SpecificRidLwm2mServer(
      {required this.shortServerId,
      required this.lifetime,
      required this.defaultMinPeriod,
      required this.defaultMaxPeriod,
      required this.disable,
      required this.disableTimeout,
      required this.notificationStoring,
      required this.binding,
      required this.regUpdateTrigger});

  factory _$_SpecificRidLwm2mServer.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidLwm2mServerFromJson(json);

  @override
  final int shortServerId;
  @override
  final int lifetime;
  @override
  final int defaultMinPeriod;
  @override
  final int defaultMaxPeriod;
  @override
  final int disable;
  @override
  final int disableTimeout;
  @override
  final int notificationStoring;
  @override
  final int binding;
  @override
  final int regUpdateTrigger;

  @override
  String toString() {
    return 'SpecificRidLwm2mServer(shortServerId: $shortServerId, lifetime: $lifetime, defaultMinPeriod: $defaultMinPeriod, defaultMaxPeriod: $defaultMaxPeriod, disable: $disable, disableTimeout: $disableTimeout, notificationStoring: $notificationStoring, binding: $binding, regUpdateTrigger: $regUpdateTrigger)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidLwm2mServer &&
            (identical(other.shortServerId, shortServerId) ||
                const DeepCollectionEquality()
                    .equals(other.shortServerId, shortServerId)) &&
            (identical(other.lifetime, lifetime) ||
                const DeepCollectionEquality()
                    .equals(other.lifetime, lifetime)) &&
            (identical(other.defaultMinPeriod, defaultMinPeriod) ||
                const DeepCollectionEquality()
                    .equals(other.defaultMinPeriod, defaultMinPeriod)) &&
            (identical(other.defaultMaxPeriod, defaultMaxPeriod) ||
                const DeepCollectionEquality()
                    .equals(other.defaultMaxPeriod, defaultMaxPeriod)) &&
            (identical(other.disable, disable) ||
                const DeepCollectionEquality()
                    .equals(other.disable, disable)) &&
            (identical(other.disableTimeout, disableTimeout) ||
                const DeepCollectionEquality()
                    .equals(other.disableTimeout, disableTimeout)) &&
            (identical(other.notificationStoring, notificationStoring) ||
                const DeepCollectionEquality()
                    .equals(other.notificationStoring, notificationStoring)) &&
            (identical(other.binding, binding) ||
                const DeepCollectionEquality()
                    .equals(other.binding, binding)) &&
            (identical(other.regUpdateTrigger, regUpdateTrigger) ||
                const DeepCollectionEquality()
                    .equals(other.regUpdateTrigger, regUpdateTrigger)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(shortServerId) ^
      const DeepCollectionEquality().hash(lifetime) ^
      const DeepCollectionEquality().hash(defaultMinPeriod) ^
      const DeepCollectionEquality().hash(defaultMaxPeriod) ^
      const DeepCollectionEquality().hash(disable) ^
      const DeepCollectionEquality().hash(disableTimeout) ^
      const DeepCollectionEquality().hash(notificationStoring) ^
      const DeepCollectionEquality().hash(binding) ^
      const DeepCollectionEquality().hash(regUpdateTrigger);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidLwm2mServerCopyWith<_SpecificRidLwm2mServer> get copyWith =>
      __$SpecificRidLwm2mServerCopyWithImpl<_SpecificRidLwm2mServer>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidLwm2mServerToJson(this);
  }
}

abstract class _SpecificRidLwm2mServer implements SpecificRidLwm2mServer {
  const factory _SpecificRidLwm2mServer(
      {required int shortServerId,
      required int lifetime,
      required int defaultMinPeriod,
      required int defaultMaxPeriod,
      required int disable,
      required int disableTimeout,
      required int notificationStoring,
      required int binding,
      required int regUpdateTrigger}) = _$_SpecificRidLwm2mServer;

  factory _SpecificRidLwm2mServer.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidLwm2mServer.fromJson;

  @override
  int get shortServerId => throw _privateConstructorUsedError;
  @override
  int get lifetime => throw _privateConstructorUsedError;
  @override
  int get defaultMinPeriod => throw _privateConstructorUsedError;
  @override
  int get defaultMaxPeriod => throw _privateConstructorUsedError;
  @override
  int get disable => throw _privateConstructorUsedError;
  @override
  int get disableTimeout => throw _privateConstructorUsedError;
  @override
  int get notificationStoring => throw _privateConstructorUsedError;
  @override
  int get binding => throw _privateConstructorUsedError;
  @override
  int get regUpdateTrigger => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidLwm2mServerCopyWith<_SpecificRidLwm2mServer> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidMagnetometer _$SpecificRidMagnetometerFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidMagnetometer.fromJson(json);
}

/// @nodoc
class _$SpecificRidMagnetometerTearOff {
  const _$SpecificRidMagnetometerTearOff();

  _SpecificRidMagnetometer call(
      {required int units,
      required int xValue,
      required int yValue,
      required int zValue,
      required int compassDir}) {
    return _SpecificRidMagnetometer(
      units: units,
      xValue: xValue,
      yValue: yValue,
      zValue: zValue,
      compassDir: compassDir,
    );
  }

  SpecificRidMagnetometer fromJson(Map<String, Object> json) {
    return SpecificRidMagnetometer.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidMagnetometer = _$SpecificRidMagnetometerTearOff();

/// @nodoc
mixin _$SpecificRidMagnetometer {
  int get units => throw _privateConstructorUsedError;
  int get xValue => throw _privateConstructorUsedError;
  int get yValue => throw _privateConstructorUsedError;
  int get zValue => throw _privateConstructorUsedError;
  int get compassDir => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidMagnetometerCopyWith<SpecificRidMagnetometer> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidMagnetometerCopyWith<$Res> {
  factory $SpecificRidMagnetometerCopyWith(SpecificRidMagnetometer value,
          $Res Function(SpecificRidMagnetometer) then) =
      _$SpecificRidMagnetometerCopyWithImpl<$Res>;
  $Res call({int units, int xValue, int yValue, int zValue, int compassDir});
}

/// @nodoc
class _$SpecificRidMagnetometerCopyWithImpl<$Res>
    implements $SpecificRidMagnetometerCopyWith<$Res> {
  _$SpecificRidMagnetometerCopyWithImpl(this._value, this._then);

  final SpecificRidMagnetometer _value;
  // ignore: unused_field
  final $Res Function(SpecificRidMagnetometer) _then;

  @override
  $Res call({
    Object? units = freezed,
    Object? xValue = freezed,
    Object? yValue = freezed,
    Object? zValue = freezed,
    Object? compassDir = freezed,
  }) {
    return _then(_value.copyWith(
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      xValue: xValue == freezed
          ? _value.xValue
          : xValue // ignore: cast_nullable_to_non_nullable
              as int,
      yValue: yValue == freezed
          ? _value.yValue
          : yValue // ignore: cast_nullable_to_non_nullable
              as int,
      zValue: zValue == freezed
          ? _value.zValue
          : zValue // ignore: cast_nullable_to_non_nullable
              as int,
      compassDir: compassDir == freezed
          ? _value.compassDir
          : compassDir // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidMagnetometerCopyWith<$Res>
    implements $SpecificRidMagnetometerCopyWith<$Res> {
  factory _$SpecificRidMagnetometerCopyWith(_SpecificRidMagnetometer value,
          $Res Function(_SpecificRidMagnetometer) then) =
      __$SpecificRidMagnetometerCopyWithImpl<$Res>;
  @override
  $Res call({int units, int xValue, int yValue, int zValue, int compassDir});
}

/// @nodoc
class __$SpecificRidMagnetometerCopyWithImpl<$Res>
    extends _$SpecificRidMagnetometerCopyWithImpl<$Res>
    implements _$SpecificRidMagnetometerCopyWith<$Res> {
  __$SpecificRidMagnetometerCopyWithImpl(_SpecificRidMagnetometer _value,
      $Res Function(_SpecificRidMagnetometer) _then)
      : super(_value, (v) => _then(v as _SpecificRidMagnetometer));

  @override
  _SpecificRidMagnetometer get _value =>
      super._value as _SpecificRidMagnetometer;

  @override
  $Res call({
    Object? units = freezed,
    Object? xValue = freezed,
    Object? yValue = freezed,
    Object? zValue = freezed,
    Object? compassDir = freezed,
  }) {
    return _then(_SpecificRidMagnetometer(
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      xValue: xValue == freezed
          ? _value.xValue
          : xValue // ignore: cast_nullable_to_non_nullable
              as int,
      yValue: yValue == freezed
          ? _value.yValue
          : yValue // ignore: cast_nullable_to_non_nullable
              as int,
      zValue: zValue == freezed
          ? _value.zValue
          : zValue // ignore: cast_nullable_to_non_nullable
              as int,
      compassDir: compassDir == freezed
          ? _value.compassDir
          : compassDir // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidMagnetometer implements _SpecificRidMagnetometer {
  const _$_SpecificRidMagnetometer(
      {required this.units,
      required this.xValue,
      required this.yValue,
      required this.zValue,
      required this.compassDir});

  factory _$_SpecificRidMagnetometer.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidMagnetometerFromJson(json);

  @override
  final int units;
  @override
  final int xValue;
  @override
  final int yValue;
  @override
  final int zValue;
  @override
  final int compassDir;

  @override
  String toString() {
    return 'SpecificRidMagnetometer(units: $units, xValue: $xValue, yValue: $yValue, zValue: $zValue, compassDir: $compassDir)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidMagnetometer &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.xValue, xValue) ||
                const DeepCollectionEquality().equals(other.xValue, xValue)) &&
            (identical(other.yValue, yValue) ||
                const DeepCollectionEquality().equals(other.yValue, yValue)) &&
            (identical(other.zValue, zValue) ||
                const DeepCollectionEquality().equals(other.zValue, zValue)) &&
            (identical(other.compassDir, compassDir) ||
                const DeepCollectionEquality()
                    .equals(other.compassDir, compassDir)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(xValue) ^
      const DeepCollectionEquality().hash(yValue) ^
      const DeepCollectionEquality().hash(zValue) ^
      const DeepCollectionEquality().hash(compassDir);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidMagnetometerCopyWith<_SpecificRidMagnetometer> get copyWith =>
      __$SpecificRidMagnetometerCopyWithImpl<_SpecificRidMagnetometer>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidMagnetometerToJson(this);
  }
}

abstract class _SpecificRidMagnetometer implements SpecificRidMagnetometer {
  const factory _SpecificRidMagnetometer(
      {required int units,
      required int xValue,
      required int yValue,
      required int zValue,
      required int compassDir}) = _$_SpecificRidMagnetometer;

  factory _SpecificRidMagnetometer.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidMagnetometer.fromJson;

  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get xValue => throw _privateConstructorUsedError;
  @override
  int get yValue => throw _privateConstructorUsedError;
  @override
  int get zValue => throw _privateConstructorUsedError;
  @override
  int get compassDir => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidMagnetometerCopyWith<_SpecificRidMagnetometer> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidMultipleAxisJoystick _$SpecificRidMultipleAxisJoystickFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidMultipleAxisJoystick.fromJson(json);
}

/// @nodoc
class _$SpecificRidMultipleAxisJoystickTearOff {
  const _$SpecificRidMultipleAxisJoystickTearOff();

  _SpecificRidMultipleAxisJoystick call(
      {required int dInState,
      required int counter,
      required int xValue,
      required int yValue,
      required int zValue,
      required int appType}) {
    return _SpecificRidMultipleAxisJoystick(
      dInState: dInState,
      counter: counter,
      xValue: xValue,
      yValue: yValue,
      zValue: zValue,
      appType: appType,
    );
  }

  SpecificRidMultipleAxisJoystick fromJson(Map<String, Object> json) {
    return SpecificRidMultipleAxisJoystick.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidMultipleAxisJoystick =
    _$SpecificRidMultipleAxisJoystickTearOff();

/// @nodoc
mixin _$SpecificRidMultipleAxisJoystick {
  int get dInState => throw _privateConstructorUsedError;
  int get counter => throw _privateConstructorUsedError;
  int get xValue => throw _privateConstructorUsedError;
  int get yValue => throw _privateConstructorUsedError;
  int get zValue => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidMultipleAxisJoystickCopyWith<SpecificRidMultipleAxisJoystick>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidMultipleAxisJoystickCopyWith<$Res> {
  factory $SpecificRidMultipleAxisJoystickCopyWith(
          SpecificRidMultipleAxisJoystick value,
          $Res Function(SpecificRidMultipleAxisJoystick) then) =
      _$SpecificRidMultipleAxisJoystickCopyWithImpl<$Res>;
  $Res call(
      {int dInState,
      int counter,
      int xValue,
      int yValue,
      int zValue,
      int appType});
}

/// @nodoc
class _$SpecificRidMultipleAxisJoystickCopyWithImpl<$Res>
    implements $SpecificRidMultipleAxisJoystickCopyWith<$Res> {
  _$SpecificRidMultipleAxisJoystickCopyWithImpl(this._value, this._then);

  final SpecificRidMultipleAxisJoystick _value;
  // ignore: unused_field
  final $Res Function(SpecificRidMultipleAxisJoystick) _then;

  @override
  $Res call({
    Object? dInState = freezed,
    Object? counter = freezed,
    Object? xValue = freezed,
    Object? yValue = freezed,
    Object? zValue = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      dInState: dInState == freezed
          ? _value.dInState
          : dInState // ignore: cast_nullable_to_non_nullable
              as int,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as int,
      xValue: xValue == freezed
          ? _value.xValue
          : xValue // ignore: cast_nullable_to_non_nullable
              as int,
      yValue: yValue == freezed
          ? _value.yValue
          : yValue // ignore: cast_nullable_to_non_nullable
              as int,
      zValue: zValue == freezed
          ? _value.zValue
          : zValue // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidMultipleAxisJoystickCopyWith<$Res>
    implements $SpecificRidMultipleAxisJoystickCopyWith<$Res> {
  factory _$SpecificRidMultipleAxisJoystickCopyWith(
          _SpecificRidMultipleAxisJoystick value,
          $Res Function(_SpecificRidMultipleAxisJoystick) then) =
      __$SpecificRidMultipleAxisJoystickCopyWithImpl<$Res>;
  @override
  $Res call(
      {int dInState,
      int counter,
      int xValue,
      int yValue,
      int zValue,
      int appType});
}

/// @nodoc
class __$SpecificRidMultipleAxisJoystickCopyWithImpl<$Res>
    extends _$SpecificRidMultipleAxisJoystickCopyWithImpl<$Res>
    implements _$SpecificRidMultipleAxisJoystickCopyWith<$Res> {
  __$SpecificRidMultipleAxisJoystickCopyWithImpl(
      _SpecificRidMultipleAxisJoystick _value,
      $Res Function(_SpecificRidMultipleAxisJoystick) _then)
      : super(_value, (v) => _then(v as _SpecificRidMultipleAxisJoystick));

  @override
  _SpecificRidMultipleAxisJoystick get _value =>
      super._value as _SpecificRidMultipleAxisJoystick;

  @override
  $Res call({
    Object? dInState = freezed,
    Object? counter = freezed,
    Object? xValue = freezed,
    Object? yValue = freezed,
    Object? zValue = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidMultipleAxisJoystick(
      dInState: dInState == freezed
          ? _value.dInState
          : dInState // ignore: cast_nullable_to_non_nullable
              as int,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as int,
      xValue: xValue == freezed
          ? _value.xValue
          : xValue // ignore: cast_nullable_to_non_nullable
              as int,
      yValue: yValue == freezed
          ? _value.yValue
          : yValue // ignore: cast_nullable_to_non_nullable
              as int,
      zValue: zValue == freezed
          ? _value.zValue
          : zValue // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidMultipleAxisJoystick
    implements _SpecificRidMultipleAxisJoystick {
  const _$_SpecificRidMultipleAxisJoystick(
      {required this.dInState,
      required this.counter,
      required this.xValue,
      required this.yValue,
      required this.zValue,
      required this.appType});

  factory _$_SpecificRidMultipleAxisJoystick.fromJson(
          Map<String, dynamic> json) =>
      _$$_SpecificRidMultipleAxisJoystickFromJson(json);

  @override
  final int dInState;
  @override
  final int counter;
  @override
  final int xValue;
  @override
  final int yValue;
  @override
  final int zValue;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidMultipleAxisJoystick(dInState: $dInState, counter: $counter, xValue: $xValue, yValue: $yValue, zValue: $zValue, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidMultipleAxisJoystick &&
            (identical(other.dInState, dInState) ||
                const DeepCollectionEquality()
                    .equals(other.dInState, dInState)) &&
            (identical(other.counter, counter) ||
                const DeepCollectionEquality()
                    .equals(other.counter, counter)) &&
            (identical(other.xValue, xValue) ||
                const DeepCollectionEquality().equals(other.xValue, xValue)) &&
            (identical(other.yValue, yValue) ||
                const DeepCollectionEquality().equals(other.yValue, yValue)) &&
            (identical(other.zValue, zValue) ||
                const DeepCollectionEquality().equals(other.zValue, zValue)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(dInState) ^
      const DeepCollectionEquality().hash(counter) ^
      const DeepCollectionEquality().hash(xValue) ^
      const DeepCollectionEquality().hash(yValue) ^
      const DeepCollectionEquality().hash(zValue) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidMultipleAxisJoystickCopyWith<_SpecificRidMultipleAxisJoystick>
      get copyWith => __$SpecificRidMultipleAxisJoystickCopyWithImpl<
          _SpecificRidMultipleAxisJoystick>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidMultipleAxisJoystickToJson(this);
  }
}

abstract class _SpecificRidMultipleAxisJoystick
    implements SpecificRidMultipleAxisJoystick {
  const factory _SpecificRidMultipleAxisJoystick(
      {required int dInState,
      required int counter,
      required int xValue,
      required int yValue,
      required int zValue,
      required int appType}) = _$_SpecificRidMultipleAxisJoystick;

  factory _SpecificRidMultipleAxisJoystick.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidMultipleAxisJoystick.fromJson;

  @override
  int get dInState => throw _privateConstructorUsedError;
  @override
  int get counter => throw _privateConstructorUsedError;
  @override
  int get xValue => throw _privateConstructorUsedError;
  @override
  int get yValue => throw _privateConstructorUsedError;
  @override
  int get zValue => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidMultipleAxisJoystickCopyWith<_SpecificRidMultipleAxisJoystick>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificRidMultistateSelector _$SpecificRidMultistateSelectorFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidMultistateSelector.fromJson(json);
}

/// @nodoc
class _$SpecificRidMultistateSelectorTearOff {
  const _$SpecificRidMultistateSelectorTearOff();

  _SpecificRidMultistateSelector call(
      {required int mStateIn, required int appType}) {
    return _SpecificRidMultistateSelector(
      mStateIn: mStateIn,
      appType: appType,
    );
  }

  SpecificRidMultistateSelector fromJson(Map<String, Object> json) {
    return SpecificRidMultistateSelector.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidMultistateSelector = _$SpecificRidMultistateSelectorTearOff();

/// @nodoc
mixin _$SpecificRidMultistateSelector {
  int get mStateIn => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidMultistateSelectorCopyWith<SpecificRidMultistateSelector>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidMultistateSelectorCopyWith<$Res> {
  factory $SpecificRidMultistateSelectorCopyWith(
          SpecificRidMultistateSelector value,
          $Res Function(SpecificRidMultistateSelector) then) =
      _$SpecificRidMultistateSelectorCopyWithImpl<$Res>;
  $Res call({int mStateIn, int appType});
}

/// @nodoc
class _$SpecificRidMultistateSelectorCopyWithImpl<$Res>
    implements $SpecificRidMultistateSelectorCopyWith<$Res> {
  _$SpecificRidMultistateSelectorCopyWithImpl(this._value, this._then);

  final SpecificRidMultistateSelector _value;
  // ignore: unused_field
  final $Res Function(SpecificRidMultistateSelector) _then;

  @override
  $Res call({
    Object? mStateIn = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      mStateIn: mStateIn == freezed
          ? _value.mStateIn
          : mStateIn // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidMultistateSelectorCopyWith<$Res>
    implements $SpecificRidMultistateSelectorCopyWith<$Res> {
  factory _$SpecificRidMultistateSelectorCopyWith(
          _SpecificRidMultistateSelector value,
          $Res Function(_SpecificRidMultistateSelector) then) =
      __$SpecificRidMultistateSelectorCopyWithImpl<$Res>;
  @override
  $Res call({int mStateIn, int appType});
}

/// @nodoc
class __$SpecificRidMultistateSelectorCopyWithImpl<$Res>
    extends _$SpecificRidMultistateSelectorCopyWithImpl<$Res>
    implements _$SpecificRidMultistateSelectorCopyWith<$Res> {
  __$SpecificRidMultistateSelectorCopyWithImpl(
      _SpecificRidMultistateSelector _value,
      $Res Function(_SpecificRidMultistateSelector) _then)
      : super(_value, (v) => _then(v as _SpecificRidMultistateSelector));

  @override
  _SpecificRidMultistateSelector get _value =>
      super._value as _SpecificRidMultistateSelector;

  @override
  $Res call({
    Object? mStateIn = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidMultistateSelector(
      mStateIn: mStateIn == freezed
          ? _value.mStateIn
          : mStateIn // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidMultistateSelector
    implements _SpecificRidMultistateSelector {
  const _$_SpecificRidMultistateSelector(
      {required this.mStateIn, required this.appType});

  factory _$_SpecificRidMultistateSelector.fromJson(
          Map<String, dynamic> json) =>
      _$$_SpecificRidMultistateSelectorFromJson(json);

  @override
  final int mStateIn;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidMultistateSelector(mStateIn: $mStateIn, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidMultistateSelector &&
            (identical(other.mStateIn, mStateIn) ||
                const DeepCollectionEquality()
                    .equals(other.mStateIn, mStateIn)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(mStateIn) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidMultistateSelectorCopyWith<_SpecificRidMultistateSelector>
      get copyWith => __$SpecificRidMultistateSelectorCopyWithImpl<
          _SpecificRidMultistateSelector>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidMultistateSelectorToJson(this);
  }
}

abstract class _SpecificRidMultistateSelector
    implements SpecificRidMultistateSelector {
  const factory _SpecificRidMultistateSelector(
      {required int mStateIn,
      required int appType}) = _$_SpecificRidMultistateSelector;

  factory _SpecificRidMultistateSelector.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidMultistateSelector.fromJson;

  @override
  int get mStateIn => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidMultistateSelectorCopyWith<_SpecificRidMultistateSelector>
      get copyWith => throw _privateConstructorUsedError;
}

SpecificRidOnOffSwitch _$SpecificRidOnOffSwitchFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidOnOffSwitch.fromJson(json);
}

/// @nodoc
class _$SpecificRidOnOffSwitchTearOff {
  const _$SpecificRidOnOffSwitchTearOff();

  _SpecificRidOnOffSwitch call(
      {required int dInState,
      required int counter,
      required int onTime,
      required int offTime,
      required int appType}) {
    return _SpecificRidOnOffSwitch(
      dInState: dInState,
      counter: counter,
      onTime: onTime,
      offTime: offTime,
      appType: appType,
    );
  }

  SpecificRidOnOffSwitch fromJson(Map<String, Object> json) {
    return SpecificRidOnOffSwitch.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidOnOffSwitch = _$SpecificRidOnOffSwitchTearOff();

/// @nodoc
mixin _$SpecificRidOnOffSwitch {
  int get dInState => throw _privateConstructorUsedError;
  int get counter => throw _privateConstructorUsedError;
  int get onTime => throw _privateConstructorUsedError;
  int get offTime => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidOnOffSwitchCopyWith<SpecificRidOnOffSwitch> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidOnOffSwitchCopyWith<$Res> {
  factory $SpecificRidOnOffSwitchCopyWith(SpecificRidOnOffSwitch value,
          $Res Function(SpecificRidOnOffSwitch) then) =
      _$SpecificRidOnOffSwitchCopyWithImpl<$Res>;
  $Res call({int dInState, int counter, int onTime, int offTime, int appType});
}

/// @nodoc
class _$SpecificRidOnOffSwitchCopyWithImpl<$Res>
    implements $SpecificRidOnOffSwitchCopyWith<$Res> {
  _$SpecificRidOnOffSwitchCopyWithImpl(this._value, this._then);

  final SpecificRidOnOffSwitch _value;
  // ignore: unused_field
  final $Res Function(SpecificRidOnOffSwitch) _then;

  @override
  $Res call({
    Object? dInState = freezed,
    Object? counter = freezed,
    Object? onTime = freezed,
    Object? offTime = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      dInState: dInState == freezed
          ? _value.dInState
          : dInState // ignore: cast_nullable_to_non_nullable
              as int,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as int,
      onTime: onTime == freezed
          ? _value.onTime
          : onTime // ignore: cast_nullable_to_non_nullable
              as int,
      offTime: offTime == freezed
          ? _value.offTime
          : offTime // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidOnOffSwitchCopyWith<$Res>
    implements $SpecificRidOnOffSwitchCopyWith<$Res> {
  factory _$SpecificRidOnOffSwitchCopyWith(_SpecificRidOnOffSwitch value,
          $Res Function(_SpecificRidOnOffSwitch) then) =
      __$SpecificRidOnOffSwitchCopyWithImpl<$Res>;
  @override
  $Res call({int dInState, int counter, int onTime, int offTime, int appType});
}

/// @nodoc
class __$SpecificRidOnOffSwitchCopyWithImpl<$Res>
    extends _$SpecificRidOnOffSwitchCopyWithImpl<$Res>
    implements _$SpecificRidOnOffSwitchCopyWith<$Res> {
  __$SpecificRidOnOffSwitchCopyWithImpl(_SpecificRidOnOffSwitch _value,
      $Res Function(_SpecificRidOnOffSwitch) _then)
      : super(_value, (v) => _then(v as _SpecificRidOnOffSwitch));

  @override
  _SpecificRidOnOffSwitch get _value => super._value as _SpecificRidOnOffSwitch;

  @override
  $Res call({
    Object? dInState = freezed,
    Object? counter = freezed,
    Object? onTime = freezed,
    Object? offTime = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidOnOffSwitch(
      dInState: dInState == freezed
          ? _value.dInState
          : dInState // ignore: cast_nullable_to_non_nullable
              as int,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as int,
      onTime: onTime == freezed
          ? _value.onTime
          : onTime // ignore: cast_nullable_to_non_nullable
              as int,
      offTime: offTime == freezed
          ? _value.offTime
          : offTime // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidOnOffSwitch implements _SpecificRidOnOffSwitch {
  const _$_SpecificRidOnOffSwitch(
      {required this.dInState,
      required this.counter,
      required this.onTime,
      required this.offTime,
      required this.appType});

  factory _$_SpecificRidOnOffSwitch.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidOnOffSwitchFromJson(json);

  @override
  final int dInState;
  @override
  final int counter;
  @override
  final int onTime;
  @override
  final int offTime;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidOnOffSwitch(dInState: $dInState, counter: $counter, onTime: $onTime, offTime: $offTime, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidOnOffSwitch &&
            (identical(other.dInState, dInState) ||
                const DeepCollectionEquality()
                    .equals(other.dInState, dInState)) &&
            (identical(other.counter, counter) ||
                const DeepCollectionEquality()
                    .equals(other.counter, counter)) &&
            (identical(other.onTime, onTime) ||
                const DeepCollectionEquality().equals(other.onTime, onTime)) &&
            (identical(other.offTime, offTime) ||
                const DeepCollectionEquality()
                    .equals(other.offTime, offTime)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(dInState) ^
      const DeepCollectionEquality().hash(counter) ^
      const DeepCollectionEquality().hash(onTime) ^
      const DeepCollectionEquality().hash(offTime) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidOnOffSwitchCopyWith<_SpecificRidOnOffSwitch> get copyWith =>
      __$SpecificRidOnOffSwitchCopyWithImpl<_SpecificRidOnOffSwitch>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidOnOffSwitchToJson(this);
  }
}

abstract class _SpecificRidOnOffSwitch implements SpecificRidOnOffSwitch {
  const factory _SpecificRidOnOffSwitch(
      {required int dInState,
      required int counter,
      required int onTime,
      required int offTime,
      required int appType}) = _$_SpecificRidOnOffSwitch;

  factory _SpecificRidOnOffSwitch.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidOnOffSwitch.fromJson;

  @override
  int get dInState => throw _privateConstructorUsedError;
  @override
  int get counter => throw _privateConstructorUsedError;
  @override
  int get onTime => throw _privateConstructorUsedError;
  @override
  int get offTime => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidOnOffSwitchCopyWith<_SpecificRidOnOffSwitch> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidPercentage _$SpecificRidPercentageFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidPercentage.fromJson(json);
}

/// @nodoc
class _$SpecificRidPercentageTearOff {
  const _$SpecificRidPercentageTearOff();

  _SpecificRidPercentage call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) {
    return _SpecificRidPercentage(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      calOffset: calOffset,
      appType: appType,
    );
  }

  SpecificRidPercentage fromJson(Map<String, Object> json) {
    return SpecificRidPercentage.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidPercentage = _$SpecificRidPercentageTearOff();

/// @nodoc
mixin _$SpecificRidPercentage {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get calOffset => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidPercentageCopyWith<SpecificRidPercentage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidPercentageCopyWith<$Res> {
  factory $SpecificRidPercentageCopyWith(SpecificRidPercentage value,
          $Res Function(SpecificRidPercentage) then) =
      _$SpecificRidPercentageCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class _$SpecificRidPercentageCopyWithImpl<$Res>
    implements $SpecificRidPercentageCopyWith<$Res> {
  _$SpecificRidPercentageCopyWithImpl(this._value, this._then);

  final SpecificRidPercentage _value;
  // ignore: unused_field
  final $Res Function(SpecificRidPercentage) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidPercentageCopyWith<$Res>
    implements $SpecificRidPercentageCopyWith<$Res> {
  factory _$SpecificRidPercentageCopyWith(_SpecificRidPercentage value,
          $Res Function(_SpecificRidPercentage) then) =
      __$SpecificRidPercentageCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class __$SpecificRidPercentageCopyWithImpl<$Res>
    extends _$SpecificRidPercentageCopyWithImpl<$Res>
    implements _$SpecificRidPercentageCopyWith<$Res> {
  __$SpecificRidPercentageCopyWithImpl(_SpecificRidPercentage _value,
      $Res Function(_SpecificRidPercentage) _then)
      : super(_value, (v) => _then(v as _SpecificRidPercentage));

  @override
  _SpecificRidPercentage get _value => super._value as _SpecificRidPercentage;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidPercentage(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidPercentage implements _SpecificRidPercentage {
  const _$_SpecificRidPercentage(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues,
      required this.calOffset,
      required this.appType});

  factory _$_SpecificRidPercentage.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidPercentageFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int calOffset;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidPercentage(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, calOffset: $calOffset, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidPercentage &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.calOffset, calOffset) ||
                const DeepCollectionEquality()
                    .equals(other.calOffset, calOffset)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(calOffset) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidPercentageCopyWith<_SpecificRidPercentage> get copyWith =>
      __$SpecificRidPercentageCopyWithImpl<_SpecificRidPercentage>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidPercentageToJson(this);
  }
}

abstract class _SpecificRidPercentage implements SpecificRidPercentage {
  const factory _SpecificRidPercentage(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) = _$_SpecificRidPercentage;

  factory _SpecificRidPercentage.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidPercentage.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get calOffset => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidPercentageCopyWith<_SpecificRidPercentage> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidPositioner _$SpecificRidPositionerFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidPositioner.fromJson(json);
}

/// @nodoc
class _$SpecificRidPositionerTearOff {
  const _$SpecificRidPositionerTearOff();

  _SpecificRidPositioner call(
      {required int currentPos,
      required int transTime,
      required int remainTime,
      required int minMeaValue,
      required int maxMeaValue,
      required int resetMinMaxMeaValues,
      required int minLimit,
      required int maxLimit,
      required int appType}) {
    return _SpecificRidPositioner(
      currentPos: currentPos,
      transTime: transTime,
      remainTime: remainTime,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      minLimit: minLimit,
      maxLimit: maxLimit,
      appType: appType,
    );
  }

  SpecificRidPositioner fromJson(Map<String, Object> json) {
    return SpecificRidPositioner.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidPositioner = _$SpecificRidPositionerTearOff();

/// @nodoc
mixin _$SpecificRidPositioner {
  int get currentPos => throw _privateConstructorUsedError;
  int get transTime => throw _privateConstructorUsedError;
  int get remainTime => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get minLimit => throw _privateConstructorUsedError;
  int get maxLimit => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidPositionerCopyWith<SpecificRidPositioner> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidPositionerCopyWith<$Res> {
  factory $SpecificRidPositionerCopyWith(SpecificRidPositioner value,
          $Res Function(SpecificRidPositioner) then) =
      _$SpecificRidPositionerCopyWithImpl<$Res>;
  $Res call(
      {int currentPos,
      int transTime,
      int remainTime,
      int minMeaValue,
      int maxMeaValue,
      int resetMinMaxMeaValues,
      int minLimit,
      int maxLimit,
      int appType});
}

/// @nodoc
class _$SpecificRidPositionerCopyWithImpl<$Res>
    implements $SpecificRidPositionerCopyWith<$Res> {
  _$SpecificRidPositionerCopyWithImpl(this._value, this._then);

  final SpecificRidPositioner _value;
  // ignore: unused_field
  final $Res Function(SpecificRidPositioner) _then;

  @override
  $Res call({
    Object? currentPos = freezed,
    Object? transTime = freezed,
    Object? remainTime = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? minLimit = freezed,
    Object? maxLimit = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      currentPos: currentPos == freezed
          ? _value.currentPos
          : currentPos // ignore: cast_nullable_to_non_nullable
              as int,
      transTime: transTime == freezed
          ? _value.transTime
          : transTime // ignore: cast_nullable_to_non_nullable
              as int,
      remainTime: remainTime == freezed
          ? _value.remainTime
          : remainTime // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      minLimit: minLimit == freezed
          ? _value.minLimit
          : minLimit // ignore: cast_nullable_to_non_nullable
              as int,
      maxLimit: maxLimit == freezed
          ? _value.maxLimit
          : maxLimit // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidPositionerCopyWith<$Res>
    implements $SpecificRidPositionerCopyWith<$Res> {
  factory _$SpecificRidPositionerCopyWith(_SpecificRidPositioner value,
          $Res Function(_SpecificRidPositioner) then) =
      __$SpecificRidPositionerCopyWithImpl<$Res>;
  @override
  $Res call(
      {int currentPos,
      int transTime,
      int remainTime,
      int minMeaValue,
      int maxMeaValue,
      int resetMinMaxMeaValues,
      int minLimit,
      int maxLimit,
      int appType});
}

/// @nodoc
class __$SpecificRidPositionerCopyWithImpl<$Res>
    extends _$SpecificRidPositionerCopyWithImpl<$Res>
    implements _$SpecificRidPositionerCopyWith<$Res> {
  __$SpecificRidPositionerCopyWithImpl(_SpecificRidPositioner _value,
      $Res Function(_SpecificRidPositioner) _then)
      : super(_value, (v) => _then(v as _SpecificRidPositioner));

  @override
  _SpecificRidPositioner get _value => super._value as _SpecificRidPositioner;

  @override
  $Res call({
    Object? currentPos = freezed,
    Object? transTime = freezed,
    Object? remainTime = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? minLimit = freezed,
    Object? maxLimit = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidPositioner(
      currentPos: currentPos == freezed
          ? _value.currentPos
          : currentPos // ignore: cast_nullable_to_non_nullable
              as int,
      transTime: transTime == freezed
          ? _value.transTime
          : transTime // ignore: cast_nullable_to_non_nullable
              as int,
      remainTime: remainTime == freezed
          ? _value.remainTime
          : remainTime // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      minLimit: minLimit == freezed
          ? _value.minLimit
          : minLimit // ignore: cast_nullable_to_non_nullable
              as int,
      maxLimit: maxLimit == freezed
          ? _value.maxLimit
          : maxLimit // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidPositioner implements _SpecificRidPositioner {
  const _$_SpecificRidPositioner(
      {required this.currentPos,
      required this.transTime,
      required this.remainTime,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.resetMinMaxMeaValues,
      required this.minLimit,
      required this.maxLimit,
      required this.appType});

  factory _$_SpecificRidPositioner.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidPositionerFromJson(json);

  @override
  final int currentPos;
  @override
  final int transTime;
  @override
  final int remainTime;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int minLimit;
  @override
  final int maxLimit;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidPositioner(currentPos: $currentPos, transTime: $transTime, remainTime: $remainTime, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, minLimit: $minLimit, maxLimit: $maxLimit, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidPositioner &&
            (identical(other.currentPos, currentPos) ||
                const DeepCollectionEquality()
                    .equals(other.currentPos, currentPos)) &&
            (identical(other.transTime, transTime) ||
                const DeepCollectionEquality()
                    .equals(other.transTime, transTime)) &&
            (identical(other.remainTime, remainTime) ||
                const DeepCollectionEquality()
                    .equals(other.remainTime, remainTime)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.minLimit, minLimit) ||
                const DeepCollectionEquality()
                    .equals(other.minLimit, minLimit)) &&
            (identical(other.maxLimit, maxLimit) ||
                const DeepCollectionEquality()
                    .equals(other.maxLimit, maxLimit)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(currentPos) ^
      const DeepCollectionEquality().hash(transTime) ^
      const DeepCollectionEquality().hash(remainTime) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(minLimit) ^
      const DeepCollectionEquality().hash(maxLimit) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidPositionerCopyWith<_SpecificRidPositioner> get copyWith =>
      __$SpecificRidPositionerCopyWithImpl<_SpecificRidPositioner>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidPositionerToJson(this);
  }
}

abstract class _SpecificRidPositioner implements SpecificRidPositioner {
  const factory _SpecificRidPositioner(
      {required int currentPos,
      required int transTime,
      required int remainTime,
      required int minMeaValue,
      required int maxMeaValue,
      required int resetMinMaxMeaValues,
      required int minLimit,
      required int maxLimit,
      required int appType}) = _$_SpecificRidPositioner;

  factory _SpecificRidPositioner.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidPositioner.fromJson;

  @override
  int get currentPos => throw _privateConstructorUsedError;
  @override
  int get transTime => throw _privateConstructorUsedError;
  @override
  int get remainTime => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get minLimit => throw _privateConstructorUsedError;
  @override
  int get maxLimit => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidPositionerCopyWith<_SpecificRidPositioner> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidPower _$SpecificRidPowerFromJson(Map<String, dynamic> json) {
  return _SpecificRidPower.fromJson(json);
}

/// @nodoc
class _$SpecificRidPowerTearOff {
  const _$SpecificRidPowerTearOff();

  _SpecificRidPower call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) {
    return _SpecificRidPower(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      calOffset: calOffset,
      appType: appType,
    );
  }

  SpecificRidPower fromJson(Map<String, Object> json) {
    return SpecificRidPower.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidPower = _$SpecificRidPowerTearOff();

/// @nodoc
mixin _$SpecificRidPower {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get calOffset => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidPowerCopyWith<SpecificRidPower> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidPowerCopyWith<$Res> {
  factory $SpecificRidPowerCopyWith(
          SpecificRidPower value, $Res Function(SpecificRidPower) then) =
      _$SpecificRidPowerCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class _$SpecificRidPowerCopyWithImpl<$Res>
    implements $SpecificRidPowerCopyWith<$Res> {
  _$SpecificRidPowerCopyWithImpl(this._value, this._then);

  final SpecificRidPower _value;
  // ignore: unused_field
  final $Res Function(SpecificRidPower) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidPowerCopyWith<$Res>
    implements $SpecificRidPowerCopyWith<$Res> {
  factory _$SpecificRidPowerCopyWith(
          _SpecificRidPower value, $Res Function(_SpecificRidPower) then) =
      __$SpecificRidPowerCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class __$SpecificRidPowerCopyWithImpl<$Res>
    extends _$SpecificRidPowerCopyWithImpl<$Res>
    implements _$SpecificRidPowerCopyWith<$Res> {
  __$SpecificRidPowerCopyWithImpl(
      _SpecificRidPower _value, $Res Function(_SpecificRidPower) _then)
      : super(_value, (v) => _then(v as _SpecificRidPower));

  @override
  _SpecificRidPower get _value => super._value as _SpecificRidPower;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidPower(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidPower implements _SpecificRidPower {
  const _$_SpecificRidPower(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues,
      required this.calOffset,
      required this.appType});

  factory _$_SpecificRidPower.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidPowerFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int calOffset;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidPower(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, calOffset: $calOffset, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidPower &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.calOffset, calOffset) ||
                const DeepCollectionEquality()
                    .equals(other.calOffset, calOffset)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(calOffset) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidPowerCopyWith<_SpecificRidPower> get copyWith =>
      __$SpecificRidPowerCopyWithImpl<_SpecificRidPower>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidPowerToJson(this);
  }
}

abstract class _SpecificRidPower implements SpecificRidPower {
  const factory _SpecificRidPower(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) = _$_SpecificRidPower;

  factory _SpecificRidPower.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidPower.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get calOffset => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidPowerCopyWith<_SpecificRidPower> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidPowerFactor _$SpecificRidPowerFactorFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidPowerFactor.fromJson(json);
}

/// @nodoc
class _$SpecificRidPowerFactorTearOff {
  const _$SpecificRidPowerFactorTearOff();

  _SpecificRidPowerFactor call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) {
    return _SpecificRidPowerFactor(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      calOffset: calOffset,
      appType: appType,
    );
  }

  SpecificRidPowerFactor fromJson(Map<String, Object> json) {
    return SpecificRidPowerFactor.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidPowerFactor = _$SpecificRidPowerFactorTearOff();

/// @nodoc
mixin _$SpecificRidPowerFactor {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get calOffset => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidPowerFactorCopyWith<SpecificRidPowerFactor> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidPowerFactorCopyWith<$Res> {
  factory $SpecificRidPowerFactorCopyWith(SpecificRidPowerFactor value,
          $Res Function(SpecificRidPowerFactor) then) =
      _$SpecificRidPowerFactorCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class _$SpecificRidPowerFactorCopyWithImpl<$Res>
    implements $SpecificRidPowerFactorCopyWith<$Res> {
  _$SpecificRidPowerFactorCopyWithImpl(this._value, this._then);

  final SpecificRidPowerFactor _value;
  // ignore: unused_field
  final $Res Function(SpecificRidPowerFactor) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidPowerFactorCopyWith<$Res>
    implements $SpecificRidPowerFactorCopyWith<$Res> {
  factory _$SpecificRidPowerFactorCopyWith(_SpecificRidPowerFactor value,
          $Res Function(_SpecificRidPowerFactor) then) =
      __$SpecificRidPowerFactorCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class __$SpecificRidPowerFactorCopyWithImpl<$Res>
    extends _$SpecificRidPowerFactorCopyWithImpl<$Res>
    implements _$SpecificRidPowerFactorCopyWith<$Res> {
  __$SpecificRidPowerFactorCopyWithImpl(_SpecificRidPowerFactor _value,
      $Res Function(_SpecificRidPowerFactor) _then)
      : super(_value, (v) => _then(v as _SpecificRidPowerFactor));

  @override
  _SpecificRidPowerFactor get _value => super._value as _SpecificRidPowerFactor;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidPowerFactor(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidPowerFactor implements _SpecificRidPowerFactor {
  const _$_SpecificRidPowerFactor(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues,
      required this.calOffset,
      required this.appType});

  factory _$_SpecificRidPowerFactor.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidPowerFactorFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int calOffset;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidPowerFactor(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, calOffset: $calOffset, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidPowerFactor &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.calOffset, calOffset) ||
                const DeepCollectionEquality()
                    .equals(other.calOffset, calOffset)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(calOffset) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidPowerFactorCopyWith<_SpecificRidPowerFactor> get copyWith =>
      __$SpecificRidPowerFactorCopyWithImpl<_SpecificRidPowerFactor>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidPowerFactorToJson(this);
  }
}

abstract class _SpecificRidPowerFactor implements SpecificRidPowerFactor {
  const factory _SpecificRidPowerFactor(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) = _$_SpecificRidPowerFactor;

  factory _SpecificRidPowerFactor.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidPowerFactor.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get calOffset => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidPowerFactorCopyWith<_SpecificRidPowerFactor> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidPresence _$SpecificRidPresenceFromJson(Map<String, dynamic> json) {
  return _SpecificRidPresence.fromJson(json);
}

/// @nodoc
class _$SpecificRidPresenceTearOff {
  const _$SpecificRidPresenceTearOff();

  _SpecificRidPresence call(
      {required int dInState,
      required int counter,
      required int counterReset,
      required int sensorType,
      required int busyToClearDelay,
      required int clearToBusyDelay}) {
    return _SpecificRidPresence(
      dInState: dInState,
      counter: counter,
      counterReset: counterReset,
      sensorType: sensorType,
      busyToClearDelay: busyToClearDelay,
      clearToBusyDelay: clearToBusyDelay,
    );
  }

  SpecificRidPresence fromJson(Map<String, Object> json) {
    return SpecificRidPresence.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidPresence = _$SpecificRidPresenceTearOff();

/// @nodoc
mixin _$SpecificRidPresence {
  int get dInState => throw _privateConstructorUsedError;
  int get counter => throw _privateConstructorUsedError;
  int get counterReset => throw _privateConstructorUsedError;
  int get sensorType => throw _privateConstructorUsedError;
  int get busyToClearDelay => throw _privateConstructorUsedError;
  int get clearToBusyDelay => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidPresenceCopyWith<SpecificRidPresence> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidPresenceCopyWith<$Res> {
  factory $SpecificRidPresenceCopyWith(
          SpecificRidPresence value, $Res Function(SpecificRidPresence) then) =
      _$SpecificRidPresenceCopyWithImpl<$Res>;
  $Res call(
      {int dInState,
      int counter,
      int counterReset,
      int sensorType,
      int busyToClearDelay,
      int clearToBusyDelay});
}

/// @nodoc
class _$SpecificRidPresenceCopyWithImpl<$Res>
    implements $SpecificRidPresenceCopyWith<$Res> {
  _$SpecificRidPresenceCopyWithImpl(this._value, this._then);

  final SpecificRidPresence _value;
  // ignore: unused_field
  final $Res Function(SpecificRidPresence) _then;

  @override
  $Res call({
    Object? dInState = freezed,
    Object? counter = freezed,
    Object? counterReset = freezed,
    Object? sensorType = freezed,
    Object? busyToClearDelay = freezed,
    Object? clearToBusyDelay = freezed,
  }) {
    return _then(_value.copyWith(
      dInState: dInState == freezed
          ? _value.dInState
          : dInState // ignore: cast_nullable_to_non_nullable
              as int,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as int,
      counterReset: counterReset == freezed
          ? _value.counterReset
          : counterReset // ignore: cast_nullable_to_non_nullable
              as int,
      sensorType: sensorType == freezed
          ? _value.sensorType
          : sensorType // ignore: cast_nullable_to_non_nullable
              as int,
      busyToClearDelay: busyToClearDelay == freezed
          ? _value.busyToClearDelay
          : busyToClearDelay // ignore: cast_nullable_to_non_nullable
              as int,
      clearToBusyDelay: clearToBusyDelay == freezed
          ? _value.clearToBusyDelay
          : clearToBusyDelay // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidPresenceCopyWith<$Res>
    implements $SpecificRidPresenceCopyWith<$Res> {
  factory _$SpecificRidPresenceCopyWith(_SpecificRidPresence value,
          $Res Function(_SpecificRidPresence) then) =
      __$SpecificRidPresenceCopyWithImpl<$Res>;
  @override
  $Res call(
      {int dInState,
      int counter,
      int counterReset,
      int sensorType,
      int busyToClearDelay,
      int clearToBusyDelay});
}

/// @nodoc
class __$SpecificRidPresenceCopyWithImpl<$Res>
    extends _$SpecificRidPresenceCopyWithImpl<$Res>
    implements _$SpecificRidPresenceCopyWith<$Res> {
  __$SpecificRidPresenceCopyWithImpl(
      _SpecificRidPresence _value, $Res Function(_SpecificRidPresence) _then)
      : super(_value, (v) => _then(v as _SpecificRidPresence));

  @override
  _SpecificRidPresence get _value => super._value as _SpecificRidPresence;

  @override
  $Res call({
    Object? dInState = freezed,
    Object? counter = freezed,
    Object? counterReset = freezed,
    Object? sensorType = freezed,
    Object? busyToClearDelay = freezed,
    Object? clearToBusyDelay = freezed,
  }) {
    return _then(_SpecificRidPresence(
      dInState: dInState == freezed
          ? _value.dInState
          : dInState // ignore: cast_nullable_to_non_nullable
              as int,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as int,
      counterReset: counterReset == freezed
          ? _value.counterReset
          : counterReset // ignore: cast_nullable_to_non_nullable
              as int,
      sensorType: sensorType == freezed
          ? _value.sensorType
          : sensorType // ignore: cast_nullable_to_non_nullable
              as int,
      busyToClearDelay: busyToClearDelay == freezed
          ? _value.busyToClearDelay
          : busyToClearDelay // ignore: cast_nullable_to_non_nullable
              as int,
      clearToBusyDelay: clearToBusyDelay == freezed
          ? _value.clearToBusyDelay
          : clearToBusyDelay // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidPresence implements _SpecificRidPresence {
  const _$_SpecificRidPresence(
      {required this.dInState,
      required this.counter,
      required this.counterReset,
      required this.sensorType,
      required this.busyToClearDelay,
      required this.clearToBusyDelay});

  factory _$_SpecificRidPresence.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidPresenceFromJson(json);

  @override
  final int dInState;
  @override
  final int counter;
  @override
  final int counterReset;
  @override
  final int sensorType;
  @override
  final int busyToClearDelay;
  @override
  final int clearToBusyDelay;

  @override
  String toString() {
    return 'SpecificRidPresence(dInState: $dInState, counter: $counter, counterReset: $counterReset, sensorType: $sensorType, busyToClearDelay: $busyToClearDelay, clearToBusyDelay: $clearToBusyDelay)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidPresence &&
            (identical(other.dInState, dInState) ||
                const DeepCollectionEquality()
                    .equals(other.dInState, dInState)) &&
            (identical(other.counter, counter) ||
                const DeepCollectionEquality()
                    .equals(other.counter, counter)) &&
            (identical(other.counterReset, counterReset) ||
                const DeepCollectionEquality()
                    .equals(other.counterReset, counterReset)) &&
            (identical(other.sensorType, sensorType) ||
                const DeepCollectionEquality()
                    .equals(other.sensorType, sensorType)) &&
            (identical(other.busyToClearDelay, busyToClearDelay) ||
                const DeepCollectionEquality()
                    .equals(other.busyToClearDelay, busyToClearDelay)) &&
            (identical(other.clearToBusyDelay, clearToBusyDelay) ||
                const DeepCollectionEquality()
                    .equals(other.clearToBusyDelay, clearToBusyDelay)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(dInState) ^
      const DeepCollectionEquality().hash(counter) ^
      const DeepCollectionEquality().hash(counterReset) ^
      const DeepCollectionEquality().hash(sensorType) ^
      const DeepCollectionEquality().hash(busyToClearDelay) ^
      const DeepCollectionEquality().hash(clearToBusyDelay);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidPresenceCopyWith<_SpecificRidPresence> get copyWith =>
      __$SpecificRidPresenceCopyWithImpl<_SpecificRidPresence>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidPresenceToJson(this);
  }
}

abstract class _SpecificRidPresence implements SpecificRidPresence {
  const factory _SpecificRidPresence(
      {required int dInState,
      required int counter,
      required int counterReset,
      required int sensorType,
      required int busyToClearDelay,
      required int clearToBusyDelay}) = _$_SpecificRidPresence;

  factory _SpecificRidPresence.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidPresence.fromJson;

  @override
  int get dInState => throw _privateConstructorUsedError;
  @override
  int get counter => throw _privateConstructorUsedError;
  @override
  int get counterReset => throw _privateConstructorUsedError;
  @override
  int get sensorType => throw _privateConstructorUsedError;
  @override
  int get busyToClearDelay => throw _privateConstructorUsedError;
  @override
  int get clearToBusyDelay => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidPresenceCopyWith<_SpecificRidPresence> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidPressure _$SpecificRidPressureFromJson(Map<String, dynamic> json) {
  return _SpecificRidPressure.fromJson(json);
}

/// @nodoc
class _$SpecificRidPressureTearOff {
  const _$SpecificRidPressureTearOff();

  _SpecificRidPressure call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) {
    return _SpecificRidPressure(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      calOffset: calOffset,
      appType: appType,
    );
  }

  SpecificRidPressure fromJson(Map<String, Object> json) {
    return SpecificRidPressure.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidPressure = _$SpecificRidPressureTearOff();

/// @nodoc
mixin _$SpecificRidPressure {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get calOffset => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidPressureCopyWith<SpecificRidPressure> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidPressureCopyWith<$Res> {
  factory $SpecificRidPressureCopyWith(
          SpecificRidPressure value, $Res Function(SpecificRidPressure) then) =
      _$SpecificRidPressureCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class _$SpecificRidPressureCopyWithImpl<$Res>
    implements $SpecificRidPressureCopyWith<$Res> {
  _$SpecificRidPressureCopyWithImpl(this._value, this._then);

  final SpecificRidPressure _value;
  // ignore: unused_field
  final $Res Function(SpecificRidPressure) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidPressureCopyWith<$Res>
    implements $SpecificRidPressureCopyWith<$Res> {
  factory _$SpecificRidPressureCopyWith(_SpecificRidPressure value,
          $Res Function(_SpecificRidPressure) then) =
      __$SpecificRidPressureCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class __$SpecificRidPressureCopyWithImpl<$Res>
    extends _$SpecificRidPressureCopyWithImpl<$Res>
    implements _$SpecificRidPressureCopyWith<$Res> {
  __$SpecificRidPressureCopyWithImpl(
      _SpecificRidPressure _value, $Res Function(_SpecificRidPressure) _then)
      : super(_value, (v) => _then(v as _SpecificRidPressure));

  @override
  _SpecificRidPressure get _value => super._value as _SpecificRidPressure;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidPressure(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidPressure implements _SpecificRidPressure {
  const _$_SpecificRidPressure(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues,
      required this.calOffset,
      required this.appType});

  factory _$_SpecificRidPressure.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidPressureFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int calOffset;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidPressure(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, calOffset: $calOffset, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidPressure &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.calOffset, calOffset) ||
                const DeepCollectionEquality()
                    .equals(other.calOffset, calOffset)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(calOffset) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidPressureCopyWith<_SpecificRidPressure> get copyWith =>
      __$SpecificRidPressureCopyWithImpl<_SpecificRidPressure>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidPressureToJson(this);
  }
}

abstract class _SpecificRidPressure implements SpecificRidPressure {
  const factory _SpecificRidPressure(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) = _$_SpecificRidPressure;

  factory _SpecificRidPressure.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidPressure.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get calOffset => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidPressureCopyWith<_SpecificRidPressure> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidPushButton _$SpecificRidPushButtonFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidPushButton.fromJson(json);
}

/// @nodoc
class _$SpecificRidPushButtonTearOff {
  const _$SpecificRidPushButtonTearOff();

  _SpecificRidPushButton call(
      {required int dInState, required int counter, required int appType}) {
    return _SpecificRidPushButton(
      dInState: dInState,
      counter: counter,
      appType: appType,
    );
  }

  SpecificRidPushButton fromJson(Map<String, Object> json) {
    return SpecificRidPushButton.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidPushButton = _$SpecificRidPushButtonTearOff();

/// @nodoc
mixin _$SpecificRidPushButton {
  int get dInState => throw _privateConstructorUsedError;
  int get counter => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidPushButtonCopyWith<SpecificRidPushButton> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidPushButtonCopyWith<$Res> {
  factory $SpecificRidPushButtonCopyWith(SpecificRidPushButton value,
          $Res Function(SpecificRidPushButton) then) =
      _$SpecificRidPushButtonCopyWithImpl<$Res>;
  $Res call({int dInState, int counter, int appType});
}

/// @nodoc
class _$SpecificRidPushButtonCopyWithImpl<$Res>
    implements $SpecificRidPushButtonCopyWith<$Res> {
  _$SpecificRidPushButtonCopyWithImpl(this._value, this._then);

  final SpecificRidPushButton _value;
  // ignore: unused_field
  final $Res Function(SpecificRidPushButton) _then;

  @override
  $Res call({
    Object? dInState = freezed,
    Object? counter = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      dInState: dInState == freezed
          ? _value.dInState
          : dInState // ignore: cast_nullable_to_non_nullable
              as int,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidPushButtonCopyWith<$Res>
    implements $SpecificRidPushButtonCopyWith<$Res> {
  factory _$SpecificRidPushButtonCopyWith(_SpecificRidPushButton value,
          $Res Function(_SpecificRidPushButton) then) =
      __$SpecificRidPushButtonCopyWithImpl<$Res>;
  @override
  $Res call({int dInState, int counter, int appType});
}

/// @nodoc
class __$SpecificRidPushButtonCopyWithImpl<$Res>
    extends _$SpecificRidPushButtonCopyWithImpl<$Res>
    implements _$SpecificRidPushButtonCopyWith<$Res> {
  __$SpecificRidPushButtonCopyWithImpl(_SpecificRidPushButton _value,
      $Res Function(_SpecificRidPushButton) _then)
      : super(_value, (v) => _then(v as _SpecificRidPushButton));

  @override
  _SpecificRidPushButton get _value => super._value as _SpecificRidPushButton;

  @override
  $Res call({
    Object? dInState = freezed,
    Object? counter = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidPushButton(
      dInState: dInState == freezed
          ? _value.dInState
          : dInState // ignore: cast_nullable_to_non_nullable
              as int,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidPushButton implements _SpecificRidPushButton {
  const _$_SpecificRidPushButton(
      {required this.dInState, required this.counter, required this.appType});

  factory _$_SpecificRidPushButton.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidPushButtonFromJson(json);

  @override
  final int dInState;
  @override
  final int counter;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidPushButton(dInState: $dInState, counter: $counter, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidPushButton &&
            (identical(other.dInState, dInState) ||
                const DeepCollectionEquality()
                    .equals(other.dInState, dInState)) &&
            (identical(other.counter, counter) ||
                const DeepCollectionEquality()
                    .equals(other.counter, counter)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(dInState) ^
      const DeepCollectionEquality().hash(counter) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidPushButtonCopyWith<_SpecificRidPushButton> get copyWith =>
      __$SpecificRidPushButtonCopyWithImpl<_SpecificRidPushButton>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidPushButtonToJson(this);
  }
}

abstract class _SpecificRidPushButton implements SpecificRidPushButton {
  const factory _SpecificRidPushButton(
      {required int dInState,
      required int counter,
      required int appType}) = _$_SpecificRidPushButton;

  factory _SpecificRidPushButton.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidPushButton.fromJson;

  @override
  int get dInState => throw _privateConstructorUsedError;
  @override
  int get counter => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidPushButtonCopyWith<_SpecificRidPushButton> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidPwrCtrl _$SpecificRidPwrCtrlFromJson(Map<String, dynamic> json) {
  return _SpecificRidPwrCtrl.fromJson(json);
}

/// @nodoc
class _$SpecificRidPwrCtrlTearOff {
  const _$SpecificRidPwrCtrlTearOff();

  _SpecificRidPwrCtrl call(
      {required int onOff,
      required int dimmer,
      required int onTime,
      required int cumulActivePwr,
      required int pwrFactor}) {
    return _SpecificRidPwrCtrl(
      onOff: onOff,
      dimmer: dimmer,
      onTime: onTime,
      cumulActivePwr: cumulActivePwr,
      pwrFactor: pwrFactor,
    );
  }

  SpecificRidPwrCtrl fromJson(Map<String, Object> json) {
    return SpecificRidPwrCtrl.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidPwrCtrl = _$SpecificRidPwrCtrlTearOff();

/// @nodoc
mixin _$SpecificRidPwrCtrl {
  int get onOff => throw _privateConstructorUsedError;
  int get dimmer => throw _privateConstructorUsedError;
  int get onTime => throw _privateConstructorUsedError;
  int get cumulActivePwr => throw _privateConstructorUsedError;
  int get pwrFactor => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidPwrCtrlCopyWith<SpecificRidPwrCtrl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidPwrCtrlCopyWith<$Res> {
  factory $SpecificRidPwrCtrlCopyWith(
          SpecificRidPwrCtrl value, $Res Function(SpecificRidPwrCtrl) then) =
      _$SpecificRidPwrCtrlCopyWithImpl<$Res>;
  $Res call(
      {int onOff, int dimmer, int onTime, int cumulActivePwr, int pwrFactor});
}

/// @nodoc
class _$SpecificRidPwrCtrlCopyWithImpl<$Res>
    implements $SpecificRidPwrCtrlCopyWith<$Res> {
  _$SpecificRidPwrCtrlCopyWithImpl(this._value, this._then);

  final SpecificRidPwrCtrl _value;
  // ignore: unused_field
  final $Res Function(SpecificRidPwrCtrl) _then;

  @override
  $Res call({
    Object? onOff = freezed,
    Object? dimmer = freezed,
    Object? onTime = freezed,
    Object? cumulActivePwr = freezed,
    Object? pwrFactor = freezed,
  }) {
    return _then(_value.copyWith(
      onOff: onOff == freezed
          ? _value.onOff
          : onOff // ignore: cast_nullable_to_non_nullable
              as int,
      dimmer: dimmer == freezed
          ? _value.dimmer
          : dimmer // ignore: cast_nullable_to_non_nullable
              as int,
      onTime: onTime == freezed
          ? _value.onTime
          : onTime // ignore: cast_nullable_to_non_nullable
              as int,
      cumulActivePwr: cumulActivePwr == freezed
          ? _value.cumulActivePwr
          : cumulActivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      pwrFactor: pwrFactor == freezed
          ? _value.pwrFactor
          : pwrFactor // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidPwrCtrlCopyWith<$Res>
    implements $SpecificRidPwrCtrlCopyWith<$Res> {
  factory _$SpecificRidPwrCtrlCopyWith(
          _SpecificRidPwrCtrl value, $Res Function(_SpecificRidPwrCtrl) then) =
      __$SpecificRidPwrCtrlCopyWithImpl<$Res>;
  @override
  $Res call(
      {int onOff, int dimmer, int onTime, int cumulActivePwr, int pwrFactor});
}

/// @nodoc
class __$SpecificRidPwrCtrlCopyWithImpl<$Res>
    extends _$SpecificRidPwrCtrlCopyWithImpl<$Res>
    implements _$SpecificRidPwrCtrlCopyWith<$Res> {
  __$SpecificRidPwrCtrlCopyWithImpl(
      _SpecificRidPwrCtrl _value, $Res Function(_SpecificRidPwrCtrl) _then)
      : super(_value, (v) => _then(v as _SpecificRidPwrCtrl));

  @override
  _SpecificRidPwrCtrl get _value => super._value as _SpecificRidPwrCtrl;

  @override
  $Res call({
    Object? onOff = freezed,
    Object? dimmer = freezed,
    Object? onTime = freezed,
    Object? cumulActivePwr = freezed,
    Object? pwrFactor = freezed,
  }) {
    return _then(_SpecificRidPwrCtrl(
      onOff: onOff == freezed
          ? _value.onOff
          : onOff // ignore: cast_nullable_to_non_nullable
              as int,
      dimmer: dimmer == freezed
          ? _value.dimmer
          : dimmer // ignore: cast_nullable_to_non_nullable
              as int,
      onTime: onTime == freezed
          ? _value.onTime
          : onTime // ignore: cast_nullable_to_non_nullable
              as int,
      cumulActivePwr: cumulActivePwr == freezed
          ? _value.cumulActivePwr
          : cumulActivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      pwrFactor: pwrFactor == freezed
          ? _value.pwrFactor
          : pwrFactor // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidPwrCtrl implements _SpecificRidPwrCtrl {
  const _$_SpecificRidPwrCtrl(
      {required this.onOff,
      required this.dimmer,
      required this.onTime,
      required this.cumulActivePwr,
      required this.pwrFactor});

  factory _$_SpecificRidPwrCtrl.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidPwrCtrlFromJson(json);

  @override
  final int onOff;
  @override
  final int dimmer;
  @override
  final int onTime;
  @override
  final int cumulActivePwr;
  @override
  final int pwrFactor;

  @override
  String toString() {
    return 'SpecificRidPwrCtrl(onOff: $onOff, dimmer: $dimmer, onTime: $onTime, cumulActivePwr: $cumulActivePwr, pwrFactor: $pwrFactor)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidPwrCtrl &&
            (identical(other.onOff, onOff) ||
                const DeepCollectionEquality().equals(other.onOff, onOff)) &&
            (identical(other.dimmer, dimmer) ||
                const DeepCollectionEquality().equals(other.dimmer, dimmer)) &&
            (identical(other.onTime, onTime) ||
                const DeepCollectionEquality().equals(other.onTime, onTime)) &&
            (identical(other.cumulActivePwr, cumulActivePwr) ||
                const DeepCollectionEquality()
                    .equals(other.cumulActivePwr, cumulActivePwr)) &&
            (identical(other.pwrFactor, pwrFactor) ||
                const DeepCollectionEquality()
                    .equals(other.pwrFactor, pwrFactor)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(onOff) ^
      const DeepCollectionEquality().hash(dimmer) ^
      const DeepCollectionEquality().hash(onTime) ^
      const DeepCollectionEquality().hash(cumulActivePwr) ^
      const DeepCollectionEquality().hash(pwrFactor);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidPwrCtrlCopyWith<_SpecificRidPwrCtrl> get copyWith =>
      __$SpecificRidPwrCtrlCopyWithImpl<_SpecificRidPwrCtrl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidPwrCtrlToJson(this);
  }
}

abstract class _SpecificRidPwrCtrl implements SpecificRidPwrCtrl {
  const factory _SpecificRidPwrCtrl(
      {required int onOff,
      required int dimmer,
      required int onTime,
      required int cumulActivePwr,
      required int pwrFactor}) = _$_SpecificRidPwrCtrl;

  factory _SpecificRidPwrCtrl.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidPwrCtrl.fromJson;

  @override
  int get onOff => throw _privateConstructorUsedError;
  @override
  int get dimmer => throw _privateConstructorUsedError;
  @override
  int get onTime => throw _privateConstructorUsedError;
  @override
  int get cumulActivePwr => throw _privateConstructorUsedError;
  @override
  int get pwrFactor => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidPwrCtrlCopyWith<_SpecificRidPwrCtrl> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidPwrMea _$SpecificRidPwrMeaFromJson(Map<String, dynamic> json) {
  return _SpecificRidPwrMea.fromJson(json);
}

/// @nodoc
class _$SpecificRidPwrMeaTearOff {
  const _$SpecificRidPwrMeaTearOff();

  _SpecificRidPwrMea call(
      {required int instActivePwr,
      required int minMeaActivePwr,
      required int maxMeaActivePwr,
      required int minRangeActivePwr,
      required int maxRangeActivePwr,
      required int cumulActivePwr,
      required int activePwrCal,
      required int instReactivePwr,
      required int minMeaReactivePwr,
      required int maxMeaReactivePwr,
      required int minRangeReactivePwr,
      required int maxRangeReactivePwr,
      required int resetMinMaxMeaValues,
      required int cumulReactivePwr,
      required int reactivePwrCal,
      required int pwrFactor,
      required int currCal,
      required int resetCumulEnergy}) {
    return _SpecificRidPwrMea(
      instActivePwr: instActivePwr,
      minMeaActivePwr: minMeaActivePwr,
      maxMeaActivePwr: maxMeaActivePwr,
      minRangeActivePwr: minRangeActivePwr,
      maxRangeActivePwr: maxRangeActivePwr,
      cumulActivePwr: cumulActivePwr,
      activePwrCal: activePwrCal,
      instReactivePwr: instReactivePwr,
      minMeaReactivePwr: minMeaReactivePwr,
      maxMeaReactivePwr: maxMeaReactivePwr,
      minRangeReactivePwr: minRangeReactivePwr,
      maxRangeReactivePwr: maxRangeReactivePwr,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      cumulReactivePwr: cumulReactivePwr,
      reactivePwrCal: reactivePwrCal,
      pwrFactor: pwrFactor,
      currCal: currCal,
      resetCumulEnergy: resetCumulEnergy,
    );
  }

  SpecificRidPwrMea fromJson(Map<String, Object> json) {
    return SpecificRidPwrMea.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidPwrMea = _$SpecificRidPwrMeaTearOff();

/// @nodoc
mixin _$SpecificRidPwrMea {
  int get instActivePwr => throw _privateConstructorUsedError;
  int get minMeaActivePwr => throw _privateConstructorUsedError;
  int get maxMeaActivePwr => throw _privateConstructorUsedError;
  int get minRangeActivePwr => throw _privateConstructorUsedError;
  int get maxRangeActivePwr => throw _privateConstructorUsedError;
  int get cumulActivePwr => throw _privateConstructorUsedError;
  int get activePwrCal => throw _privateConstructorUsedError;
  int get instReactivePwr => throw _privateConstructorUsedError;
  int get minMeaReactivePwr => throw _privateConstructorUsedError;
  int get maxMeaReactivePwr => throw _privateConstructorUsedError;
  int get minRangeReactivePwr => throw _privateConstructorUsedError;
  int get maxRangeReactivePwr => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get cumulReactivePwr => throw _privateConstructorUsedError;
  int get reactivePwrCal => throw _privateConstructorUsedError;
  int get pwrFactor => throw _privateConstructorUsedError;
  int get currCal => throw _privateConstructorUsedError;
  int get resetCumulEnergy => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidPwrMeaCopyWith<SpecificRidPwrMea> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidPwrMeaCopyWith<$Res> {
  factory $SpecificRidPwrMeaCopyWith(
          SpecificRidPwrMea value, $Res Function(SpecificRidPwrMea) then) =
      _$SpecificRidPwrMeaCopyWithImpl<$Res>;
  $Res call(
      {int instActivePwr,
      int minMeaActivePwr,
      int maxMeaActivePwr,
      int minRangeActivePwr,
      int maxRangeActivePwr,
      int cumulActivePwr,
      int activePwrCal,
      int instReactivePwr,
      int minMeaReactivePwr,
      int maxMeaReactivePwr,
      int minRangeReactivePwr,
      int maxRangeReactivePwr,
      int resetMinMaxMeaValues,
      int cumulReactivePwr,
      int reactivePwrCal,
      int pwrFactor,
      int currCal,
      int resetCumulEnergy});
}

/// @nodoc
class _$SpecificRidPwrMeaCopyWithImpl<$Res>
    implements $SpecificRidPwrMeaCopyWith<$Res> {
  _$SpecificRidPwrMeaCopyWithImpl(this._value, this._then);

  final SpecificRidPwrMea _value;
  // ignore: unused_field
  final $Res Function(SpecificRidPwrMea) _then;

  @override
  $Res call({
    Object? instActivePwr = freezed,
    Object? minMeaActivePwr = freezed,
    Object? maxMeaActivePwr = freezed,
    Object? minRangeActivePwr = freezed,
    Object? maxRangeActivePwr = freezed,
    Object? cumulActivePwr = freezed,
    Object? activePwrCal = freezed,
    Object? instReactivePwr = freezed,
    Object? minMeaReactivePwr = freezed,
    Object? maxMeaReactivePwr = freezed,
    Object? minRangeReactivePwr = freezed,
    Object? maxRangeReactivePwr = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? cumulReactivePwr = freezed,
    Object? reactivePwrCal = freezed,
    Object? pwrFactor = freezed,
    Object? currCal = freezed,
    Object? resetCumulEnergy = freezed,
  }) {
    return _then(_value.copyWith(
      instActivePwr: instActivePwr == freezed
          ? _value.instActivePwr
          : instActivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaActivePwr: minMeaActivePwr == freezed
          ? _value.minMeaActivePwr
          : minMeaActivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaActivePwr: maxMeaActivePwr == freezed
          ? _value.maxMeaActivePwr
          : maxMeaActivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeActivePwr: minRangeActivePwr == freezed
          ? _value.minRangeActivePwr
          : minRangeActivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeActivePwr: maxRangeActivePwr == freezed
          ? _value.maxRangeActivePwr
          : maxRangeActivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      cumulActivePwr: cumulActivePwr == freezed
          ? _value.cumulActivePwr
          : cumulActivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      activePwrCal: activePwrCal == freezed
          ? _value.activePwrCal
          : activePwrCal // ignore: cast_nullable_to_non_nullable
              as int,
      instReactivePwr: instReactivePwr == freezed
          ? _value.instReactivePwr
          : instReactivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaReactivePwr: minMeaReactivePwr == freezed
          ? _value.minMeaReactivePwr
          : minMeaReactivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaReactivePwr: maxMeaReactivePwr == freezed
          ? _value.maxMeaReactivePwr
          : maxMeaReactivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeReactivePwr: minRangeReactivePwr == freezed
          ? _value.minRangeReactivePwr
          : minRangeReactivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeReactivePwr: maxRangeReactivePwr == freezed
          ? _value.maxRangeReactivePwr
          : maxRangeReactivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      cumulReactivePwr: cumulReactivePwr == freezed
          ? _value.cumulReactivePwr
          : cumulReactivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      reactivePwrCal: reactivePwrCal == freezed
          ? _value.reactivePwrCal
          : reactivePwrCal // ignore: cast_nullable_to_non_nullable
              as int,
      pwrFactor: pwrFactor == freezed
          ? _value.pwrFactor
          : pwrFactor // ignore: cast_nullable_to_non_nullable
              as int,
      currCal: currCal == freezed
          ? _value.currCal
          : currCal // ignore: cast_nullable_to_non_nullable
              as int,
      resetCumulEnergy: resetCumulEnergy == freezed
          ? _value.resetCumulEnergy
          : resetCumulEnergy // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidPwrMeaCopyWith<$Res>
    implements $SpecificRidPwrMeaCopyWith<$Res> {
  factory _$SpecificRidPwrMeaCopyWith(
          _SpecificRidPwrMea value, $Res Function(_SpecificRidPwrMea) then) =
      __$SpecificRidPwrMeaCopyWithImpl<$Res>;
  @override
  $Res call(
      {int instActivePwr,
      int minMeaActivePwr,
      int maxMeaActivePwr,
      int minRangeActivePwr,
      int maxRangeActivePwr,
      int cumulActivePwr,
      int activePwrCal,
      int instReactivePwr,
      int minMeaReactivePwr,
      int maxMeaReactivePwr,
      int minRangeReactivePwr,
      int maxRangeReactivePwr,
      int resetMinMaxMeaValues,
      int cumulReactivePwr,
      int reactivePwrCal,
      int pwrFactor,
      int currCal,
      int resetCumulEnergy});
}

/// @nodoc
class __$SpecificRidPwrMeaCopyWithImpl<$Res>
    extends _$SpecificRidPwrMeaCopyWithImpl<$Res>
    implements _$SpecificRidPwrMeaCopyWith<$Res> {
  __$SpecificRidPwrMeaCopyWithImpl(
      _SpecificRidPwrMea _value, $Res Function(_SpecificRidPwrMea) _then)
      : super(_value, (v) => _then(v as _SpecificRidPwrMea));

  @override
  _SpecificRidPwrMea get _value => super._value as _SpecificRidPwrMea;

  @override
  $Res call({
    Object? instActivePwr = freezed,
    Object? minMeaActivePwr = freezed,
    Object? maxMeaActivePwr = freezed,
    Object? minRangeActivePwr = freezed,
    Object? maxRangeActivePwr = freezed,
    Object? cumulActivePwr = freezed,
    Object? activePwrCal = freezed,
    Object? instReactivePwr = freezed,
    Object? minMeaReactivePwr = freezed,
    Object? maxMeaReactivePwr = freezed,
    Object? minRangeReactivePwr = freezed,
    Object? maxRangeReactivePwr = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? cumulReactivePwr = freezed,
    Object? reactivePwrCal = freezed,
    Object? pwrFactor = freezed,
    Object? currCal = freezed,
    Object? resetCumulEnergy = freezed,
  }) {
    return _then(_SpecificRidPwrMea(
      instActivePwr: instActivePwr == freezed
          ? _value.instActivePwr
          : instActivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaActivePwr: minMeaActivePwr == freezed
          ? _value.minMeaActivePwr
          : minMeaActivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaActivePwr: maxMeaActivePwr == freezed
          ? _value.maxMeaActivePwr
          : maxMeaActivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeActivePwr: minRangeActivePwr == freezed
          ? _value.minRangeActivePwr
          : minRangeActivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeActivePwr: maxRangeActivePwr == freezed
          ? _value.maxRangeActivePwr
          : maxRangeActivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      cumulActivePwr: cumulActivePwr == freezed
          ? _value.cumulActivePwr
          : cumulActivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      activePwrCal: activePwrCal == freezed
          ? _value.activePwrCal
          : activePwrCal // ignore: cast_nullable_to_non_nullable
              as int,
      instReactivePwr: instReactivePwr == freezed
          ? _value.instReactivePwr
          : instReactivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaReactivePwr: minMeaReactivePwr == freezed
          ? _value.minMeaReactivePwr
          : minMeaReactivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaReactivePwr: maxMeaReactivePwr == freezed
          ? _value.maxMeaReactivePwr
          : maxMeaReactivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeReactivePwr: minRangeReactivePwr == freezed
          ? _value.minRangeReactivePwr
          : minRangeReactivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeReactivePwr: maxRangeReactivePwr == freezed
          ? _value.maxRangeReactivePwr
          : maxRangeReactivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      cumulReactivePwr: cumulReactivePwr == freezed
          ? _value.cumulReactivePwr
          : cumulReactivePwr // ignore: cast_nullable_to_non_nullable
              as int,
      reactivePwrCal: reactivePwrCal == freezed
          ? _value.reactivePwrCal
          : reactivePwrCal // ignore: cast_nullable_to_non_nullable
              as int,
      pwrFactor: pwrFactor == freezed
          ? _value.pwrFactor
          : pwrFactor // ignore: cast_nullable_to_non_nullable
              as int,
      currCal: currCal == freezed
          ? _value.currCal
          : currCal // ignore: cast_nullable_to_non_nullable
              as int,
      resetCumulEnergy: resetCumulEnergy == freezed
          ? _value.resetCumulEnergy
          : resetCumulEnergy // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidPwrMea implements _SpecificRidPwrMea {
  const _$_SpecificRidPwrMea(
      {required this.instActivePwr,
      required this.minMeaActivePwr,
      required this.maxMeaActivePwr,
      required this.minRangeActivePwr,
      required this.maxRangeActivePwr,
      required this.cumulActivePwr,
      required this.activePwrCal,
      required this.instReactivePwr,
      required this.minMeaReactivePwr,
      required this.maxMeaReactivePwr,
      required this.minRangeReactivePwr,
      required this.maxRangeReactivePwr,
      required this.resetMinMaxMeaValues,
      required this.cumulReactivePwr,
      required this.reactivePwrCal,
      required this.pwrFactor,
      required this.currCal,
      required this.resetCumulEnergy});

  factory _$_SpecificRidPwrMea.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidPwrMeaFromJson(json);

  @override
  final int instActivePwr;
  @override
  final int minMeaActivePwr;
  @override
  final int maxMeaActivePwr;
  @override
  final int minRangeActivePwr;
  @override
  final int maxRangeActivePwr;
  @override
  final int cumulActivePwr;
  @override
  final int activePwrCal;
  @override
  final int instReactivePwr;
  @override
  final int minMeaReactivePwr;
  @override
  final int maxMeaReactivePwr;
  @override
  final int minRangeReactivePwr;
  @override
  final int maxRangeReactivePwr;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int cumulReactivePwr;
  @override
  final int reactivePwrCal;
  @override
  final int pwrFactor;
  @override
  final int currCal;
  @override
  final int resetCumulEnergy;

  @override
  String toString() {
    return 'SpecificRidPwrMea(instActivePwr: $instActivePwr, minMeaActivePwr: $minMeaActivePwr, maxMeaActivePwr: $maxMeaActivePwr, minRangeActivePwr: $minRangeActivePwr, maxRangeActivePwr: $maxRangeActivePwr, cumulActivePwr: $cumulActivePwr, activePwrCal: $activePwrCal, instReactivePwr: $instReactivePwr, minMeaReactivePwr: $minMeaReactivePwr, maxMeaReactivePwr: $maxMeaReactivePwr, minRangeReactivePwr: $minRangeReactivePwr, maxRangeReactivePwr: $maxRangeReactivePwr, resetMinMaxMeaValues: $resetMinMaxMeaValues, cumulReactivePwr: $cumulReactivePwr, reactivePwrCal: $reactivePwrCal, pwrFactor: $pwrFactor, currCal: $currCal, resetCumulEnergy: $resetCumulEnergy)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidPwrMea &&
            (identical(other.instActivePwr, instActivePwr) ||
                const DeepCollectionEquality()
                    .equals(other.instActivePwr, instActivePwr)) &&
            (identical(other.minMeaActivePwr, minMeaActivePwr) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaActivePwr, minMeaActivePwr)) &&
            (identical(other.maxMeaActivePwr, maxMeaActivePwr) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaActivePwr, maxMeaActivePwr)) &&
            (identical(other.minRangeActivePwr, minRangeActivePwr) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeActivePwr, minRangeActivePwr)) &&
            (identical(other.maxRangeActivePwr, maxRangeActivePwr) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeActivePwr, maxRangeActivePwr)) &&
            (identical(other.cumulActivePwr, cumulActivePwr) ||
                const DeepCollectionEquality()
                    .equals(other.cumulActivePwr, cumulActivePwr)) &&
            (identical(other.activePwrCal, activePwrCal) ||
                const DeepCollectionEquality()
                    .equals(other.activePwrCal, activePwrCal)) &&
            (identical(other.instReactivePwr, instReactivePwr) ||
                const DeepCollectionEquality()
                    .equals(other.instReactivePwr, instReactivePwr)) &&
            (identical(other.minMeaReactivePwr, minMeaReactivePwr) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaReactivePwr, minMeaReactivePwr)) &&
            (identical(other.maxMeaReactivePwr, maxMeaReactivePwr) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaReactivePwr, maxMeaReactivePwr)) &&
            (identical(other.minRangeReactivePwr, minRangeReactivePwr) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeReactivePwr, minRangeReactivePwr)) &&
            (identical(other.maxRangeReactivePwr, maxRangeReactivePwr) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeReactivePwr, maxRangeReactivePwr)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.cumulReactivePwr, cumulReactivePwr) ||
                const DeepCollectionEquality()
                    .equals(other.cumulReactivePwr, cumulReactivePwr)) &&
            (identical(other.reactivePwrCal, reactivePwrCal) ||
                const DeepCollectionEquality()
                    .equals(other.reactivePwrCal, reactivePwrCal)) &&
            (identical(other.pwrFactor, pwrFactor) ||
                const DeepCollectionEquality()
                    .equals(other.pwrFactor, pwrFactor)) &&
            (identical(other.currCal, currCal) ||
                const DeepCollectionEquality()
                    .equals(other.currCal, currCal)) &&
            (identical(other.resetCumulEnergy, resetCumulEnergy) ||
                const DeepCollectionEquality()
                    .equals(other.resetCumulEnergy, resetCumulEnergy)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(instActivePwr) ^
      const DeepCollectionEquality().hash(minMeaActivePwr) ^
      const DeepCollectionEquality().hash(maxMeaActivePwr) ^
      const DeepCollectionEquality().hash(minRangeActivePwr) ^
      const DeepCollectionEquality().hash(maxRangeActivePwr) ^
      const DeepCollectionEquality().hash(cumulActivePwr) ^
      const DeepCollectionEquality().hash(activePwrCal) ^
      const DeepCollectionEquality().hash(instReactivePwr) ^
      const DeepCollectionEquality().hash(minMeaReactivePwr) ^
      const DeepCollectionEquality().hash(maxMeaReactivePwr) ^
      const DeepCollectionEquality().hash(minRangeReactivePwr) ^
      const DeepCollectionEquality().hash(maxRangeReactivePwr) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(cumulReactivePwr) ^
      const DeepCollectionEquality().hash(reactivePwrCal) ^
      const DeepCollectionEquality().hash(pwrFactor) ^
      const DeepCollectionEquality().hash(currCal) ^
      const DeepCollectionEquality().hash(resetCumulEnergy);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidPwrMeaCopyWith<_SpecificRidPwrMea> get copyWith =>
      __$SpecificRidPwrMeaCopyWithImpl<_SpecificRidPwrMea>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidPwrMeaToJson(this);
  }
}

abstract class _SpecificRidPwrMea implements SpecificRidPwrMea {
  const factory _SpecificRidPwrMea(
      {required int instActivePwr,
      required int minMeaActivePwr,
      required int maxMeaActivePwr,
      required int minRangeActivePwr,
      required int maxRangeActivePwr,
      required int cumulActivePwr,
      required int activePwrCal,
      required int instReactivePwr,
      required int minMeaReactivePwr,
      required int maxMeaReactivePwr,
      required int minRangeReactivePwr,
      required int maxRangeReactivePwr,
      required int resetMinMaxMeaValues,
      required int cumulReactivePwr,
      required int reactivePwrCal,
      required int pwrFactor,
      required int currCal,
      required int resetCumulEnergy}) = _$_SpecificRidPwrMea;

  factory _SpecificRidPwrMea.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidPwrMea.fromJson;

  @override
  int get instActivePwr => throw _privateConstructorUsedError;
  @override
  int get minMeaActivePwr => throw _privateConstructorUsedError;
  @override
  int get maxMeaActivePwr => throw _privateConstructorUsedError;
  @override
  int get minRangeActivePwr => throw _privateConstructorUsedError;
  @override
  int get maxRangeActivePwr => throw _privateConstructorUsedError;
  @override
  int get cumulActivePwr => throw _privateConstructorUsedError;
  @override
  int get activePwrCal => throw _privateConstructorUsedError;
  @override
  int get instReactivePwr => throw _privateConstructorUsedError;
  @override
  int get minMeaReactivePwr => throw _privateConstructorUsedError;
  @override
  int get maxMeaReactivePwr => throw _privateConstructorUsedError;
  @override
  int get minRangeReactivePwr => throw _privateConstructorUsedError;
  @override
  int get maxRangeReactivePwr => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get cumulReactivePwr => throw _privateConstructorUsedError;
  @override
  int get reactivePwrCal => throw _privateConstructorUsedError;
  @override
  int get pwrFactor => throw _privateConstructorUsedError;
  @override
  int get currCal => throw _privateConstructorUsedError;
  @override
  int get resetCumulEnergy => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidPwrMeaCopyWith<_SpecificRidPwrMea> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidRate _$SpecificRidRateFromJson(Map<String, dynamic> json) {
  return _SpecificRidRate.fromJson(json);
}

/// @nodoc
class _$SpecificRidRateTearOff {
  const _$SpecificRidRateTearOff();

  _SpecificRidRate call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) {
    return _SpecificRidRate(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      calOffset: calOffset,
      appType: appType,
    );
  }

  SpecificRidRate fromJson(Map<String, Object> json) {
    return SpecificRidRate.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidRate = _$SpecificRidRateTearOff();

/// @nodoc
mixin _$SpecificRidRate {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get calOffset => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidRateCopyWith<SpecificRidRate> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidRateCopyWith<$Res> {
  factory $SpecificRidRateCopyWith(
          SpecificRidRate value, $Res Function(SpecificRidRate) then) =
      _$SpecificRidRateCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class _$SpecificRidRateCopyWithImpl<$Res>
    implements $SpecificRidRateCopyWith<$Res> {
  _$SpecificRidRateCopyWithImpl(this._value, this._then);

  final SpecificRidRate _value;
  // ignore: unused_field
  final $Res Function(SpecificRidRate) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidRateCopyWith<$Res>
    implements $SpecificRidRateCopyWith<$Res> {
  factory _$SpecificRidRateCopyWith(
          _SpecificRidRate value, $Res Function(_SpecificRidRate) then) =
      __$SpecificRidRateCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class __$SpecificRidRateCopyWithImpl<$Res>
    extends _$SpecificRidRateCopyWithImpl<$Res>
    implements _$SpecificRidRateCopyWith<$Res> {
  __$SpecificRidRateCopyWithImpl(
      _SpecificRidRate _value, $Res Function(_SpecificRidRate) _then)
      : super(_value, (v) => _then(v as _SpecificRidRate));

  @override
  _SpecificRidRate get _value => super._value as _SpecificRidRate;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidRate(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidRate implements _SpecificRidRate {
  const _$_SpecificRidRate(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues,
      required this.calOffset,
      required this.appType});

  factory _$_SpecificRidRate.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidRateFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int calOffset;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidRate(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, calOffset: $calOffset, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidRate &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.calOffset, calOffset) ||
                const DeepCollectionEquality()
                    .equals(other.calOffset, calOffset)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(calOffset) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidRateCopyWith<_SpecificRidRate> get copyWith =>
      __$SpecificRidRateCopyWithImpl<_SpecificRidRate>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidRateToJson(this);
  }
}

abstract class _SpecificRidRate implements SpecificRidRate {
  const factory _SpecificRidRate(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) = _$_SpecificRidRate;

  factory _SpecificRidRate.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidRate.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get calOffset => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidRateCopyWith<_SpecificRidRate> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidTemperature _$SpecificRidTemperatureFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidTemperature.fromJson(json);
}

/// @nodoc
class _$SpecificRidTemperatureTearOff {
  const _$SpecificRidTemperatureTearOff();

  _SpecificRidTemperature call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues}) {
    return _SpecificRidTemperature(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
    );
  }

  SpecificRidTemperature fromJson(Map<String, Object> json) {
    return SpecificRidTemperature.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidTemperature = _$SpecificRidTemperatureTearOff();

/// @nodoc
mixin _$SpecificRidTemperature {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidTemperatureCopyWith<SpecificRidTemperature> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidTemperatureCopyWith<$Res> {
  factory $SpecificRidTemperatureCopyWith(SpecificRidTemperature value,
          $Res Function(SpecificRidTemperature) then) =
      _$SpecificRidTemperatureCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues});
}

/// @nodoc
class _$SpecificRidTemperatureCopyWithImpl<$Res>
    implements $SpecificRidTemperatureCopyWith<$Res> {
  _$SpecificRidTemperatureCopyWithImpl(this._value, this._then);

  final SpecificRidTemperature _value;
  // ignore: unused_field
  final $Res Function(SpecificRidTemperature) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidTemperatureCopyWith<$Res>
    implements $SpecificRidTemperatureCopyWith<$Res> {
  factory _$SpecificRidTemperatureCopyWith(_SpecificRidTemperature value,
          $Res Function(_SpecificRidTemperature) then) =
      __$SpecificRidTemperatureCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues});
}

/// @nodoc
class __$SpecificRidTemperatureCopyWithImpl<$Res>
    extends _$SpecificRidTemperatureCopyWithImpl<$Res>
    implements _$SpecificRidTemperatureCopyWith<$Res> {
  __$SpecificRidTemperatureCopyWithImpl(_SpecificRidTemperature _value,
      $Res Function(_SpecificRidTemperature) _then)
      : super(_value, (v) => _then(v as _SpecificRidTemperature));

  @override
  _SpecificRidTemperature get _value => super._value as _SpecificRidTemperature;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
  }) {
    return _then(_SpecificRidTemperature(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidTemperature implements _SpecificRidTemperature {
  const _$_SpecificRidTemperature(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues});

  factory _$_SpecificRidTemperature.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidTemperatureFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;

  @override
  String toString() {
    return 'SpecificRidTemperature(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidTemperature &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality()
                    .equals(other.resetMinMaxMeaValues, resetMinMaxMeaValues)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidTemperatureCopyWith<_SpecificRidTemperature> get copyWith =>
      __$SpecificRidTemperatureCopyWithImpl<_SpecificRidTemperature>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidTemperatureToJson(this);
  }
}

abstract class _SpecificRidTemperature implements SpecificRidTemperature {
  const factory _SpecificRidTemperature(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues}) = _$_SpecificRidTemperature;

  factory _SpecificRidTemperature.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidTemperature.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidTemperatureCopyWith<_SpecificRidTemperature> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidTime _$SpecificRidTimeFromJson(Map<String, dynamic> json) {
  return _SpecificRidTime.fromJson(json);
}

/// @nodoc
class _$SpecificRidTimeTearOff {
  const _$SpecificRidTimeTearOff();

  _SpecificRidTime call(
      {required int currentTime, required int fracTime, required int appType}) {
    return _SpecificRidTime(
      currentTime: currentTime,
      fracTime: fracTime,
      appType: appType,
    );
  }

  SpecificRidTime fromJson(Map<String, Object> json) {
    return SpecificRidTime.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidTime = _$SpecificRidTimeTearOff();

/// @nodoc
mixin _$SpecificRidTime {
  int get currentTime => throw _privateConstructorUsedError;
  int get fracTime => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidTimeCopyWith<SpecificRidTime> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidTimeCopyWith<$Res> {
  factory $SpecificRidTimeCopyWith(
          SpecificRidTime value, $Res Function(SpecificRidTime) then) =
      _$SpecificRidTimeCopyWithImpl<$Res>;
  $Res call({int currentTime, int fracTime, int appType});
}

/// @nodoc
class _$SpecificRidTimeCopyWithImpl<$Res>
    implements $SpecificRidTimeCopyWith<$Res> {
  _$SpecificRidTimeCopyWithImpl(this._value, this._then);

  final SpecificRidTime _value;
  // ignore: unused_field
  final $Res Function(SpecificRidTime) _then;

  @override
  $Res call({
    Object? currentTime = freezed,
    Object? fracTime = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      currentTime: currentTime == freezed
          ? _value.currentTime
          : currentTime // ignore: cast_nullable_to_non_nullable
              as int,
      fracTime: fracTime == freezed
          ? _value.fracTime
          : fracTime // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidTimeCopyWith<$Res>
    implements $SpecificRidTimeCopyWith<$Res> {
  factory _$SpecificRidTimeCopyWith(
          _SpecificRidTime value, $Res Function(_SpecificRidTime) then) =
      __$SpecificRidTimeCopyWithImpl<$Res>;
  @override
  $Res call({int currentTime, int fracTime, int appType});
}

/// @nodoc
class __$SpecificRidTimeCopyWithImpl<$Res>
    extends _$SpecificRidTimeCopyWithImpl<$Res>
    implements _$SpecificRidTimeCopyWith<$Res> {
  __$SpecificRidTimeCopyWithImpl(
      _SpecificRidTime _value, $Res Function(_SpecificRidTime) _then)
      : super(_value, (v) => _then(v as _SpecificRidTime));

  @override
  _SpecificRidTime get _value => super._value as _SpecificRidTime;

  @override
  $Res call({
    Object? currentTime = freezed,
    Object? fracTime = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidTime(
      currentTime: currentTime == freezed
          ? _value.currentTime
          : currentTime // ignore: cast_nullable_to_non_nullable
              as int,
      fracTime: fracTime == freezed
          ? _value.fracTime
          : fracTime // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidTime implements _SpecificRidTime {
  const _$_SpecificRidTime(
      {required this.currentTime,
      required this.fracTime,
      required this.appType});

  factory _$_SpecificRidTime.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidTimeFromJson(json);

  @override
  final int currentTime;
  @override
  final int fracTime;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidTime(currentTime: $currentTime, fracTime: $fracTime, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidTime &&
            (identical(other.currentTime, currentTime) ||
                const DeepCollectionEquality()
                    .equals(other.currentTime, currentTime)) &&
            (identical(other.fracTime, fracTime) ||
                const DeepCollectionEquality()
                    .equals(other.fracTime, fracTime)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(currentTime) ^
      const DeepCollectionEquality().hash(fracTime) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidTimeCopyWith<_SpecificRidTime> get copyWith =>
      __$SpecificRidTimeCopyWithImpl<_SpecificRidTime>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidTimeToJson(this);
  }
}

abstract class _SpecificRidTime implements SpecificRidTime {
  const factory _SpecificRidTime(
      {required int currentTime,
      required int fracTime,
      required int appType}) = _$_SpecificRidTime;

  factory _SpecificRidTime.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidTime.fromJson;

  @override
  int get currentTime => throw _privateConstructorUsedError;
  @override
  int get fracTime => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidTimeCopyWith<_SpecificRidTime> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidTimer _$SpecificRidTimerFromJson(Map<String, dynamic> json) {
  return _SpecificRidTimer.fromJson(json);
}

/// @nodoc
class _$SpecificRidTimerTearOff {
  const _$SpecificRidTimerTearOff();

  _SpecificRidTimer call(
      {required int timeDuration,
      required int remainTime,
      required int minOffTime,
      required int trigger,
      required int onOff,
      required int counter,
      required int cumulTime,
      required int digitalState,
      required int eventCounter,
      required int mode,
      required int appType}) {
    return _SpecificRidTimer(
      timeDuration: timeDuration,
      remainTime: remainTime,
      minOffTime: minOffTime,
      trigger: trigger,
      onOff: onOff,
      counter: counter,
      cumulTime: cumulTime,
      digitalState: digitalState,
      eventCounter: eventCounter,
      mode: mode,
      appType: appType,
    );
  }

  SpecificRidTimer fromJson(Map<String, Object> json) {
    return SpecificRidTimer.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidTimer = _$SpecificRidTimerTearOff();

/// @nodoc
mixin _$SpecificRidTimer {
  int get timeDuration => throw _privateConstructorUsedError;
  int get remainTime => throw _privateConstructorUsedError;
  int get minOffTime => throw _privateConstructorUsedError;
  int get trigger => throw _privateConstructorUsedError;
  int get onOff => throw _privateConstructorUsedError;
  int get counter => throw _privateConstructorUsedError;
  int get cumulTime => throw _privateConstructorUsedError;
  int get digitalState => throw _privateConstructorUsedError;
  int get eventCounter => throw _privateConstructorUsedError;
  int get mode => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidTimerCopyWith<SpecificRidTimer> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidTimerCopyWith<$Res> {
  factory $SpecificRidTimerCopyWith(
          SpecificRidTimer value, $Res Function(SpecificRidTimer) then) =
      _$SpecificRidTimerCopyWithImpl<$Res>;
  $Res call(
      {int timeDuration,
      int remainTime,
      int minOffTime,
      int trigger,
      int onOff,
      int counter,
      int cumulTime,
      int digitalState,
      int eventCounter,
      int mode,
      int appType});
}

/// @nodoc
class _$SpecificRidTimerCopyWithImpl<$Res>
    implements $SpecificRidTimerCopyWith<$Res> {
  _$SpecificRidTimerCopyWithImpl(this._value, this._then);

  final SpecificRidTimer _value;
  // ignore: unused_field
  final $Res Function(SpecificRidTimer) _then;

  @override
  $Res call({
    Object? timeDuration = freezed,
    Object? remainTime = freezed,
    Object? minOffTime = freezed,
    Object? trigger = freezed,
    Object? onOff = freezed,
    Object? counter = freezed,
    Object? cumulTime = freezed,
    Object? digitalState = freezed,
    Object? eventCounter = freezed,
    Object? mode = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      timeDuration: timeDuration == freezed
          ? _value.timeDuration
          : timeDuration // ignore: cast_nullable_to_non_nullable
              as int,
      remainTime: remainTime == freezed
          ? _value.remainTime
          : remainTime // ignore: cast_nullable_to_non_nullable
              as int,
      minOffTime: minOffTime == freezed
          ? _value.minOffTime
          : minOffTime // ignore: cast_nullable_to_non_nullable
              as int,
      trigger: trigger == freezed
          ? _value.trigger
          : trigger // ignore: cast_nullable_to_non_nullable
              as int,
      onOff: onOff == freezed
          ? _value.onOff
          : onOff // ignore: cast_nullable_to_non_nullable
              as int,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as int,
      cumulTime: cumulTime == freezed
          ? _value.cumulTime
          : cumulTime // ignore: cast_nullable_to_non_nullable
              as int,
      digitalState: digitalState == freezed
          ? _value.digitalState
          : digitalState // ignore: cast_nullable_to_non_nullable
              as int,
      eventCounter: eventCounter == freezed
          ? _value.eventCounter
          : eventCounter // ignore: cast_nullable_to_non_nullable
              as int,
      mode: mode == freezed
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidTimerCopyWith<$Res>
    implements $SpecificRidTimerCopyWith<$Res> {
  factory _$SpecificRidTimerCopyWith(
          _SpecificRidTimer value, $Res Function(_SpecificRidTimer) then) =
      __$SpecificRidTimerCopyWithImpl<$Res>;
  @override
  $Res call(
      {int timeDuration,
      int remainTime,
      int minOffTime,
      int trigger,
      int onOff,
      int counter,
      int cumulTime,
      int digitalState,
      int eventCounter,
      int mode,
      int appType});
}

/// @nodoc
class __$SpecificRidTimerCopyWithImpl<$Res>
    extends _$SpecificRidTimerCopyWithImpl<$Res>
    implements _$SpecificRidTimerCopyWith<$Res> {
  __$SpecificRidTimerCopyWithImpl(
      _SpecificRidTimer _value, $Res Function(_SpecificRidTimer) _then)
      : super(_value, (v) => _then(v as _SpecificRidTimer));

  @override
  _SpecificRidTimer get _value => super._value as _SpecificRidTimer;

  @override
  $Res call({
    Object? timeDuration = freezed,
    Object? remainTime = freezed,
    Object? minOffTime = freezed,
    Object? trigger = freezed,
    Object? onOff = freezed,
    Object? counter = freezed,
    Object? cumulTime = freezed,
    Object? digitalState = freezed,
    Object? eventCounter = freezed,
    Object? mode = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidTimer(
      timeDuration: timeDuration == freezed
          ? _value.timeDuration
          : timeDuration // ignore: cast_nullable_to_non_nullable
              as int,
      remainTime: remainTime == freezed
          ? _value.remainTime
          : remainTime // ignore: cast_nullable_to_non_nullable
              as int,
      minOffTime: minOffTime == freezed
          ? _value.minOffTime
          : minOffTime // ignore: cast_nullable_to_non_nullable
              as int,
      trigger: trigger == freezed
          ? _value.trigger
          : trigger // ignore: cast_nullable_to_non_nullable
              as int,
      onOff: onOff == freezed
          ? _value.onOff
          : onOff // ignore: cast_nullable_to_non_nullable
              as int,
      counter: counter == freezed
          ? _value.counter
          : counter // ignore: cast_nullable_to_non_nullable
              as int,
      cumulTime: cumulTime == freezed
          ? _value.cumulTime
          : cumulTime // ignore: cast_nullable_to_non_nullable
              as int,
      digitalState: digitalState == freezed
          ? _value.digitalState
          : digitalState // ignore: cast_nullable_to_non_nullable
              as int,
      eventCounter: eventCounter == freezed
          ? _value.eventCounter
          : eventCounter // ignore: cast_nullable_to_non_nullable
              as int,
      mode: mode == freezed
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidTimer implements _SpecificRidTimer {
  const _$_SpecificRidTimer(
      {required this.timeDuration,
      required this.remainTime,
      required this.minOffTime,
      required this.trigger,
      required this.onOff,
      required this.counter,
      required this.cumulTime,
      required this.digitalState,
      required this.eventCounter,
      required this.mode,
      required this.appType});

  factory _$_SpecificRidTimer.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidTimerFromJson(json);

  @override
  final int timeDuration;
  @override
  final int remainTime;
  @override
  final int minOffTime;
  @override
  final int trigger;
  @override
  final int onOff;
  @override
  final int counter;
  @override
  final int cumulTime;
  @override
  final int digitalState;
  @override
  final int eventCounter;
  @override
  final int mode;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidTimer(timeDuration: $timeDuration, remainTime: $remainTime, minOffTime: $minOffTime, trigger: $trigger, onOff: $onOff, counter: $counter, cumulTime: $cumulTime, digitalState: $digitalState, eventCounter: $eventCounter, mode: $mode, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidTimer &&
            (identical(other.timeDuration, timeDuration) ||
                const DeepCollectionEquality()
                    .equals(other.timeDuration, timeDuration)) &&
            (identical(other.remainTime, remainTime) ||
                const DeepCollectionEquality()
                    .equals(other.remainTime, remainTime)) &&
            (identical(other.minOffTime, minOffTime) ||
                const DeepCollectionEquality()
                    .equals(other.minOffTime, minOffTime)) &&
            (identical(other.trigger, trigger) ||
                const DeepCollectionEquality()
                    .equals(other.trigger, trigger)) &&
            (identical(other.onOff, onOff) ||
                const DeepCollectionEquality().equals(other.onOff, onOff)) &&
            (identical(other.counter, counter) ||
                const DeepCollectionEquality()
                    .equals(other.counter, counter)) &&
            (identical(other.cumulTime, cumulTime) ||
                const DeepCollectionEquality()
                    .equals(other.cumulTime, cumulTime)) &&
            (identical(other.digitalState, digitalState) ||
                const DeepCollectionEquality()
                    .equals(other.digitalState, digitalState)) &&
            (identical(other.eventCounter, eventCounter) ||
                const DeepCollectionEquality()
                    .equals(other.eventCounter, eventCounter)) &&
            (identical(other.mode, mode) ||
                const DeepCollectionEquality().equals(other.mode, mode)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(timeDuration) ^
      const DeepCollectionEquality().hash(remainTime) ^
      const DeepCollectionEquality().hash(minOffTime) ^
      const DeepCollectionEquality().hash(trigger) ^
      const DeepCollectionEquality().hash(onOff) ^
      const DeepCollectionEquality().hash(counter) ^
      const DeepCollectionEquality().hash(cumulTime) ^
      const DeepCollectionEquality().hash(digitalState) ^
      const DeepCollectionEquality().hash(eventCounter) ^
      const DeepCollectionEquality().hash(mode) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidTimerCopyWith<_SpecificRidTimer> get copyWith =>
      __$SpecificRidTimerCopyWithImpl<_SpecificRidTimer>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidTimerToJson(this);
  }
}

abstract class _SpecificRidTimer implements SpecificRidTimer {
  const factory _SpecificRidTimer(
      {required int timeDuration,
      required int remainTime,
      required int minOffTime,
      required int trigger,
      required int onOff,
      required int counter,
      required int cumulTime,
      required int digitalState,
      required int eventCounter,
      required int mode,
      required int appType}) = _$_SpecificRidTimer;

  factory _SpecificRidTimer.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidTimer.fromJson;

  @override
  int get timeDuration => throw _privateConstructorUsedError;
  @override
  int get remainTime => throw _privateConstructorUsedError;
  @override
  int get minOffTime => throw _privateConstructorUsedError;
  @override
  int get trigger => throw _privateConstructorUsedError;
  @override
  int get onOff => throw _privateConstructorUsedError;
  @override
  int get counter => throw _privateConstructorUsedError;
  @override
  int get cumulTime => throw _privateConstructorUsedError;
  @override
  int get digitalState => throw _privateConstructorUsedError;
  @override
  int get eventCounter => throw _privateConstructorUsedError;
  @override
  int get mode => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidTimerCopyWith<_SpecificRidTimer> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidUpDownControl _$SpecificRidUpDownControlFromJson(
    Map<String, dynamic> json) {
  return _SpecificRidUpDownControl.fromJson(json);
}

/// @nodoc
class _$SpecificRidUpDownControlTearOff {
  const _$SpecificRidUpDownControlTearOff();

  _SpecificRidUpDownControl call(
      {required int incInputState,
      required int decInputState,
      required int upCounter,
      required int downCounter,
      required int appType}) {
    return _SpecificRidUpDownControl(
      incInputState: incInputState,
      decInputState: decInputState,
      upCounter: upCounter,
      downCounter: downCounter,
      appType: appType,
    );
  }

  SpecificRidUpDownControl fromJson(Map<String, Object> json) {
    return SpecificRidUpDownControl.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidUpDownControl = _$SpecificRidUpDownControlTearOff();

/// @nodoc
mixin _$SpecificRidUpDownControl {
  int get incInputState => throw _privateConstructorUsedError;
  int get decInputState => throw _privateConstructorUsedError;
  int get upCounter => throw _privateConstructorUsedError;
  int get downCounter => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidUpDownControlCopyWith<SpecificRidUpDownControl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidUpDownControlCopyWith<$Res> {
  factory $SpecificRidUpDownControlCopyWith(SpecificRidUpDownControl value,
          $Res Function(SpecificRidUpDownControl) then) =
      _$SpecificRidUpDownControlCopyWithImpl<$Res>;
  $Res call(
      {int incInputState,
      int decInputState,
      int upCounter,
      int downCounter,
      int appType});
}

/// @nodoc
class _$SpecificRidUpDownControlCopyWithImpl<$Res>
    implements $SpecificRidUpDownControlCopyWith<$Res> {
  _$SpecificRidUpDownControlCopyWithImpl(this._value, this._then);

  final SpecificRidUpDownControl _value;
  // ignore: unused_field
  final $Res Function(SpecificRidUpDownControl) _then;

  @override
  $Res call({
    Object? incInputState = freezed,
    Object? decInputState = freezed,
    Object? upCounter = freezed,
    Object? downCounter = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      incInputState: incInputState == freezed
          ? _value.incInputState
          : incInputState // ignore: cast_nullable_to_non_nullable
              as int,
      decInputState: decInputState == freezed
          ? _value.decInputState
          : decInputState // ignore: cast_nullable_to_non_nullable
              as int,
      upCounter: upCounter == freezed
          ? _value.upCounter
          : upCounter // ignore: cast_nullable_to_non_nullable
              as int,
      downCounter: downCounter == freezed
          ? _value.downCounter
          : downCounter // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidUpDownControlCopyWith<$Res>
    implements $SpecificRidUpDownControlCopyWith<$Res> {
  factory _$SpecificRidUpDownControlCopyWith(_SpecificRidUpDownControl value,
          $Res Function(_SpecificRidUpDownControl) then) =
      __$SpecificRidUpDownControlCopyWithImpl<$Res>;
  @override
  $Res call(
      {int incInputState,
      int decInputState,
      int upCounter,
      int downCounter,
      int appType});
}

/// @nodoc
class __$SpecificRidUpDownControlCopyWithImpl<$Res>
    extends _$SpecificRidUpDownControlCopyWithImpl<$Res>
    implements _$SpecificRidUpDownControlCopyWith<$Res> {
  __$SpecificRidUpDownControlCopyWithImpl(_SpecificRidUpDownControl _value,
      $Res Function(_SpecificRidUpDownControl) _then)
      : super(_value, (v) => _then(v as _SpecificRidUpDownControl));

  @override
  _SpecificRidUpDownControl get _value =>
      super._value as _SpecificRidUpDownControl;

  @override
  $Res call({
    Object? incInputState = freezed,
    Object? decInputState = freezed,
    Object? upCounter = freezed,
    Object? downCounter = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidUpDownControl(
      incInputState: incInputState == freezed
          ? _value.incInputState
          : incInputState // ignore: cast_nullable_to_non_nullable
              as int,
      decInputState: decInputState == freezed
          ? _value.decInputState
          : decInputState // ignore: cast_nullable_to_non_nullable
              as int,
      upCounter: upCounter == freezed
          ? _value.upCounter
          : upCounter // ignore: cast_nullable_to_non_nullable
              as int,
      downCounter: downCounter == freezed
          ? _value.downCounter
          : downCounter // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidUpDownControl implements _SpecificRidUpDownControl {
  const _$_SpecificRidUpDownControl(
      {required this.incInputState,
      required this.decInputState,
      required this.upCounter,
      required this.downCounter,
      required this.appType});

  factory _$_SpecificRidUpDownControl.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidUpDownControlFromJson(json);

  @override
  final int incInputState;
  @override
  final int decInputState;
  @override
  final int upCounter;
  @override
  final int downCounter;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidUpDownControl(incInputState: $incInputState, decInputState: $decInputState, upCounter: $upCounter, downCounter: $downCounter, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidUpDownControl &&
            (identical(other.incInputState, incInputState) ||
                const DeepCollectionEquality()
                    .equals(other.incInputState, incInputState)) &&
            (identical(other.decInputState, decInputState) ||
                const DeepCollectionEquality()
                    .equals(other.decInputState, decInputState)) &&
            (identical(other.upCounter, upCounter) ||
                const DeepCollectionEquality()
                    .equals(other.upCounter, upCounter)) &&
            (identical(other.downCounter, downCounter) ||
                const DeepCollectionEquality()
                    .equals(other.downCounter, downCounter)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(incInputState) ^
      const DeepCollectionEquality().hash(decInputState) ^
      const DeepCollectionEquality().hash(upCounter) ^
      const DeepCollectionEquality().hash(downCounter) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidUpDownControlCopyWith<_SpecificRidUpDownControl> get copyWith =>
      __$SpecificRidUpDownControlCopyWithImpl<_SpecificRidUpDownControl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidUpDownControlToJson(this);
  }
}

abstract class _SpecificRidUpDownControl implements SpecificRidUpDownControl {
  const factory _SpecificRidUpDownControl(
      {required int incInputState,
      required int decInputState,
      required int upCounter,
      required int downCounter,
      required int appType}) = _$_SpecificRidUpDownControl;

  factory _SpecificRidUpDownControl.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidUpDownControl.fromJson;

  @override
  int get incInputState => throw _privateConstructorUsedError;
  @override
  int get decInputState => throw _privateConstructorUsedError;
  @override
  int get upCounter => throw _privateConstructorUsedError;
  @override
  int get downCounter => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidUpDownControlCopyWith<_SpecificRidUpDownControl> get copyWith =>
      throw _privateConstructorUsedError;
}

SpecificRidVoltage _$SpecificRidVoltageFromJson(Map<String, dynamic> json) {
  return _SpecificRidVoltage.fromJson(json);
}

/// @nodoc
class _$SpecificRidVoltageTearOff {
  const _$SpecificRidVoltageTearOff();

  _SpecificRidVoltage call(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) {
    return _SpecificRidVoltage(
      sensorValue: sensorValue,
      units: units,
      minMeaValue: minMeaValue,
      maxMeaValue: maxMeaValue,
      minRangeValue: minRangeValue,
      maxRangeValue: maxRangeValue,
      resetMinMaxMeaValues: resetMinMaxMeaValues,
      calOffset: calOffset,
      appType: appType,
    );
  }

  SpecificRidVoltage fromJson(Map<String, Object> json) {
    return SpecificRidVoltage.fromJson(json);
  }
}

/// @nodoc
const $SpecificRidVoltage = _$SpecificRidVoltageTearOff();

/// @nodoc
mixin _$SpecificRidVoltage {
  int get sensorValue => throw _privateConstructorUsedError;
  int get units => throw _privateConstructorUsedError;
  int get minMeaValue => throw _privateConstructorUsedError;
  int get maxMeaValue => throw _privateConstructorUsedError;
  int get minRangeValue => throw _privateConstructorUsedError;
  int get maxRangeValue => throw _privateConstructorUsedError;
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  int get calOffset => throw _privateConstructorUsedError;
  int get appType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SpecificRidVoltageCopyWith<SpecificRidVoltage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecificRidVoltageCopyWith<$Res> {
  factory $SpecificRidVoltageCopyWith(
          SpecificRidVoltage value, $Res Function(SpecificRidVoltage) then) =
      _$SpecificRidVoltageCopyWithImpl<$Res>;
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class _$SpecificRidVoltageCopyWithImpl<$Res>
    implements $SpecificRidVoltageCopyWith<$Res> {
  _$SpecificRidVoltageCopyWithImpl(this._value, this._then);

  final SpecificRidVoltage _value;
  // ignore: unused_field
  final $Res Function(SpecificRidVoltage) _then;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_value.copyWith(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$SpecificRidVoltageCopyWith<$Res>
    implements $SpecificRidVoltageCopyWith<$Res> {
  factory _$SpecificRidVoltageCopyWith(
          _SpecificRidVoltage value, $Res Function(_SpecificRidVoltage) then) =
      __$SpecificRidVoltageCopyWithImpl<$Res>;
  @override
  $Res call(
      {int sensorValue,
      int units,
      int minMeaValue,
      int maxMeaValue,
      int minRangeValue,
      int maxRangeValue,
      int resetMinMaxMeaValues,
      int calOffset,
      int appType});
}

/// @nodoc
class __$SpecificRidVoltageCopyWithImpl<$Res>
    extends _$SpecificRidVoltageCopyWithImpl<$Res>
    implements _$SpecificRidVoltageCopyWith<$Res> {
  __$SpecificRidVoltageCopyWithImpl(
      _SpecificRidVoltage _value, $Res Function(_SpecificRidVoltage) _then)
      : super(_value, (v) => _then(v as _SpecificRidVoltage));

  @override
  _SpecificRidVoltage get _value => super._value as _SpecificRidVoltage;

  @override
  $Res call({
    Object? sensorValue = freezed,
    Object? units = freezed,
    Object? minMeaValue = freezed,
    Object? maxMeaValue = freezed,
    Object? minRangeValue = freezed,
    Object? maxRangeValue = freezed,
    Object? resetMinMaxMeaValues = freezed,
    Object? calOffset = freezed,
    Object? appType = freezed,
  }) {
    return _then(_SpecificRidVoltage(
      sensorValue: sensorValue == freezed
          ? _value.sensorValue
          : sensorValue // ignore: cast_nullable_to_non_nullable
              as int,
      units: units == freezed
          ? _value.units
          : units // ignore: cast_nullable_to_non_nullable
              as int,
      minMeaValue: minMeaValue == freezed
          ? _value.minMeaValue
          : minMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxMeaValue: maxMeaValue == freezed
          ? _value.maxMeaValue
          : maxMeaValue // ignore: cast_nullable_to_non_nullable
              as int,
      minRangeValue: minRangeValue == freezed
          ? _value.minRangeValue
          : minRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxRangeValue: maxRangeValue == freezed
          ? _value.maxRangeValue
          : maxRangeValue // ignore: cast_nullable_to_non_nullable
              as int,
      resetMinMaxMeaValues: resetMinMaxMeaValues == freezed
          ? _value.resetMinMaxMeaValues
          : resetMinMaxMeaValues // ignore: cast_nullable_to_non_nullable
              as int,
      calOffset: calOffset == freezed
          ? _value.calOffset
          : calOffset // ignore: cast_nullable_to_non_nullable
              as int,
      appType: appType == freezed
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SpecificRidVoltage implements _SpecificRidVoltage {
  const _$_SpecificRidVoltage(
      {required this.sensorValue,
      required this.units,
      required this.minMeaValue,
      required this.maxMeaValue,
      required this.minRangeValue,
      required this.maxRangeValue,
      required this.resetMinMaxMeaValues,
      required this.calOffset,
      required this.appType});

  factory _$_SpecificRidVoltage.fromJson(Map<String, dynamic> json) =>
      _$$_SpecificRidVoltageFromJson(json);

  @override
  final int sensorValue;
  @override
  final int units;
  @override
  final int minMeaValue;
  @override
  final int maxMeaValue;
  @override
  final int minRangeValue;
  @override
  final int maxRangeValue;
  @override
  final int resetMinMaxMeaValues;
  @override
  final int calOffset;
  @override
  final int appType;

  @override
  String toString() {
    return 'SpecificRidVoltage(sensorValue: $sensorValue, units: $units, minMeaValue: $minMeaValue, maxMeaValue: $maxMeaValue, minRangeValue: $minRangeValue, maxRangeValue: $maxRangeValue, resetMinMaxMeaValues: $resetMinMaxMeaValues, calOffset: $calOffset, appType: $appType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecificRidVoltage &&
            (identical(other.sensorValue, sensorValue) ||
                const DeepCollectionEquality()
                    .equals(other.sensorValue, sensorValue)) &&
            (identical(other.units, units) ||
                const DeepCollectionEquality().equals(other.units, units)) &&
            (identical(other.minMeaValue, minMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.minMeaValue, minMeaValue)) &&
            (identical(other.maxMeaValue, maxMeaValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxMeaValue, maxMeaValue)) &&
            (identical(other.minRangeValue, minRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.minRangeValue, minRangeValue)) &&
            (identical(other.maxRangeValue, maxRangeValue) ||
                const DeepCollectionEquality()
                    .equals(other.maxRangeValue, maxRangeValue)) &&
            (identical(other.resetMinMaxMeaValues, resetMinMaxMeaValues) ||
                const DeepCollectionEquality().equals(
                    other.resetMinMaxMeaValues, resetMinMaxMeaValues)) &&
            (identical(other.calOffset, calOffset) ||
                const DeepCollectionEquality()
                    .equals(other.calOffset, calOffset)) &&
            (identical(other.appType, appType) ||
                const DeepCollectionEquality().equals(other.appType, appType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(sensorValue) ^
      const DeepCollectionEquality().hash(units) ^
      const DeepCollectionEquality().hash(minMeaValue) ^
      const DeepCollectionEquality().hash(maxMeaValue) ^
      const DeepCollectionEquality().hash(minRangeValue) ^
      const DeepCollectionEquality().hash(maxRangeValue) ^
      const DeepCollectionEquality().hash(resetMinMaxMeaValues) ^
      const DeepCollectionEquality().hash(calOffset) ^
      const DeepCollectionEquality().hash(appType);

  @JsonKey(ignore: true)
  @override
  _$SpecificRidVoltageCopyWith<_SpecificRidVoltage> get copyWith =>
      __$SpecificRidVoltageCopyWithImpl<_SpecificRidVoltage>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SpecificRidVoltageToJson(this);
  }
}

abstract class _SpecificRidVoltage implements SpecificRidVoltage {
  const factory _SpecificRidVoltage(
      {required int sensorValue,
      required int units,
      required int minMeaValue,
      required int maxMeaValue,
      required int minRangeValue,
      required int maxRangeValue,
      required int resetMinMaxMeaValues,
      required int calOffset,
      required int appType}) = _$_SpecificRidVoltage;

  factory _SpecificRidVoltage.fromJson(Map<String, dynamic> json) =
      _$_SpecificRidVoltage.fromJson;

  @override
  int get sensorValue => throw _privateConstructorUsedError;
  @override
  int get units => throw _privateConstructorUsedError;
  @override
  int get minMeaValue => throw _privateConstructorUsedError;
  @override
  int get maxMeaValue => throw _privateConstructorUsedError;
  @override
  int get minRangeValue => throw _privateConstructorUsedError;
  @override
  int get maxRangeValue => throw _privateConstructorUsedError;
  @override
  int get resetMinMaxMeaValues => throw _privateConstructorUsedError;
  @override
  int get calOffset => throw _privateConstructorUsedError;
  @override
  int get appType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SpecificRidVoltageCopyWith<_SpecificRidVoltage> get copyWith =>
      throw _privateConstructorUsedError;
}
